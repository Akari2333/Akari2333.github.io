<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一讲 基础算法 04高精度</title>
      <link href="/posts/6862/"/>
      <url>/posts/6862/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.cnblogs.com/littlehb/p/14981155.html">AcWing 高精度模板 - 糖豆爸爸 - 博客园</a><br><a href="https://www.acwing.com/blog/content/4018/">AcWing《算法基础课》第1章 算法基础 - AcWing</a><br><a href="https://blog.csdn.net/qq_45438600/article/details/116795979">AcWing 算法基础课笔记 1.基础算法-CSDN博客</a></p></blockquote><hr><h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="一、大整数的存储"><a href="#一、大整数的存储" class="headerlink" title="一、大整数的存储"></a>一、大整数的存储</h2><ol><li>当输入的数很大时，可采用字符串方式接收。</li><li>拆成一位一位的数字，把它们存在一个数组中，一个数组元素表示一位数字</li></ol><p>数组中是这样存储的：<strong>逆序存储</strong></p><table><thead><tr><th align="center">数组下标</th><th align="center">a[0]</th><th align="center">a[1]</th><th align="center">a[2]</th><th align="center">a[3]</th><th align="center">a[4]</th><th align="center">a[5]</th></tr></thead><tbody><tr><td align="center">原数</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">-</td></tr><tr><td align="center">存储数</td><td align="center">5</td><td align="center">4</td><td align="center">3</td><td align="center">2</td><td align="center">1</td><td align="center">-</td></tr></tbody></table><p><strong>倒序存储原因：</strong><br>在平常，数字从左到右依次为从高位到低位….可这里却与日常的习惯相反。<br>因为整数相加要进位，当最高位要进位的时候，我们在数组的末尾使用 <code>push_back()</code> 加一位即可，较方便。反之，在头部加一位要将整个数组后移，较麻烦。</p><blockquote><ul><li>大整数<strong>低位</strong>存放在<strong>数组低地址</strong>处，<strong>高位</strong>存放在<strong>数组高地址</strong>处<ul><li>数组地址由低位到高位 <strong>（0 → n - 1）</strong></li><li>整数位数最左边是高位，最右边是低位（高位→低位）</li></ul></li><li>读取数组时反向(n-1→0)遍历，运算时正向(0→n-1)遍历</li></ul></blockquote><h2 id="二、大整数比较"><a href="#二、大整数比较" class="headerlink" title="二、大整数比较"></a>二、大整数比较</h2><p>分两种情况：位数一致、位数不一致时。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A &gt;= B返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;      <span class="comment">// 引用效率高，只需要传首地址</span></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();   <span class="comment">// 位数不一致时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)     <span class="comment">// 位数一致时，从最高位开始比</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、高精度加法"><a href="#三、高精度加法" class="headerlink" title="三、高精度加法"></a>三、高精度加法</h2><p>比如：1234 + 567 模拟一下：<br><img src="https://telegraph-image-box.pages.dev/file/7771a7e91a259aa95647d.png" alt="1"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span>     <span class="comment">// 默认 A &gt; B</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;      <span class="comment">// t 存储进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )&#123;   <span class="comment">// 以位数较大的 A 来遍历</span></span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];        <span class="comment">// 如果 B 还有剩余（A：1234，B：12）</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);    <span class="comment">// 把进位尾接到 C</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);  <span class="comment">//如果循环后仍有进位，则将其作为最后一位添加到 C 中</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>这里 <strong>t</strong> 存储进位 1</li><li>模板假设 <strong>A</strong> 和 <strong>B</strong> 都是非负大整数，即 <strong>A ≥ 0，B ≥ 0</strong></li><li>假设大整数的位数 <strong>A ≥ B</strong>，不满足要交换参数次序</li><li>注意处理最高位进位（循环中，循环结束之后）</li><li>读取数组时反向 <strong>(n - 1 → 0)</strong> 遍历，运算时正向 <strong>(0 → n - 1)</strong> 遍历</li><li>高精度加法不会出现前导 0，而减法、乘法和除法会出现前导 0</li></ul><h2 id="四、高精度减法"><a href="#四、高精度减法" class="headerlink" title="四、高精度减法"></a>四、高精度减法</h2><p>这里用大数减小数，若 <strong>A &lt; B</strong>，则计算 **-(B-A)**。因为 A 和 B 存在数组里，不能直接比大小，所以需要写一个 <code>cmp()</code> 函数进行比较，判断用谁减谁。</p><p>比如：1234 - 567 模拟一下：<br><img src="https://telegraph-image-box.pages.dev/file/fdc47a41be5fdcb0da009.png" alt="2"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A &gt;= B返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A - B, 满足 A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span>     <span class="comment">// 默认 A &gt;= B</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;      <span class="comment">// t 存储借位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];    <span class="comment">// 如果 B 还有剩余（A：1234，B：12）</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);     <span class="comment">// 涵盖 t 为正数负数两种情况</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;               <span class="comment">// 更新借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();   <span class="comment">// 去掉前导0，但不能把结果 0 去掉</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>这里 <strong>t</strong> 存储借位 1</li><li>模板假设 A和B 都是非负大整数，且 <strong>A ≥ B</strong>，可用 <code>cmp()</code> 模板判断是否满足 <strong>A ≥ B</strong>，不满足交换参数次序即可</li><li><code>(t + 10) % 10</code> 涵盖了 t 正负两种情况<ul><li><strong>t &gt;&#x3D; 0</strong>，说明不需要借位，(t + 10) % 10 得到 t 本身</li><li><strong>t &lt; 0</strong>，说明需要借位，(t + 10) % 10 得到 t + 10</li></ul></li><li>减法会产生多个前导 0 （123 - 120 &#x3D; 003）<ul><li>将 C 中的高位 0 给 <code>pop_back()</code> 掉。即：<code>while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();</code></li><li>去掉前导 0 时，注意不能把结果 0 也去掉，即需要判断 <code>C.size() &gt; 1</code></li></ul></li></ul><h2 id="五、高精度乘法"><a href="#五、高精度乘法" class="headerlink" title="五、高精度乘法"></a>五、高精度乘法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、高精度除法"><a href="#六、高精度除法" class="headerlink" title="六、高精度除法"></a>六、高精度除法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 790. 数的三次方根</title>
      <link href="/posts/9978/"/>
      <url>/posts/9978/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.cnblogs.com/littlehb/p/15234625.html">AcWing 790. 数的三次方根 - 糖豆爸爸 - 博客园</a><br><a href="https://akari2333.github.io/posts/38284/">第一讲 基础算法 - 03二分 | Akari的小站</a></p></blockquote><h1 id="AcWing-790-数的三次方根【简单】"><a href="#AcWing-790-数的三次方根【简单】" class="headerlink" title="AcWing 790. 数的三次方根【简单】"></a><a href="https://www.acwing.com/problem/content/792/">AcWing 790. 数的三次方根【简单】</a></h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个浮点数 n，求它的三次方根。</p><p><strong>输入格式</strong><br>共一行，包含一个浮点数 n。</p><p><strong>输出格式</strong><br>共一行，包含一个浮点数，表示问题的解。</p><p>注意，结果保留 6 位小数。</p><p><strong>数据范围</strong><br>−10000 ≤ n ≤ 10000</p><p><strong>输入样例：</strong></p><blockquote><p>1000.00</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>10.000000</p></blockquote><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>浮点数二分还是很简单的，最开始使劲设置最大和最小，精度一般设为 <code>1e-8</code>，然后根据条件写 <code>check()</code>，发现符合就向左或向右逼近，直到结果的差，精度在可以接受的范围内。<br>以本题来说，给出的数据相当于 <code>y</code>，而我们输出的相当于 <code>x</code>，即：<code>y = x*x*x</code>。<br>因为 −10000 ≤ n ≤ 10000，开三次方根不会超过 100，所以 l、r 设置为 <code>-100, 100</code>即可。<br>保留 6 位小数，所以 <code>eps = 1e-8</code>。</p><p>实际上，<code>21*21*21 &lt; 10000 &lt; 22*22*22</code>，最小开到 22 即可。</p><h2 id="三、AC代码"><a href="#三、AC代码" class="headerlink" title="三、AC代码"></a>三、AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @version:</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-26 22:35:11</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r, <span class="type">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, <span class="built_in">bsearch</span>(<span class="number">-100</span>, <span class="number">100</span>, x));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r, <span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)&#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid*mid*mid &lt;= x) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、牛顿迭代法"><a href="#四、牛顿迭代法" class="headerlink" title="四、牛顿迭代法"></a>四、牛顿迭代法</h2><p>hhh，大佬太强了······</p><p>大佬题解：<a href="https://www.cnblogs.com/littlehb/p/15234625.html">https://www.cnblogs.com/littlehb/p/15234625.html</a></p>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一讲 基础算法 - 03二分</title>
      <link href="/posts/38284/"/>
      <url>/posts/38284/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li><a href="https://akari2333.github.io/posts/55426/">二分查找（折半查找） 之二 | Akari的小站</a></li><li><a href="https://akari2333.github.io/posts/42877/">二分查找 | Akari的小站</a></li><li><a href="https://www.cnblogs.com/littlehb/p/15232810.html">AcWing 789. 数的范围 - 糖豆爸爸 - 博客园</a></li><li><a href="https://www.acwing.com/activity/content/code/content/39787/">AcWing 789. 数的范围 - AcWing - yxc</a></li><li><a href="https://www.acwing.com/solution/content/123954/">AcWing 789. 数的范围(二分终极分析！) - AcWing - crayongrq</a></li><li><a href="https://b23.tv/EZEJCeV">【A05 二分查找算法 最好的板子 - 董晓算法 - 哔哩哔哩】</a></li></ul></blockquote><hr><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><em><strong>二分搜索是一种在有序数组中查找某一特定元素的搜索算法。</strong></em></p><p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><p>二分查找算法在<strong>最坏情况</strong>下是对数时间复杂度的，需要进行 <strong>O(log n)</strong> 次比较操作。二分查找算法使用常数空间，对于任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。尽管一些特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分查找算法应用面更广。</p><p>二分查找算法有许多种变种。比如分散层叠可以提升在多个数组中对同一个数值的搜索的速度。分散层叠有效的解决了计算几何学和其他领域的许多搜索问题。指数搜索将二分查找算法拓宽到无边界的列表。二叉搜索树和B树数据结构就是基于二分查找算法的。</p><h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2><h3 id="1、完全匹配（简单）"><a href="#1、完全匹配（简单）" class="headerlink" title="1、完全匹配（简单）"></a>1、完全匹配（简单）</h3><blockquote><p>形如：-1 0 3 5 9 12</p></blockquote><p><strong>使用条件：</strong></p><ul><li>线性表中的记录必须按关键码有序</li><li>必须采用顺序存储</li><li>数组中不能有重复元素，必须保证返回值唯一</li></ul><p>这种就是最简单的二分，单调无重复数组中找目标值。<br>完全匹配的二分搜索只对<strong>有序数组</strong>有效。二分搜索先比较数组中位元素和目标值。如果目标值与中位元素相等，则返回其在数组中的位置；如果目标值小于中位元素，则搜索继续在前半部分的数组中进行。如果目标值大于中位元素，则搜索继续在数组后半部分进行。由此，算法每次排除掉至少一半的待查数组。</p><h3 id="2、大致匹配（难）"><a href="#2、大致匹配（难）" class="headerlink" title="2、大致匹配（难）"></a>2、大致匹配（难）</h3><blockquote><p>比如：1 2 2 3 3 4 12</p></blockquote><p><strong>使用条件：</strong></p><ul><li>线性表中的记录必须按关键码有序</li><li>可以有重复元素</li></ul><p>以上程序只适用于完全匹配，也就是查找一个目标值的位置。<br>而大致匹配的二分更适用于需要找到大致匹配（即接近目标值）的情况，例如查找范围内的上限和下限，但是实际使用中还会有其它情况。</p><h2 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h2><p>平均时间复杂度 <strong>O(log n)</strong><br>最坏时间复杂度 <strong>O(log n)</strong><br>最优时间复杂度 <strong>O(1)</strong></p><h2 id="四、整数二分"><a href="#四、整数二分" class="headerlink" title="四、整数二分"></a>四、整数二分</h2><blockquote><p><strong>完全匹配的二分已经详细写过 blog，不再叙述，本篇重点叙述大致匹配的二分。</strong></p></blockquote><h3 id="1、yxc"><a href="#1、yxc" class="headerlink" title="1、yxc"></a>1、yxc</h3><h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>有单调性一定可以二分，但是可以二分的题目不一定非要有单调性。找到一个边界将区间划分为两部分，使得一部分满足，另一部分不满足。<br><img src="https://telegraph-image-box.pages.dev/file/c84cf4afaba5690ac84da.png" alt="1"><br>这里的两个边界点就对应两个模板写法。</p><p><strong>第一种情况：红色边界点</strong><br>check (mid) 判断 mid 是否满足红颜色的性质。注意 mid &#x3D; ( l + r + 1) &#x2F; 2 以及更新区间时的 mid 和 mid-1。<br><strong>第二种情况：绿色边界点</strong><br>check (mid) 判断 mid 是否满足绿颜色的性质。注意更新区间时的 mid 和 mid+1。</p><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/1163c0a51f25e4befb334.png" alt="$fileName" width="65%"/></div><h4 id="2、注意点"><a href="#2、注意点" class="headerlink" title="2、注意点"></a>2、注意点</h4><p>如果是 l &#x3D; mid ，就要在 mid 中补上 +1。<br>如果是 r &#x3D; mid ，就不用补 +1。</p><p><strong>补上 + 1 的原因在于：</strong><br>如果不补上的话，当 l &#x3D; r - 1，由于C++是下取整的，所以 mid &#x3D; l，更新后区间没变，会导致死循环。<br>也就是说：当 l 和 r 只相差 1，即 <code>l == r - 1</code> 时。<code>mid = (l + r) / 2 = l</code>。若此时 <code>a[mid]</code> 满足左边边性质，则有 <code>(l, r)</code> → <code>(mid, r)</code> &#x3D; <code>(l, r)</code>，搜索区间不变，则陷入死循环。若 + 1，则下取整变成上取整，此时 <code>mid = (l + r + 1) / 2 = r</code>。若此时 a[mid] 满足左半边性质，则有 <code>(l, r)</code> → <code>(mid, r)</code> &#x3D; <code>(r, r)</code>，则结果为 r，不会陷入死循环。</p><h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/e72eb663d4a90608f1be8.png" alt="$fileName" width="55%"/></div><p>二分的本质是寻找边界：如果一组数能根据某个性质一分为二，则可快速通过二分找到边界。它有两种模板：寻找左半边的边界和右半边的边界。<br>实际运用时，先不考虑用哪个模板，而是先写 <code>check()</code> 函数，然后写模板（不考虑 <code>mid</code> 是否 <code>+ 1</code>），写到 <code>if(check(mid))</code> 时，再考虑满足 <code>check(mid)</code> 的段是在哪一边：如果在左边，则填 <code>l = mid</code>；如果在右边，则填 <code>r = mid</code>。然后填出 <code>else</code> 的部分，如果存在 <code>l = mid</code>，则要在 <code>mid</code> 声明处 <code>+ 1</code>；反之不补。</p><h4 id="4、代码模板"><a href="#4、代码模板" class="headerlink" title="4、代码模板"></a>4、代码模板</h4><p> <strong>这两个函数的 <code>check()</code> 函数不一定相同，根据题目设计。</strong></p><blockquote><ol><li><strong>左闭右闭</strong> <code>[0, n - 1]</code></li><li>默认升序排列<br> 如果是降序，把符号<strong>对称</strong>改过来即可。比如 <code>&gt;=</code> 改为 <code>&lt;=</code>，<code>&lt;=</code> 改为 <code>&gt;=</code></li><li><code>bsearch_upper</code> 中，<code>mid = l + (r - l) / 2 + 1</code>：<br> 一个mid &#x3D; (l + r) &gt;&gt; 1<br>一个mid &#x3D; (l + r + 1) &gt;&gt; 1<br>加不加 1，完全取决于 l &#x3D; mid 还是 r &#x3D; mid<br>l 等于 mid 时必须 +1 <strong>向上取整</strong>，不然会陷入 l &#x3D; l 的死循环<br>r &#x3D; mid 时候不用加 1，因为下一步 l &#x3D; r 直接会退出循环</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid, <span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125;   <span class="comment">// 检查 x 是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找右半边边界（下限），区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_lower</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid, x)) r = mid;    <span class="comment">// a[mid]满足右半边性质，应在[l, mid]继续寻找</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;   <span class="comment">// a[mid]不满足右半边性质，应在[mid + 1, r]继续寻找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;   <span class="comment">// 二分结束后，l == r。如果一定存在右半边的边界，l和r都是结果。如果不一定存在右半边的边界，需要做if判断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找左半边边界（上限），区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_upper</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 让下取整变成上取整，避免 l = mid 出现死循环</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid, x)) l = mid;     <span class="comment">// a[mid]满足左半边性质，应在[mid, r]继续寻找</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;   <span class="comment">// a[mid]不满足左半边性质，应在[l, mid - 1]继续寻找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;   <span class="comment">// 二分结束后，l == r。如果一定存在左半边的边界，l和r都是结果。如果不一定存在左半边的边界，需要做if判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、董晓算法"><a href="#2、董晓算法" class="headerlink" title="2、董晓算法"></a>2、董晓算法</h3><p><strong>图中下标是从 1 开始的！而我们都是从 0 开始的！重要的事情说三遍！</strong><br><strong>图中下标是从 1 开始的！而我们都是从 0 开始的！重要的事情说三遍！</strong><br><strong>图中下标是从 1 开始的！而我们都是从 0 开始的！重要的事情说三遍！</strong></p><p>老实说，我喜欢这种，很容易理解。<br><strong>如图所示，以查询上限和下限为例</strong>：（别的情况类似，只是判断条件变了而已）：</p><h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>本质上，这种二分查找的思想是基于有序数组的特性，通过每一步将搜索范围缩小一半的方式，快速定位目标值或满足某个条件的元素。<br>基本思想的关键在于通过比较目标值与中间元素的大小关系，不断调整搜索范围。在每一步，通过 <code>check()</code> 函数来判断中间值是否满足条件，根据判断结果，动态地调整搜索范围的左右边界。<br>总体而言，本质上这种二分查找是一种分治策略，通过将搜索范围一分为二，然后根据目标值与中间值的关系，决定舍弃一半的数据，从而在较短的时间内快速找到目标值或满足条件的元素。</p><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/4ee7d0c66ec0cd210a08a.jpg" alt="$fileName" width="75%"/></div><h4 id="2、注意点-1"><a href="#2、注意点-1" class="headerlink" title="2、注意点"></a>2、注意点</h4><p><strong>Q：</strong> 为什么必须是开区间？<br><strong>A：</strong> 反证法：<br>如图，如果要查找最后一个 &lt;&#x3D; 8 的数的下标，让 l 和 r 初值指向闭区间，为 1 和 8，在模拟过程中，我们会发现最后条件结束时，<strong>l &#x3D; 7</strong>，退出循环，但是此时还没有找完。</p><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/c58107e99604ce4822f08.jpg" alt="$fileName" width="75%"/></div><h4 id="3、总结-1"><a href="#3、总结-1" class="headerlink" title="3、总结"></a>3、总结</h4><p>很容易发现，这两种写法是对称的，而且从图中也能很好的看出来：</p><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/292b66b8fdf3666f422ee.jpg" alt="$fileName" width="75%"/></div><h4 id="4、代码模板-1"><a href="#4、代码模板-1" class="headerlink" title="4、代码模板"></a>4、代码模板</h4><p><strong>注意：以查询上限和下限为例。</strong><br><strong>这两个函数的 <code>check()</code> 函数不一定相同，根据题目设计。</strong></p><blockquote><ol><li><strong>左开右开</strong> <code>(-1, n)</code></li><li>数组下标从 -1 开始，到 n 结束</li><li>默认升序排列<br> 如果是降序，把 <code>&gt;=</code> 改为 <code>&lt;=</code>，把 <code>&lt;=</code> 改为 <code>&gt;=</code></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid, <span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125;   <span class="comment">// 检查 x 是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小化查找（可行区在右侧）：查找第一个 满足check(mid, x) 的数的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_lower</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)&#123;  <span class="comment">// l + 1 = r时结束</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid, x)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大化查找（可行区在左侧）：查找最后一个 满足check(mid, x) 的数的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_upper</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)&#123;  <span class="comment">// l + 1 = r 时结束</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid, x)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、浮点数二分"><a href="#五、浮点数二分" class="headerlink" title="五、浮点数二分"></a>五、浮点数二分</h2><blockquote><ol><li>double 可以直接除而不会取整，所以不用在意边界问题，较为简单。<strong>即不需要考虑 mid 是否 +1 ，else 后是否 +1。</strong></li><li>判断条件一般为 <code>r - l &gt;= 1e-6</code>.<br>没有固定的浮点数序列，因此要考虑精度 <code>eps</code>，一般比题目要求多 <code>2</code> 位小数就行</li><li>需要自己确定l和r的值，即查找范围</li><li>或者不使用函数，改为 for 循环，相当于除了 2^100 次方，效果跟 <code>r - l &gt; eps</code> 是一样的。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid, <span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)&#123;</span><br><span class="line">        <span class="type">double</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid, x)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 789. 数的范围 *</title>
      <link href="/posts/50156/"/>
      <url>/posts/50156/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><blockquote><ul><li><a href="https://akari2333.github.io/posts/55426/">二分查找（折半查找） 之二 | Akari的小站</a></li><li><a href="https://akari2333.github.io/posts/42877/">二分查找 | Akari的小站</a></li><li><a href="https://www.cnblogs.com/littlehb/p/15232810.html">AcWing 789. 数的范围 - 糖豆爸爸 - 博客园</a></li><li><a href="https://www.acwing.com/activity/content/code/content/39787/">AcWing 789. 数的范围 - AcWing - yxc</a></li><li><a href="https://www.acwing.com/solution/content/123954/">AcWing 789. 数的范围(二分终极分析！) - AcWing - crayongrq</a></li><li><a href="https://b23.tv/EZEJCeV">【A05 二分查找算法 最好的板子 - 董晓算法 - 哔哩哔哩】</a></li></ul></blockquote><p class='p red center logo large'>一杯茶，一包烟，一道算法看一天。</p><hr><h1 id="AcWing-789-数的范围【简单】"><a href="#AcWing-789-数的范围【简单】" class="headerlink" title="AcWing 789. 数的范围【简单】*"></a><a href="https://www.acwing.com/problem/content/791/">AcWing 789. 数的范围【简单】*</a></h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。<br>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。<br>如果数组中不存在该元素，则返回 -1 -1。</p><p><strong>输入格式</strong><br>第一行包含整数 n 和 q，表示数组长度和询问个数。<br>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。<br>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p><p><strong>输出格式</strong><br>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回 -1 -1。</p><p><strong>数据范围</strong><br>1 ≤ n ≤ 100000<br>1 ≤ q ≤ 10000<br>1 ≤ k ≤ 10000</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><h2 id="二、函数定义与用途"><a href="#二、函数定义与用途" class="headerlink" title="二、函数定义与用途"></a>二、函数定义与用途</h2><p>将默认采用<strong>升序</strong>描述。</p><h3 id="1、bsearch-lower"><a href="#1、bsearch-lower" class="headerlink" title="1、bsearch_lower"></a>1、bsearch_lower</h3><p><strong>用途：</strong><br>在 <strong>升序</strong> 情况下，返回的是第一个 <strong>大于等于 x</strong> 的数的位置（下标）<br>在 <strong>降序</strong> 情况下，返回的是第一个 <strong>小于等于 x</strong> 的数的位置（下标）</p><h3 id="2、bsearch-upper"><a href="#2、bsearch-upper" class="headerlink" title="2、bsearch_upper"></a>2、bsearch_upper</h3><p><strong>用途：</strong><br>在 <strong>升序</strong> 情况下，返回的是最后一个 <strong>大于等于 x</strong> 的数的位置（下标）<br>在 <strong>降序</strong> 情况下，返回的是最后一个 <strong>小于等于 x</strong> 的数的位置（下标）</p><h2 id="三、解题方法"><a href="#三、解题方法" class="headerlink" title="三、解题方法"></a>三、解题方法</h2><p>这是整数二分的模板题，仔细体会一下模板中的 <code>check()</code> 函数在这里是怎么运用的，以及如果要找的不是上限和下限换成别的情况该如何改动。</p><h3 id="1、yxc"><a href="#1、yxc" class="headerlink" title="1、yxc"></a>1、yxc</h3><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/e72eb663d4a90608f1be8.png" alt="$fileName" width="65%"/></div><p>或者：</p><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/2d81eb3b6b0bae86f24e5.png" alt="$fileName" width="60%"/></div><p><strong>注意：</strong></p><blockquote><ol><li><strong>左闭右闭</strong> <code>[0, n - 1]</code></li><li>数组下标从 0 开始，到 n - 1 结束</li><li>默认升序排列<br> 如果是降序，把 <code>bsearch_lower</code> 中的 <code>&gt;=</code> 改为 <code>&lt;=</code>，把 <code>bsearch_upper</code> 中的 <code>&lt;=</code> 改为 <code>&gt;=</code></li><li><code>bsearch_upper</code> 中，<code>mid = l + (r - l) / 2 + 1</code>：<br> 一个mid &#x3D; (l + r) &gt;&gt; 1<br>一个mid &#x3D; (l + r + 1) &gt;&gt; 1<br>加不加 1，完全取决于 l &#x3D; mid 还是 r &#x3D; mid<br>l 等于 mid 时必须 +1 <strong>向上取整</strong>，不然会陷入 l &#x3D; l 的死循环<br>r &#x3D; mid 时候不用加 1，因为下一步 l &#x3D; r 直接会退出循环</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找大于等于 x 的下限</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_lower</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[mid] &gt;= x) r = mid;   <span class="comment">// 降序改为 &lt;=</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找小于等于 x 的上限</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_upper</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 需要 + 1，防止死循环</span></span><br><span class="line">        <span class="keyword">if</span> (q[mid] &lt;= x) l = mid;   <span class="comment">// 降序改为 &gt;=</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、糖豆爸爸"><a href="#2、糖豆爸爸" class="headerlink" title="2、糖豆爸爸"></a>2、糖豆爸爸</h3><p>跟y总的差不多，只是区间变成了左闭右开。</p><p><strong>注意：</strong></p><blockquote><ol><li><strong>左闭右开</strong> <code>[0, n)</code></li><li>数组下标从 0 开始，到 n 结束</li><li>默认升序排列<br> 如果是降序，把 <code>bsearch_lower</code> 中的 <code>&gt;=</code> 改为 <code>&lt;=</code>，把 <code>bsearch_upper</code> 中的 <code>&lt;=</code> 改为 <code>&gt;=</code></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[mid] &lt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[mid] &lt; x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、董晓算法"><a href="#3、董晓算法" class="headerlink" title="3、董晓算法"></a>3、董晓算法</h3><p><strong>图中下标是从 1 开始的！而一般都是从 0 开始的！</strong></p><p>老实说，我喜欢这种，很容易理解。如图所示：</p><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/4ee7d0c66ec0cd210a08a.jpg" alt="$fileName" width="75%"/></div><p><strong>注意：</strong></p><blockquote><ol><li><strong>左开右开</strong> <code>(-1, n)</code></li><li>数组下标从 -1 开始，到 n 结束</li><li>默认升序排列<br> 如果是降序，把 <code>bsearch_lower</code> 中的 <code>&gt;=</code> 改为 <code>&lt;=</code>，把 <code>bsearch_upper</code> 中的 <code>&lt;=</code> 改为 <code>&gt;=</code></li><li>为了方便记忆，可以理解为：<br>找第一个 <strong>&gt;&#x3D; x</strong> 的数，if 中就用 <strong>&gt;&#x3D;</strong><br>找最后一个 <strong>&lt;&#x3D; x</strong> 的数，if 中就用 <strong>&lt;&#x3D;</strong></li></ol></blockquote><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/292b66b8fdf3666f422ee.jpg" alt="$fileName" width="75%"/></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小化查找（可行区在右侧）：查找第一个 &gt;= x的数的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_lower</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)&#123;  <span class="comment">// l + 1 = r时结束</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大化查找（可行区在左侧）：查找最后一个 &lt;= x的数的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_upper</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)&#123;  <span class="comment">// l + 1 = r 时结束</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[mid] &lt;= x) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、STL-内置方法"><a href="#4、STL-内置方法" class="headerlink" title="4、STL 内置方法"></a>4、STL 内置方法</h3><p><strong>lower_bound：</strong></p><p>升序：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p = <span class="built_in">lower_bound</span>(q, q + n, x) - q;</span><br></pre></td></tr></table></figure><p>降序：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p = <span class="built_in">lower_bound</span>(q, q + n, x, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) - q;</span><br></pre></td></tr></table></figure><p><strong>upper_bound：</strong></p><p>升序：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p = <span class="built_in">upper_bound</span>(q, q + n, x) - q;</span><br></pre></td></tr></table></figure><p>降序：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p = <span class="built_in">upper_bound</span>(q, q + n, x, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) - q;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><ol><li><strong>左闭右开</strong> <code>[ )</code></li><li>数组下标从 0 开始，到 n 结束</li><li>一般来讲,STL 可以处理大于等于，大于，小于等于，小于，一般的数字二分够用</li><li>查找左边界，可以直接 <code>lower_bound</code>，如果想要查找右边界，可以使用 <code>upper_bound</code> 然后再减 1。<br>但是，由于二分不一定是数字二分，有时需要用 <strong>check</strong> 函数，这里 STL就无法使用 <strong>check</strong> 函数了，所以，终极解法还是手写二分，容易扩展！</li></ol></blockquote><h2 id="四、AC代码"><a href="#四、AC代码" class="headerlink" title="四、AC代码"></a>四、AC代码</h2><p>这两个模板解决的是 找 &gt;&#x3D; || &lt;&#x3D; || &gt; || &lt; 某个数的最左或最右的位置 但这个数不一定在二分的数组中<br>如果在就能准确找到<br>如果不在 找到的就是最接近答案的数（你要找大于等于5的第一个数）但数组中没有 5 那找到的就是 6 的位置(如果有 6 的话)<br>所以二分是一定有答案的<br>我觉得这个二分模板就是解决了我上面说的（&gt;&#x3D; || &lt;&#x3D; || &gt; || &lt;）这四种情况</p><p><strong>这两个模板是一定有答案的，如果没有答案，那就只能是题目数据里没有，所以才会输出 -1 -1，对应就是代码里的 if 不成立的条件。</strong></p><h3 id="1、yxc-1"><a href="#1、yxc-1" class="headerlink" title="1、yxc"></a>1、yxc</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_lower</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_upper</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (x != q[<span class="built_in">bsearch_lower</span>(<span class="number">0</span>, n - <span class="number">1</span>, x)]) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">bsearch_lower</span>(<span class="number">0</span>, n - <span class="number">1</span>, x) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">bsearch_upper</span>(<span class="number">0</span>, n - <span class="number">1</span>, x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_lower</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_upper</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[mid] &lt;= x) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、董晓算法"><a href="#2、董晓算法" class="headerlink" title="2、董晓算法"></a>2、董晓算法</h3><p>我喜欢这个。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_lower</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_upper</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (q[<span class="built_in">bsearch_lower</span>(<span class="number">-1</span>, n, x)] != x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">bsearch_lower</span>(<span class="number">-1</span>, n, x)&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">bsearch_upper</span>(<span class="number">-1</span>, n, x)&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小化查找（可行区在右侧）：查找第一个 &gt;= x的数的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_lower</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)&#123;      <span class="comment">// l + 1 = r时结束</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= q[mid]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大化查找（可行区在左侧）：查找最后一个 &lt;= x的数的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_upper</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)&#123;      <span class="comment">// l + 1 = r 时结束</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= q[mid]) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、糖豆爸爸"><a href="#3、糖豆爸爸" class="headerlink" title="3、糖豆爸爸"></a>3、糖豆爸爸</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, q[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右开 [ )</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[mid] &gt;= x)  r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[mid] &gt; x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lower_bound</span>(<span class="number">0</span>, n, x); <span class="comment">//[0,n)</span></span><br><span class="line">        <span class="keyword">if</span> (q[p] != x) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p);</span><br><span class="line">        p = <span class="built_in">upper_bound</span>(<span class="number">0</span>, n, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h2><p>题目要求是找一个数的上限和下限，也就是 <code>&gt;=</code> 和 <code>&lt;=</code>，那么如果要找 <code>&gt;</code> 或者 <code>&lt;</code> 或者别的情况怎么办呢？<br>比如：将代码中的 <strong>&gt;&#x3D;</strong> 和 <strong>&lt;&#x3D;</strong> 中的 <strong>&#x3D;</strong> 去掉，输出结果的变化意味着什么呢？<br><strong>输入：</strong></p><blockquote><p>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5</p></blockquote><p><strong>输出：</strong></p><blockquote><p>5 2<br>6 4<br>6 5</p></blockquote><p>这个是比较简单的情况，<code>check()</code> 就是 <code>q[mid] &lt;= x</code>，就是排个序找到答案而已。<br>别的题需要自己判断，就是自己二分的答案，左边就是不满足 且比答案小的，右边都是满足条件且比答案大的数。就是说二分具有单调性，<code>check()</code> 函数就是判断否满足这个性质。</p>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 788. 逆序对的数量 *</title>
      <link href="/posts/8193/"/>
      <url>/posts/8193/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><blockquote><ul><li><a href="https://www.cnblogs.com/littlehb/p/15223919.html">AcWing 788. 逆序对的数量 - 糖豆爸爸 - 博客园</a></li><li><a href="https://akari2333.github.io/posts/3605/">第一讲 基础算法 - 02归并排序 | Akari的小站</a></li></ul></blockquote><p>感谢微信群群友的解答：<em>黑桃皇后</em>、<em>五个结晶水</em>、<em>但为君故</em></p><p><strong>现在我也是似懂非懂的，看一天了······太菜了，hhh。</strong></p><hr><h1 id="AcWing-788-逆序对的数量【简单】"><a href="#AcWing-788-逆序对的数量【简单】" class="headerlink" title="AcWing 788. 逆序对的数量【简单】*"></a><a href="https://www.acwing.com/problem/content/790/">AcWing 788. 逆序对的数量【简单】*</a></h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。<br>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。</p><p><strong>输入格式</strong><br>第一行包含整数 n，表示数列的长度。<br>第二行包含 n 个整数，表示整个数列。</p><p><strong>输出格式</strong><br>输出一个整数，表示逆序对的个数。</p><p><strong>数据范围</strong><br>1≤n≤100000，<br>数列中的元素的取值范围 [1,109]。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 3 4 5 6 1</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="二、解题方法"><a href="#二、解题方法" class="headerlink" title="二、解题方法"></a>二、解题方法</h2><p><img src="https://telegraph-image-box.pages.dev/file/9bbed6db3d2dacd080300.png" alt="3"></p><h3 id="1、暴力"><a href="#1、暴力" class="headerlink" title="1、暴力"></a>1、暴力</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @version:</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-24 15:44:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i] &gt; q[j])</span><br><span class="line">                res ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无悬念：<code>Time Limit Exceeded</code>。</p><h3 id="2、归并"><a href="#2、归并" class="headerlink" title="2、归并"></a>2、归并</h3><p>大概理解，主要是理解 res &#x3D; merge_sort(q, l, mid) + merge_sort(q, mid + 1, r)，就是先求出第一次平分左右两边的逆序数，再分别对左右两边进行平分求逆序数，一直递归下去。</p><p>也可以用 <code>void</code> 作为返回类型，全局定义一个 <code>LL res = 0;</code>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @version:</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-24 15:25:09</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;   <span class="comment">// 必须用 long long，防止爆 int</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, q[N], tmp[N];</span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;   <span class="comment">// 也要改为 long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归处理左右两部分</span></span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 递归排序！（将序列一直分，拆封成单个，即为有序）</span></span><br><span class="line">    LL res = <span class="built_in">merge_sort</span>(q, l, mid) + <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 当前层的结果是回溯的上一层两边相加的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并的过程</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k ++ ] = q[j ++ ];</span><br><span class="line">            res += mid - i + <span class="number">1</span>;     <span class="comment">//满足逆序对条件</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 物归原主</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、树状数组解法"><a href="#3、树状数组解法" class="headerlink" title="3、树状数组解法 *"></a>3、树状数组解法 *</h3><blockquote><p><a href="https://www.cnblogs.com/littlehb/p/17143537.html">AcWing 788 逆序对的数量 之 树状数组 解法 - 糖豆爸爸 - 博客园</a></p></blockquote><p>看大佬blog，还可以这样写，不过我还没学到，先开个坑······</p><h3 id="4、线段树-静态数组"><a href="#4、线段树-静态数组" class="headerlink" title="4、线段树+静态数组 *"></a>4、线段树+静态数组 *</h3><blockquote><p><a href="https://www.cnblogs.com/littlehb/p/17143537.html">AcWing 788 逆序对的数量 之 树状数组 解法 - 糖豆爸爸 - 博客园</a></p></blockquote><p>同上。</p><h2 id="三、具体分析"><a href="#三、具体分析" class="headerlink" title="三、具体分析"></a>三、具体分析</h2><h3 id="1、答案的数据类型"><a href="#1、答案的数据类型" class="headerlink" title="1、答案的数据类型"></a>1、答案的数据类型</h3><p><strong>Q：</strong> 逆序对最多有多少？<br><strong>A：</strong> 当数列逆序时，逆序对最多，比如：[5, 4, 3, 2, 1]，所以最多有 <code>res = n-1 + n-2 + ··· + 2 + 1 == (n*(n-1))/2</code><br>本题 <code>1&lt;=n&lt;=10000</code>，所以 res &#x3D; 100000 * (100000 - 1) &#x2F; 2 ≈ 1e10 ÷ 2 &#x3D; 5 * 10^9<br>而 int 极限为 2147483647，约为 2 * 10^9，所以会爆 int，需要用long long</p><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/dd4fec158977f200201a9.png" alt="$fileName" width="75%"/></div><h3 id="2、利用归并求逆序对"><a href="#2、利用归并求逆序对" class="headerlink" title="2、利用归并求逆序对"></a>2、利用归并求逆序对</h3><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/d6a777fef37e31852093f.png" alt="$fileName" width="75%"/></div><p>在归并两个子数组时，有三种情况:</p><blockquote><p><strong>（1）、逆序对在左边（红色）</strong><br>这在调用左侧子数组进行递归时，已经完成了统计，自己不管。（内部问题内部解决）<br><strong>（2）、逆序对在右边（绿色）</strong><br>这在调用右侧子数组进行递归时，已经完成了统计，自己不管。(内部问题内部解决)<br><strong>（3）、逆序对在左侧和右侧（黄色）</strong><br>这个需要自己来处理，对于右侧的黄色圆，那么在左侧的黄色圆及左侧黄色圆后面，一直到中线的所有数，都是比右侧黄色圆大的，就是有 <code>mid - i + 1</code> 个逆序对。</p></blockquote><p>可以结合代码来理解原理，其实就是在归并时，只处理合并数组中大小反着的两个数字，一旦发现前面的数字比后面的数字大，就是发现了一个逆序对。同时，由于归并排序的特点，两个要归并的数组是内部有序的，所以，意味着左侧当前数字及其之后的一直到左侧集合结束的所有数字，都比右侧当前数字大！那么个数就是 <code>mid - i + 1</code> 个，其中 <code>l &lt;= i &lt;= mid</code> 。</p><h3 id="3、内部问题内部解决什么意思？"><a href="#3、内部问题内部解决什么意思？" class="headerlink" title="3、内部问题内部解决什么意思？"></a>3、内部问题内部解决什么意思？</h3><p><em><strong>@Arsene7777：</strong></em></p><blockquote><p>其实本质还是递归跟分治。<br>假设给你两个有序列的数组 A, B，那么显然，A 和 B 的逆序数就都是 0 对不对。所以将 A, B 按照顺序接成一个新的数组的逆序数，是不是就等于求y总视频中所讲的<strong>黄色逆序数</strong>的个数？<br>本质就是 C 由 A, B 构成，那么对 C 求某些特定的性质，可以等价于 对 A 求（<strong>红色</strong>）加上对 B 求（<strong>绿色</strong>），再加上将 A，B 整合之后产生的性质（<strong>黄色</strong>），然后又可以将 A 看作由更小的 E，F。而当数组不可以再划分的时候，即只要一个元素的时候，就是我们递归的尽头了。<br><strong>所以我觉得归并的本质还是求黄色的逆序数，因为 A 红色的逆序数可以等于 A 的红色+黄色+绿色，而最底层的红色和绿色都为 0，所以本质是求黄色。</strong></p></blockquote><p><em><strong>@劲能神佑：</strong></em></p><blockquote><p>在这里要理解逆序数的本质，逆序数是用来描述这个数列相对于排序后的混乱程度的（逆序数就是每次交换一变成排序后数列的次数（和冒泡的次数一致））。那么只要是排序方法，理论上都可以做（比如快排把那个x参照点设为最左端就可以做，复杂度（o^2））</p></blockquote><h3 id="4、用归并排序的原因（难）"><a href="#4、用归并排序的原因（难）" class="headerlink" title="4、用归并排序的原因（难）"></a>4、用归并排序的原因（难）</h3><p>归并排序天然适合解决逆序对的计算问题，因为归并排序的关键步骤是将<strong>两个有序的子数组</strong>合并成一个有序的数组。在这个过程中，<strong>如果左边数组中的某个元素大于右边数组中的某个元素，那么左边数组中该元素后面的所有元素都会与右边数组中的这个元素构成逆序对。</strong><br>通过在归并排序的过程中统计逆序对的数量，可以高效地解决逆序对计算问题。因为归并排序的<strong>分治策略</strong>使得每个子问题都能得到解决，而逆序对的数量可以在合并的过程中被有效地计算出来。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>可以借助这张图理解：</p><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/216ab5659939cc867d4b3.png" alt="$fileName" width="75%"/></div><h3 id="1、第三种情况利用了归并的特性"><a href="#1、第三种情况利用了归并的特性" class="headerlink" title="1、第三种情况利用了归并的特性"></a>1、第三种情况利用了归并的特性</h3><p><strong>Q：</strong> 是不是左半部分和右半部分分别当成一个新的数列进行归并处理，而第三种左右两边都有的情况恰好利用了归并合并的特性？<br><strong>A：</strong> 是的。</p><hr><p>在归并排序中，递归地将原始数组分割成更小的子数组，然后对这些子数组进行排序。在合并的过程中，利用归并的特性确保有序的子数组正确地合并成整体有序的数组。<br>对于逆序对的问题，正是因为归并排序的特性，可以有效地在合并的过程中统计逆序对的数量。具体来说：</p><blockquote><ol><li>当递归处理左侧子数组时，逆序对的统计已经在更深层次的递归中完成了。左侧子数组在当前层次是有序的。</li><li>当递归处理右侧子数组时，逆序对的统计同样在更深层次的递归中完成了。右侧子数组在当前层次是有序的。</li><li>当左右两侧都有序时，合并的过程中，我们可以通过比较左右两侧的元素大小来统计逆序对的数量。这是因为在左侧有序的情况下，右侧的某个元素比左侧当前元素小，就形成了逆序对，数量为左侧剩余元素的个数。</li></ol></blockquote><p>这种分治和归并的结合，确保了逆序对问题可以在归并的过程中高效地解决。左右两侧各自有序的特性为这一算法提供了便利，而第三种情况则充分利用了归并排序的特性来统计逆序对数量。</p><h3 id="2、左右两半进行处理时其实最后也是第三种情况"><a href="#2、左右两半进行处理时其实最后也是第三种情况" class="headerlink" title="2、左右两半进行处理时其实最后也是第三种情况"></a>2、左右两半进行处理时其实最后也是第三种情况</h3><p>换句话说：第三种情况就是处理前面 2 种情况的已经排好序的数组，并在合并的过程中统计逆序对的数量。</p><p>当左侧子数组和右侧子数组都是有序的时候，在合并过程中，可以利用归并排序的特性，比较左右两侧的元素大小，以统计逆序对的数量（<strong>也就是模板里的归并过程</strong>）。此时，左侧子数组和右侧子数组各自都是已经排好序的，因此可以在合并的过程中通过比较元素大小，统计逆序对的数量。<strong>统计在合并的过程中进行，而不是在递归的过程中。</strong></p><h3 id="3、递归函数的作用"><a href="#3、递归函数的作用" class="headerlink" title="3、递归函数的作用"></a>3、递归函数的作用</h3><blockquote><p><em>你可以自己写个例子看一下，就像是<strong>后序遍历</strong>一样。</em></p></blockquote><p>递归函数在归并排序中的作用是对子数组进行排序：</p><blockquote><ol><li><strong>递归地将数组分解为更小的子数组：</strong> 先检查数组的长度，如果长度超过 1，就将数组分成两半。然后，递归地对这两个子数组调用自身，将它们分解为更小的子数组，直到每个子数组的长度都为 1。</li><li><strong>对子数组进行合并排序：</strong> 一旦数组被分解为长度为 1 的子数组，递归函数开始合并这些子数组，同时进行排序。通过调用归并函数来完成，归并函数的任务是将两个有序的子数组合并成一个有序的数组。</li></ol></blockquote><p>在这个过程中，递归函数不仅会进行拆分，还会在合并的时候进行逆序对的统计。通过递归的方式，整个数组最终会被分解为越来越小的子数组，然后逆序对的数量也会被统计和合并，直到最终得到完整有序的数组。<br>因此，递归函数在归并排序中的主要作用是将大问题分解为更小的子问题，并在递归的过程中解决这些子问题。<strong>递归的停止条件是子数组长度为 1，此时递归回溯，对子数组进行合并排序。</strong></p><h3 id="4、本质"><a href="#4、本质" class="headerlink" title="4、本质"></a>4、本质</h3><blockquote><p>从根本上来说只是在归并排序的合并过程中求出两个子数组的逆序对数，而每个子数组也都是左右递归形成的，这样只要通过递归到最深层的时候回溯的过程就可以对合并过程得到的每一个子结果进行累加就是答案了</p></blockquote><p><strong>Q：</strong> 是不是左半部分和右半部分分别当成一个新的数列进行归并处理，而第三种左右两边都有的情况恰好利用了归并合并的特性<br>因为合并的时候就是左右两半进行比较嘛，而左右两半进行处理时其实最后也是第三种情况<br><strong>A：</strong> 是的。<br>当前层的结果是回溯的上一层两边相加的结果</p><hr><blockquote><p>通过分治和递归，最深层的单个元素 return 往回，就是两个元素，这两个元素是来自两个数列的，也就是黄色圈的情况。本质上，红色圈和蓝色圈，各自的情况是不存在的，这是借助计算机代码的特性所造成的</p></blockquote><p><strong>Q：</strong> 既然本质是黄色圈之间比较，为什么还要有红色圈和蓝色圈呢？或者说，我不明白为什么是res是两种情况相加。<br><strong>A：</strong> 这里是后序遍历，所以递归到最后一层（也就是一个数的时候）才开始merge，红色圈和蓝色圈就是依靠黄色情况下算出来的，所以最终结果就是res +&#x3D; 左半边 + 右半边。<br><strong>Q：</strong> 我觉得是不是：递归到最深处，只有第三种情况，前两个就是描述这个递归的过程，只是用来帮助理解，事实上不存在。归并排序的递归过程的边界就是区间只有1个数，所以就是第三种 两边相加的情况。<br><strong>A：</strong> 以左边的举例，左边的递归到最深处只有黄色的情况 ，这个结果返回到上一层之后，它的值就是红色。<br><strong>A：</strong> 说的是没问题的，其实意思就是不断递归找黄色部分进行加和的，红色和蓝色部分只是大体上的概念。<br><strong>A：</strong> 这样理解 那些红色和蓝色的情况在最后递归之后 还是会变成 后面那些 较小的数组的黄色情况</p>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】算竞常用 C++ STL 用法</title>
      <link href="/posts/40362/"/>
      <url>/posts/40362/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>转载自：<a href="https://io.zouht.com/154.html">杂项 | 算竞常用 C++ STL 用法 - 颢天笔记</a></li><li>部分显示会有问题，一部分 markdown 语法和主题的样式会有冲突······</li></ul></blockquote><hr><p><strong>C++ 标准模板库 (STL, Standard Template Library)</strong> ：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).</p><span id="more"></span><p>示例：</p><ul><li>算法：<code>sort(a.begin(), a.end())</code></li><li>容器：<code>priority_queue&lt;int&gt; pque</code></li><li>仿函数：<code>greater&lt;int&gt;()</code></li><li>迭代器：<code>vector&lt;int&gt;::iterator it = a.begin()</code></li></ul><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>STL 作为一个封装良好，性能合格的 C++ 标准库，在算法竞赛中运用极其常见。灵活且正确使用 STL 可以节省非常多解题时间，这一点不仅是由于可以直接调用，还是因为它封装良好，可以让代码的可读性变高，解题思路更清晰，调试过程 <del>往往</del> 更顺利。</p><p>不过 STL 毕竟使用了很多复杂的结构来实现丰富的功能，它的效率往往是比不上自己手搓针对特定题目的数据结构与算法的。因此，STL 的使用相当于使用更长的运行时间换取更高的编程效率。因此，在实际比赛中要权衡 STL 的利弊，不过这一点就得靠经验了。</p><p>接下来，我会分享在算法竞赛中常用的 STL 容器和算法，对于函数和迭代器，就不着重展开讲了。</p><h1 id="2-常用容器"><a href="#2-常用容器" class="headerlink" title="2 常用容器"></a>2 常用容器</h1><h2 id="2-1-内容总览"><a href="#2-1-内容总览" class="headerlink" title="2.1 内容总览"></a>2.1 内容总览</h2><p>打勾的是本次将会详细讲解的，加粗的是算法竞赛中有必要学习的。</p><ul><li><p>顺序容器</p><ul><li><p><input disabled="" type="checkbox"> <strong>array</strong></p></li><li><p><input checked="" disabled="" type="checkbox"> <strong>vector</strong></p></li><li><p><input disabled="" type="checkbox"> <strong>deque</strong></p></li><li><p><input disabled="" type="checkbox"> forward_list</p></li><li><p><input disabled="" type="checkbox"> <strong>list</strong></p></li></ul></li><li><p>关联容器</p><ul><li><input checked="" disabled="" type="checkbox"> <strong>set</strong></li><li><input checked="" disabled="" type="checkbox"> <strong>map</strong></li><li><input disabled="" type="checkbox"> <strong>multiset</strong></li><li><input disabled="" type="checkbox"> <strong>multimap</strong></li></ul></li><li><p>无序关联容器</p><ul><li><input disabled="" type="checkbox"> <strong>unordered_set</strong></li><li><input disabled="" type="checkbox"> <strong>unordered_map</strong></li><li><input disabled="" type="checkbox"> <strong>unordered_multiset</strong></li><li><input disabled="" type="checkbox"> <strong>unordered_multimap</strong></li></ul></li><li><p>容器适配器</p><ul><li><input checked="" disabled="" type="checkbox"> <strong>stack</strong></li><li><input checked="" disabled="" type="checkbox"> <strong>queue</strong></li><li><input checked="" disabled="" type="checkbox"> <strong>priority_queue</strong></li><li><input disabled="" type="checkbox"> flat_set</li><li><input disabled="" type="checkbox"> flat_map</li><li><input disabled="" type="checkbox"> flat_multiset</li><li><input disabled="" type="checkbox"> flat_multimap</li></ul></li><li><p>字符串</p><ul><li><input checked="" disabled="" type="checkbox"> <strong>string</strong> (basic_string&lt;char&gt;)</li></ul></li><li><p>对与元组</p><ul><li><input checked="" disabled="" type="checkbox"> <strong>pair</strong></li><li><input disabled="" type="checkbox"> <strong>tuple</strong></li></ul></li></ul><h2 id="2-2-向量-vector"><a href="#2-2-向量-vector" class="headerlink" title="2.2 向量 vector"></a>2.2 向量 <a href="https://zh.cppreference.com/w/cpp/container/vector">vector</a></h2><p><strong><code>#include &lt;vector&gt;</code></strong></p><p>连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。</p><h3 id="2-2-1-常用方法"><a href="#2-2-1-常用方法" class="headerlink" title="2.2.1 常用方法"></a>2.2.1 常用方法</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p><strong><code>vector&lt;类型&gt; arr(长度, [初值])</code></strong></p><p>时间复杂度：$O(n)$</p><p>常用的一维和二维数组构造示例，高维也是一样的（就是会有点长）.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr;         <span class="comment">// 构造int数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>;    <span class="comment">// 构造初始长100的int数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 构造初始长100的int数组，初值为1</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ());       <span class="comment">// 构造初始100行，不指定列数的二维数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">666</span>, <span class="number">-1</span>)) <span class="comment">// 构造初始100行，初始666列的二维数组，初值为-1</span></span><br></pre></td></tr></table></figure><p>构造二维数组的奇葩写法，千万别用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>];         <span class="comment">// 正确，构造初始100行，不指定列数的二维数组，可用于链式前向星存图</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>](<span class="number">100</span>, <span class="number">1</span>); <span class="comment">// 语法错误！</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span>[100]</span>; <span class="comment">// 语法错误！</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>] &#123;&#123;<span class="number">100</span>, <span class="number">1</span>&#125;, 这里省略<span class="number">98</span>个 ,&#123;<span class="number">100</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 正确但奇葩，使用列表初始化</span></span><br></pre></td></tr></table></figure><h4 id="尾接-尾删"><a href="#尾接-尾删" class="headerlink" title="尾接 &amp; 尾删"></a>尾接 &amp; 尾删</h4><ul><li><strong><code>.push_back(元素)</code></strong> ：在 vector 尾接一个元素，数组长度 $+1$.</li><li><strong><code>.pop_back()</code></strong> ：删除 vector 尾部的一个元素，数组长度 $-1$</li></ul><p>时间复杂度：均摊 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init: arr = []</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// after: arr = [1]</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// after: arr = [1, 2]</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// after: arr = [1]</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// after: arr = []</span></span><br></pre></td></tr></table></figure><h4 id="中括号运算符"><a href="#中括号运算符" class="headerlink" title="中括号运算符"></a>中括号运算符</h4><p>和一般数组一样的作用</p><p>时间复杂度：$O(1)$</p><h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><p><strong><code>.size()</code></strong></p><p>获取当前 vector 的长度</p><p>时间复杂度：$O(1)$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><p><strong><code>.clear()</code></strong></p><p>清空 vector</p><p>时间复杂度：$O(n)$</p><h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><p><strong><code>.empty()</code></strong></p><p>如果是空返回 <code>true</code> 反之返回 <code>false</code>.</p><p>时间复杂度：$O(1)$</p><h4 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h4><p><strong><code>.resize(新长度, [默认值])</code></strong></p><p>修改 vector 的长度</p><ul><li>如果是缩短，则删除多余的值</li><li>如果是扩大，且指定了默认值，则新元素均为默认值<strong>（旧元素不变）</strong></li></ul><p>时间复杂度：$O(n)$</p><h3 id="2-2-2-适用情形"><a href="#2-2-2-适用情形" class="headerlink" title="2.2.2 适用情形"></a>2.2.2 适用情形</h3><p>一般情况 <code>vector</code> 可以替换掉普通数组，除非该题卡常。</p><p>有些情况普通数组没法解决：$n\times m$ 的矩阵，$1\leq n,m\leq 10^6$ 且 $n\times m \leq 10^6$</p><ul><li>如果用普通数组 <code>int mat[1000010][1000010]</code>，浪费内存，会导致 MLE。</li><li>如果使用 <code>vector&lt;vector&lt;int&gt;&gt; mat(n + 10, vector&lt;int&gt; (m + 10))</code>，完美解决该问题。</li></ul><p>另外，<code>vector</code> 的数据储存在堆空间中，不会爆栈。</p><h3 id="2-2-3-注意事项"><a href="#2-2-3-注意事项" class="headerlink" title="2.2.3 注意事项"></a>2.2.3 注意事项</h3><h4 id="提前指定长度"><a href="#提前指定长度" class="headerlink" title="提前指定长度"></a>提前指定长度</h4><p>如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 <code>.push_back()</code>. 因为 <code>vector</code> 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化前: 522ms</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="comment">// 优化后: 259ms</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1e8</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    a[i] = i;</span><br></pre></td></tr></table></figure><h4 id="当心-size-t-溢出"><a href="#当心-size-t-溢出" class="headerlink" title="当心 size_t 溢出"></a>当心 size_t 溢出</h4><p>vector 获取长度的方法 <code>.size()</code> 返回值类型为 <code>size_t</code>，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 $[0,2^{32})$.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">65536</span>)</span></span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a = a.<span class="built_in">size</span>() * a.<span class="built_in">size</span>(); <span class="comment">// 直接溢出变成0了</span></span><br></pre></td></tr></table></figure><h2 id="2-3-栈-stack"><a href="#2-3-栈-stack" class="headerlink" title="2.3 栈 stack"></a>2.3 栈 <a href="https://zh.cppreference.com/w/cpp/container/stack">stack</a></h2><p><strong><code>#include &lt;stack&gt;</code></strong></p><p>通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。</p><h3 id="2-3-1-常用方法"><a href="#2-3-1-常用方法" class="headerlink" title="2.3.1 常用方法"></a>2.3.1 常用方法</h3><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>stack&lt;类型&gt; stk</code></td><td><code>stack&lt;int&gt; stk;</code></td></tr><tr><td>进栈</td><td><code>.push(元素)</code></td><td><code>stk.push(1);</code></td></tr><tr><td>出栈</td><td><code>.pop()</code></td><td><code>stk.pop();</code></td></tr><tr><td>取栈顶</td><td><code>.top()</code></td><td><code>int a = stk.top();</code></td></tr><tr><td>查看大小 &#x2F; 清空 &#x2F; 判空</td><td>略</td><td>略</td></tr></tbody></table><h3 id="2-3-2-适用情形"><a href="#2-3-2-适用情形" class="headerlink" title="2.3.2 适用情形"></a>2.3.2 适用情形</h3><p>如果不卡常的话，就可以直接用它而不需要手写栈了。</p><p>另外，vector 也可以当栈用，vector 的 <code>.back()</code> 取尾部元素，就相当于取栈顶，<code>.push_back()</code> 相当于进栈，<code>.pop_back()</code> 相当于出栈。</p><h3 id="2-3-3-注意事项"><a href="#2-3-3-注意事项" class="headerlink" title="2.3.3 注意事项"></a>2.3.3 注意事项</h3><p>不可访问内部元素！<strong>下面都是错误用法</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stk.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; stk[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele : stk)</span><br><span class="line">    cout &lt;&lt; stk &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-4-队列-queue"><a href="#2-4-队列-queue" class="headerlink" title="2.4 队列 queue"></a>2.4 队列 <a href="https://zh.cppreference.com/w/cpp/container/queue">queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><p>通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。</p><h3 id="2-4-1-常用方法"><a href="#2-4-1-常用方法" class="headerlink" title="2.4.1 常用方法"></a>2.4.1 常用方法</h3><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>queue&lt;类型&gt; que</code></td><td><code>queue&lt;int&gt; que;</code></td></tr><tr><td>进队</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出队</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取队首</td><td><code>.front()</code></td><td><code>int a = que.front();</code></td></tr><tr><td>取队尾</td><td><code>.back()</code></td><td><code>int a = que.back();</code></td></tr><tr><td>查看大小 &#x2F; 清空 &#x2F; 判空</td><td>略</td><td>略</td></tr></tbody></table><h3 id="2-4-2-适用情形"><a href="#2-4-2-适用情形" class="headerlink" title="2.4.2 适用情形"></a>2.4.2 适用情形</h3><p>如果不卡常的话，就可以直接用它而不需要手写队列了。</p><h3 id="2-4-3-注意事项"><a href="#2-4-3-注意事项" class="headerlink" title="2.4.3 注意事项"></a>2.4.3 注意事项</h3><p>不可访问内部元素！<strong>下面都是错误用法</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; que.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; que[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele : que)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-5-优先队列-priority-queue"><a href="#2-5-优先队列-priority-queue" class="headerlink" title="2.5 优先队列 priority_queue"></a>2.5 优先队列 <a href="https://zh.cppreference.com/w/cpp/container/priority_queue">priority_queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><p>提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。</p><h3 id="2-5-1-常用方法"><a href="#2-5-1-常用方法" class="headerlink" title="2.5.1 常用方法"></a>2.5.1 常用方法</h3><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p><ul><li>类型：要储存的数据类型</li><li>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pque1;                            <span class="comment">// 储存int的大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pque2; <span class="comment">// 储存int的小顶堆</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。如果想要了解，可以查阅 cppreference 中的代码示例。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>进堆</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出堆</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取堆顶</td><td><code>.top()</code></td><td><code>int a = que.top();</code></td></tr><tr><td>查看大小 &#x2F; 判空</td><td>略</td><td>略</td></tr></tbody></table><p>进出队复杂度 $O(\log n)$，取堆顶 $O(1)$.</p><h3 id="2-5-2-适用情形"><a href="#2-5-2-适用情形" class="headerlink" title="2.5.2 适用情形"></a>2.5.2 适用情形</h3><p>持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小&#x2F;最大的元素，元素数量 $n$，插入操作数量 $k$.</p><ul><li>每次插入后进行快速排序：$k\cdot n\log n$</li><li>使用优先队列维护：$k\cdot\log n$</li></ul><h3 id="2-5-3-注意事项"><a href="#2-5-3-注意事项" class="headerlink" title="2.5.3 注意事项"></a>2.5.3 注意事项</h3><h4 id="仅堆顶可读"><a href="#仅堆顶可读" class="headerlink" title="仅堆顶可读"></a>仅堆顶可读</h4><p>只可访问堆顶，其他元素都无法读取到。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; pque[<span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="所有元素不可写"><a href="#所有元素不可写" class="headerlink" title="所有元素不可写"></a>所有元素不可写</h4><p>堆中所有元素是不可修改的。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pque[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">pque.<span class="built_in">top</span>() = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果你恰好要修改的是堆顶元素，那么是可以完成的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tp = pque.<span class="built_in">top</span>();</span><br><span class="line">pque.<span class="built_in">pop</span>();</span><br><span class="line">pque.<span class="built_in">push</span>(tp + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="2-6-集合-set"><a href="#2-6-集合-set" class="headerlink" title="2.6 集合 set"></a>2.6 集合 <a href="https://zh.cppreference.com/w/cpp/container/set">set</a></h2><p><strong><code>#include &lt;set&gt;</code></strong></p><p>提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。</p><table><thead><tr><th>集合三要素</th><th>解释</th><th>set</th><th>multiset</th><th>unordered_set</th></tr></thead><tbody><tr><td>确定性</td><td>一个元素要么在集合中，要么不在</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>互异性</td><td>一个元素仅可以在集合中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>集合中的元素是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table><h3 id="2-6-1-常用方法"><a href="#2-6-1-常用方法" class="headerlink" title="2.6.1 常用方法"></a>2.6.1 常用方法</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p><strong><code>set&lt;类型, 比较器&gt; st</code></strong></p><ul><li>类型：要储存的数据类型</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; st1;               <span class="comment">// 储存int的集合（从小到大）</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// 储存int的集合（从大到小）</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。</p></blockquote><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>可使用迭代器进行遍历：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>基于范围的循环（C++ 11）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ele : st)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>插入元素</td><td><code>.insert(元素)</code></td><td><code>st.insert(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>st.erase(2);</code></td></tr><tr><td>查找元素</td><td><code>.find(元素)</code></td><td><code>auto it = st.find(1);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>st.count(3);</code></td></tr><tr><td>查看大小 &#x2F; 清空 &#x2F; 判空</td><td>略</td><td>略</td></tr></tbody></table><p>增删查时间复杂度均为 $O(\log n)$</p><h3 id="2-6-2-适用情形"><a href="#2-6-2-适用情形" class="headerlink" title="2.6.2 适用情形"></a>2.6.2 适用情形</h3><ul><li>元素去重：$[1,1,3,2,4,4]\to[1,2,3,4]$</li><li>维护顺序：$[1,5,3,7,9]\to[1,3,5,7,9]$</li><li>元素是否出现过：元素大小 $[-10^{18},10^{18}]$，元素数量 $10^6$，vis 数组无法实现，通过 set 可以完成。</li></ul><h3 id="2-6-3-注意事项"><a href="#2-6-3-注意事项" class="headerlink" title="2.6.3 注意事项"></a>2.6.3 注意事项</h3><h4 id="不存在下标索引"><a href="#不存在下标索引" class="headerlink" title="不存在下标索引"></a>不存在下标索引</h4><p>set 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念，无法通过下标访问到数据。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; st[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="元素只读"><a href="#元素只读" class="headerlink" title="元素只读"></a>元素只读</h4><p>set 的迭代器取到的元素是只读的（因为是 const 迭代器），不可修改其值。如果要改，需要先 erase 再 insert. <strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; *st.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">// 正确。可读。</span></span><br><span class="line">*st.<span class="built_in">begin</span>() = <span class="number">1</span>;             <span class="comment">// 错误！不可写！</span></span><br></pre></td></tr></table></figure><h4 id="不可用迭代器计算下标"><a href="#不可用迭代器计算下标" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h4><p>set 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = st.<span class="built_in">find</span>(<span class="number">2</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - st.<span class="built_in">begin</span>(); <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure><h2 id="2-7-映射-map"><a href="#2-7-映射-map" class="headerlink" title="2.7 映射 map"></a>2.7 映射 <a href="https://zh.cppreference.com/w/cpp/container/map">map</a></h2><p><strong><code>#include &lt;map&gt;</code></strong></p><p>提供对数时间的有序键值对结构。底层原理是红黑树。</p><p>映射：<br>$$<br>\begin{matrix}<br>1&amp;\to&amp;2\<br>2&amp;\to&amp;2\<br>3&amp;\to&amp;1\<br>4&amp;\to&amp;5\<br>&amp;\vdots<br>\end{matrix}<br>$$</p><table><thead><tr><th>性质</th><th>解释</th><th>map</th><th>multimap</th><th>unordered_map</th></tr></thead><tbody><tr><td>互异性</td><td>一个键仅可以在映射中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>键是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table><h3 id="2-7-1-常用方法"><a href="#2-7-1-常用方法" class="headerlink" title="2.7.1 常用方法"></a>2.7.1 常用方法</h3><h4 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h4><p><strong><code>map&lt;键类型, 值类型, 比较器&gt; mp</code></strong></p><ul><li>键类型：要储存键的数据类型</li><li>值类型：要储存值的数据类型</li><li>比较器：键比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;               <span class="comment">// int-&gt;int 的映射（键从小到大）</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// int-&gt;int 的映射（键从大到小）</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。</p></blockquote><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p>可使用迭代器进行遍历：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>基于范围的循环（C++ 11）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pr : mp)</span><br><span class="line">    cout &lt;&lt; pr.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pr.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>结构化绑定 + 基于范围的循环（C++17）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, val] : mp)</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>增 &#x2F; 改 &#x2F; 查元素</td><td>中括号</td><td><code>mp[1] = 2;</code></td></tr><tr><td>查元素（返回迭代器）</td><td><code>.find(元素)</code></td><td><code>auto it = mp.find(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>mp.erase(2);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>mp.count(3);</code></td></tr><tr><td>查看大小 &#x2F; 清空 &#x2F; 判空</td><td>略</td><td>略</td></tr></tbody></table><p>增删改查时间复杂度均为 $O(\log n)$</p><h3 id="2-7-2-适用情形"><a href="#2-7-2-适用情形" class="headerlink" title="2.7.2 适用情形"></a>2.7.2 适用情形</h3><p>需要维护映射的场景可以使用：输入若干字符串，统计每种字符串的出现次数。(<code>map&lt;string, int&gt; mp</code>)</p><h3 id="2-7-3-注意事项"><a href="#2-7-3-注意事项" class="headerlink" title="2.7.3 注意事项"></a>2.7.3 注意事项</h3><h4 id="中括号访问时默认值"><a href="#中括号访问时默认值" class="headerlink" title="中括号访问时默认值"></a>中括号访问时默认值</h4><p>如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>];                       <span class="comment">// 即使什么都没做，此时mp[&#x27;a&#x27;]=0已经插入了</span></span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; mp[<span class="string">&#x27;a&#x27;</span>] &lt;&lt; endl;       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="不可用迭代器计算下标-1"><a href="#不可用迭代器计算下标-1" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h4><p>map 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - mp.<span class="built_in">begin</span>();   <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure><h2 id="2-8-字符串-string"><a href="#2-8-字符串-string" class="headerlink" title="2.8 字符串 string"></a>2.8 字符串 <a href="https://zh.cppreference.com/w/cpp/string">string</a></h2><p><strong><code>#include &lt;string&gt;</code></strong></p><p>顾名思义，就是储存字符串的。</p><h3 id="2-8-1-常用方法"><a href="#2-8-1-常用方法" class="headerlink" title="2.8.1 常用方法"></a>2.8.1 常用方法</h3><h4 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h4><p>构造函数：<code>string(长度, 初值)</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1;           <span class="comment">// 构造字符串，为空</span></span><br><span class="line">string s2 = <span class="string">&quot;awa!&quot;</span>;  <span class="comment">// 构造字符串，并赋值awa!</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;6&#x27;</span>)</span></span>;  <span class="comment">// 构造字符串，通过构造函数构造为6666666666</span></span><br></pre></td></tr></table></figure><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>C++</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">cout &lt;&lt; s;</span><br></pre></td></tr></table></figure><p>C</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;buf);</span><br><span class="line">s = buf;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h4 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>修改、查询指定下标字符</td><td><code>[]</code></td><td><code>s[1] = &#39;a&#39;;</code></td></tr><tr><td>是否相同</td><td><code>==</code></td><td><code>if (s1 == s2) ...</code></td></tr><tr><td>字符串连接</td><td><code>+</code></td><td><code>string s = s1 + s2;</code></td></tr><tr><td>尾接字符串</td><td><code>+=</code></td><td><code>s += &quot;awa&quot;;</code></td></tr><tr><td>取子串</td><td><code>.substr(起始下标, 子串长度)</code></td><td><code>string sub = s.substr(2, 10);</code></td></tr><tr><td>查找字符串</td><td><code>.find(字符串, 起始下标)</code></td><td><code>int pos = s.find(&quot;awa&quot;);</code></td></tr></tbody></table><h4 id="数值与字符串互转（C-11）"><a href="#数值与字符串互转（C-11）" class="headerlink" title="数值与字符串互转（C++11）"></a>数值与字符串互转（C++11）</h4><table><thead><tr><th>源</th><th>目的</th><th>函数</th></tr></thead><tbody><tr><td>int &#x2F; long long &#x2F; float &#x2F; double &#x2F; long double</td><td>string</td><td>to_string()</td></tr><tr><td>string</td><td>int</td><td>stoi()</td></tr><tr><td>string</td><td>long long</td><td>stoll()</td></tr><tr><td>string</td><td>float</td><td>stof()</td></tr><tr><td>string</td><td>double</td><td>stod()</td></tr><tr><td>string</td><td>long double</td><td>stold()</td></tr></tbody></table><h3 id="2-8-2-适用情形"><a href="#2-8-2-适用情形" class="headerlink" title="2.8.2 适用情形"></a>2.8.2 适用情形</h3><p>非常好用！<del>建议直接把字符数组扔了，赶快投入 string 的怀抱。</del></p><h3 id="2-8-3-注意事项"><a href="#2-8-3-注意事项" class="headerlink" title="2.8.3 注意事项"></a>2.8.3 注意事项</h3><h4 id="尾接字符串一定要用"><a href="#尾接字符串一定要用" class="headerlink" title="尾接字符串一定要用 +="></a>尾接字符串一定要用 <code>+=</code></h4><p>string 的 +&#x3D; 运算符，将会在原字符串原地尾接字符串。而 + 了再 &#x3D; 赋值，会先生成一个临时变量，在复制给 string.</p><p>通常字符串长度可以很长，如果使用 + 字符串很容易就 TLE 了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化前: 15139ms</span></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5e5</span>; i++)</span><br><span class="line">    s = s + <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后: &lt; 1ms (计时器显示0)</span></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5e5</span>; i++)</span><br><span class="line">    s += <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="substr-方法的奇葩参数"><a href="#substr-方法的奇葩参数" class="headerlink" title=".substr() 方法的奇葩参数"></a><code>.substr()</code> 方法的奇葩参数</h4><p>一定要注意，C++ string 的取子串的第一个参数是<strong>子串起点下标</strong>，第二个参数是<strong>子串长度</strong>。</p><p>第二个参数不是子串终点！不是子串终点！要与 java 等其他语言区分开来。</p><h4 id="find-方法的复杂度"><a href="#find-方法的复杂度" class="headerlink" title=".find() 方法的复杂度"></a><code>.find()</code> 方法的复杂度</h4><p>该方法实现为暴力实现，时间复杂度为 $O(n^2)$.</p><p><del>不要幻想 STL 内置了个 $O(n)$ 的 KMP 算法</del></p><h2 id="2-9-二元组-pair"><a href="#2-9-二元组-pair" class="headerlink" title="2.9 二元组 pair"></a>2.9 二元组 <a href="https://zh.cppreference.com/w/cpp/utility/pair">pair</a></h2><p><strong><code>#include &lt;utility&gt;</code></strong></p><p>顾名思义，就是储存二元组的。</p><h3 id="2-9-1-常用方法"><a href="#2-9-1-常用方法" class="headerlink" title="2.9.1 常用方法"></a>2.9.1 常用方法</h3><h4 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h4><p><strong><code>pair&lt;第一个值类型, 第二个值类型&gt; pr</code></strong></p><ul><li>第一个值类型：要储存的第一个值的数据类型</li><li>第二个值类型：要储存的第二个值的数据类型</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; p2;</span><br><span class="line">pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p3;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>老式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>列表构造 C++11</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>直接取值</p><ul><li>取第一个值：<code>.first</code></li><li>取第二个值：<code>.second</code></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> awa = pr.first;</span><br><span class="line"><span class="type">char</span> bwb = pr.second;</span><br></pre></td></tr></table></figure><p>结构化绑定 C++17</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;[awa, bwb] = pr;</span><br></pre></td></tr></table></figure><h4 id="判同"><a href="#判同" class="headerlink" title="判同"></a>判同</h4><p>直接用 <code>==</code> 运算符</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p2 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123; ... &#125; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="2-9-2-适用场景"><a href="#2-9-2-适用场景" class="headerlink" title="2.9.2 适用场景"></a>2.9.2 适用场景</h3><p>所有需要二元组的场景均可使用，效率和自己定义结构体差不多。</p><h3 id="2-9-3-注意事项"><a href="#2-9-3-注意事项" class="headerlink" title="2.9.3 注意事项"></a>2.9.3 注意事项</h3><p>无</p><h1 id="3-迭代器简介"><a href="#3-迭代器简介" class="headerlink" title="3 迭代器简介"></a>3 迭代器简介</h1><h2 id="3-1-迭代器是什么？"><a href="#3-1-迭代器是什么？" class="headerlink" title="3.1 迭代器是什么？"></a>3.1 迭代器是什么？</h2><p>不搞抽象，直接举例。</p><p>对于一个 vector，我们可以用下标遍历：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>我们同时也可以用迭代器来遍历：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li><code>a.begin()</code> 是一个迭代器，指向的是第一个元素</li><li><code>a.end()</code> 是一个迭代器，指向的是最后一个元素<strong>再后面一位</strong></li><li>上述迭代器具有自增运算符，自增则迭代器向下一个元素移动</li><li>迭代器与指针相似，如果对它使用解引用运算符，即 <code>*it</code>，就能取到对应值了</li></ul><h2 id="3-2-为何需要迭代器？"><a href="#3-2-为何需要迭代器？" class="headerlink" title="3.2 为何需要迭代器？"></a>3.2 为何需要迭代器？</h2><p>很多数据结构并不是线性的（例如红黑树），对于非线性数据结构，下标是无意义的。无法使用下标来遍历整个数据结构。</p><p>迭代器的作用就是定义某个数据结构的遍历方式，通过迭代器的增减，代表遍历到的位置，通过迭代器便能成功遍历非线性结构了。</p><p>例如，set 的实现是红黑树，我们是没法用下标来访问元素的。但是通过迭代器，我们就能遍历 set 中的元素了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="3-3-迭代器用法"><a href="#3-3-迭代器用法" class="headerlink" title="3.3 迭代器用法"></a>3.3 迭代器用法</h2><p>对于 vector 容器，它的迭代器功能比较完整，以它举例：</p><ul><li><code>.begin()</code>：头迭代器</li><li><code>.end()</code>：尾迭代器</li><li><code>.rbegin()</code>：反向头迭代器</li><li><code>.rend()</code>：反向尾迭代器</li><li>迭代器 <code>+</code> 整型：将迭代器向后移动</li><li>迭代器 <code>-</code> 整型：将迭代器向前移动</li><li>迭代器 <code>++</code>：将迭代器向后移动 1 位</li><li>迭代器 <code>--</code>：将迭代器向前移动 1 位</li><li>迭代器 <code>-</code> 迭代器：两个迭代器的距离</li><li><code>prev(it)</code>：返回 it 的前一个迭代器</li><li><code>next(it)</code>：返回 it 的后一个迭代器</li></ul><p>对于其他容器，由于其结构特性，上面的功能不一定都有（例如 set 的迭代器是不能相减求距离的）</p><h2 id="3-4-常见问题"><a href="#3-4-常见问题" class="headerlink" title="3.4 常见问题"></a>3.4 常见问题</h2><p><strong><code>.end()</code> 和 <code>.rend()</code> 指向的位置是无意义的值</strong></p><p>对于一个长度为 10 的数组：<code>for (int i = 0; i &lt; 10; i++)</code>，第 10 位是不可访问的</p><p>对于一个长度为 10 的容器：<code>for (auto it = a.begin(); it != a.end(); ++it)</code>，.end 是不可访问的</p><p><strong>不同容器的迭代器功能可能不一样</strong></p><p>迭代器细化的话有正向、反向、双向，每个容器的迭代器支持的运算符也可能不同，因此不同容器的迭代器细节很有可能是不一样的。</p><p><strong>删除操作时需要警惕</strong></p><p>为什么 3 没删掉？</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span> || *it == <span class="number">3</span>)</span><br><span class="line">        a.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="comment">// a = [1, 3, 4]</span></span><br></pre></td></tr></table></figure><p>为啥 RE 了？</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">4</span>)</span><br><span class="line">        a.<span class="built_in">erase</span>(it);</span><br></pre></td></tr></table></figure><center><b>建议：如无必要，别用迭代器操作容器。（遍历与访问没关系）</b></center><h1 id="4-常用算法"><a href="#4-常用算法" class="headerlink" title="4 常用算法"></a>4 常用算法</h1><h2 id="4-1-内容总览"><a href="#4-1-内容总览" class="headerlink" title="4.1 内容总览"></a>4.1 内容总览</h2><p>打勾的是本次将会详细讲解的，其他的是算法竞赛中建议学习的，不在下表列出的在比赛中基本用不到。</p><p>（很多函数的功能很简单，自己都能快速写出来，但是使用函数可以让代码可读性变得更高，这在比赛中是至关紧要的）</p><ul><li><p>算法库 Algorithm</p><ul><li><input disabled="" type="checkbox"> <code>count()</code></li><li><input disabled="" type="checkbox"> <code>find()</code></li><li><input disabled="" type="checkbox"> <code>fill()</code></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/swap"><code>swap()</code></a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/reverse"><code>reverse()</code></a></li><li><input disabled="" type="checkbox"> <code>shuffle()</code> C++11</li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/unique"><code>unique()</code></a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/sort"><code>sort()</code></a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound"><code>lower_bound()</code></a> &#x2F; <a href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound"><code>upper_bound()</code></a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/max"><code>max()</code></a> &#x2F; <a href="https://zh.cppreference.com/w/cpp/algorithm/min"><code>min()</code></a></li><li><input disabled="" type="checkbox"> <code>max_element()</code> &#x2F; <code>min_element()</code></li><li><input disabled="" type="checkbox"> <code>prev_permutation()</code> &#x2F; <code>next_permutation()</code></li></ul></li><li><p>数学函数 cmath</p><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/fabs"><code>abs()</code></a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/exp"><code>exp()</code></a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/log"><code>log()</code></a> &#x2F; <code>log10()</code> &#x2F; <code>log2()</code></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/pow"><code>pow()</code></a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/sqrt"><code>sqrt()</code></a></li><li><input disabled="" type="checkbox"> <code>sin()</code> &#x2F; <code>cos()</code> &#x2F; <code>tan()</code></li><li><input disabled="" type="checkbox"> <code>asin()</code> &#x2F; <code>acos()</code> &#x2F; <code>atan()</code></li><li><input disabled="" type="checkbox"> <code>sinh()</code> &#x2F; <code>cosh()</code> &#x2F; <code>tanh()</code></li><li><input disabled="" type="checkbox"> <code>asinh()</code> &#x2F; <code>acosh()</code> &#x2F; <code>atanh()</code> C++11</li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/ceil"><code>ceil()</code></a> &#x2F; <a href="https://zh.cppreference.com/w/cpp/numeric/math/floor"><code>floor()</code></a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/round"><code>round()</code></a> C++11</li></ul></li><li><p>数值算法 numeric</p><ul><li><input disabled="" type="checkbox"> <code>iota()</code> C++11</li><li><input disabled="" type="checkbox"> <code>accumulate()</code></li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/gcd"><code>gcd()</code></a> C++17</li><li><input checked="" disabled="" type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/lcm"><code>lcm()</code></a> C++17</li></ul></li><li><p>伪随机数生成 random</p><ul><li><input disabled="" type="checkbox"> <code>mt19937</code></li><li><input disabled="" type="checkbox"> <code>random_device()</code></li></ul></li></ul><h2 id="4-2-swap"><a href="#4-2-swap" class="headerlink" title="4.2 swap()"></a>4.2 <code>swap()</code></h2><p>交换两个变量的值</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="comment">// now a = 1, b = 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">4</span>], arr[<span class="number">6</span>]);</span><br><span class="line"><span class="comment">// now arr = &#123;0, 1, 2, 3, 6, 5, 4, 7, 8, 9&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>这个 swap 参数是引用的，不需要像 C 语言一样取地址。</p><h2 id="4-3-sort"><a href="#4-3-sort" class="headerlink" title="4.3 sort()"></a>4.3 <code>sort()</code></h2><p>使用快速排序给一个可迭代对象排序</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure><p>默认排序从小到大</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// arr = [0, 1, 1, 1, 8, 9, 9]</span></span><br></pre></td></tr></table></figure><p>如果要从大到小，则需要传比较器进去。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">// arr = [9, 9, 8, 1, 1, 1, 0]</span></span><br></pre></td></tr></table></figure><p>如果需要完成特殊比较，则需要手写比较器。</p><p>比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们定义的该比较操作为 $\star$：</p><ul><li>若 $a\star b$，则比较器函数应当返回 <code>true</code></li><li>若 $a\not\star b$，则比较器函数应当返回 <code>false</code></li></ul><p><strong>注意：</strong>如果 $a&#x3D;b$，比较器函数必须返回 <code>false</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.second != b.second)</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr&#123;&#123;<span class="number">1</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">9</span>&#125;, &#123;<span class="number">8</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="comment">// arr = [(0, 0), (8, 1), (2, 9), (1, 9)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-lower-bound-upper-bound"><a href="#4-4-lower-bound-upper-bound" class="headerlink" title="4.4 lower_bound() &#x2F; upper_bound()"></a>4.4 <code>lower_bound()</code> &#x2F; <code>upper_bound()</code></h2><p>在<strong>已升序排序</strong>的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。<strong>找不到则返回尾迭代器。</strong></p><ul><li><code>lower_bound()</code>: 寻找 $\geq x$ 的第一个元素的位置</li><li><code>upper_bound()</code>: 寻找 $&gt;x$ 的第一个元素的位置</li></ul><p>怎么找 $\leq x$ &#x2F; $&lt; x$ 的第一个元素呢？</p><ul><li>$&gt;x$ 的第一个元素的前一个元素（如果有）便是 $\leq x$ 的第一个元素</li><li>$\geq x$ 的第一个元素的前一个元素（如果有）便是 $&lt;x$ 的第一个元素</li></ul><p>返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line"><span class="type">int</span> idx = it - arr.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// idx = 4</span></span><br></pre></td></tr></table></figure><p>我们通常写成一行：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="4-5-reverse"><a href="#4-5-reverse" class="headerlink" title="4.5 reverse()"></a>4.5 <code>reverse()</code></h2><p>反转一个可迭代对象的元素顺序</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">( BidirIt first, BidirIt last )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line"><span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span></span><br></pre></td></tr></table></figure><h2 id="4-6-max-min"><a href="#4-6-max-min" class="headerlink" title="4.6 max() &#x2F; min()"></a>4.6 <code>max()</code> &#x2F; <code>min()</code></h2><p>返回最大值 &#x2F; 最小值的<strong>数值</strong></p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在 C++11 之后，可以使用列表构造语法传入一个列表，这样就能一次性给多个元素找最大值而不用套娃了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before C++11</span></span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">min</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// After C++11</span></span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="4-7-unique"><a href="#4-7-unique" class="headerlink" title="4.7 unique()"></a>4.7 <code>unique()</code></h2><p>消除数组的重复<strong>相邻</strong>元素，数组长度不变，但是有效数据缩短，返回的是有效数据位置的结尾迭代器。</p><p>例如：$[1,1,4,5,1,4]\to[1,4,5,1,4,\underline?]$，下划线位置为返回的迭代器指向。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">unique</span><span class="params">( ForwardIt first, ForwardIt last )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>用法示例</strong></p><p>单独使用 unique 并不能达成去重效果，因为它只消除<strong>相邻</strong>的重复元素。但是如果序列有序，那么它就能去重了。</p><p>但是它去重后，序列尾部会产生一些无效数据：$[1,1,2,4,4,4,5]\to[1,2,4,5,\underline?,?,?]$，为了删掉这些无效数据，我们需要结合 erase.</p><p>最终，给 vector 去重的写法便是：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">arr.<span class="built_in">erase</span>(<span class="built_in">unique</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="4-8-数学函数"><a href="#4-8-数学函数" class="headerlink" title="4.8 数学函数"></a>4.8 数学函数</h2><p>所有函数参数均支持 <code>int</code> &#x2F; <code>long long</code> &#x2F; <code>float</code> &#x2F; <code>double</code> &#x2F; <code>long double</code></p><table><thead><tr><th>公式</th><th>示例</th></tr></thead><tbody><tr><td>$f(x)&#x3D;\lvert x\rvert$</td><td><code>abs(-1.0)</code></td></tr><tr><td>$f(x)&#x3D;e^x$</td><td><code>exp(2)</code></td></tr><tr><td>$f(x)&#x3D;\ln x$</td><td><code>log(3)</code></td></tr><tr><td>$f(x,y)&#x3D;x^y$</td><td><code>pow(2, 3)</code></td></tr><tr><td>$f(x)&#x3D;\sqrt x$</td><td><code>sqrt(2)</code></td></tr><tr><td>$f(x)&#x3D;\lceil x\rceil$</td><td><code>ceil(2.1)</code></td></tr><tr><td>$f(x)&#x3D;\lfloor x\rfloor$</td><td><code>floor(2.1)</code></td></tr><tr><td>$f(x)&#x3D;\left&lt;x\right&gt;$</td><td><code>rount(2.1)</code></td></tr></tbody></table><p><strong>注意事项</strong></p><p>由于浮点误差，有些的数学函数的行为可能与预期不符，导致 WA。如果你的操作数都是整型，那么用下面的写法会更稳妥。</p><blockquote><p>原文地址：<a href="https://codeforces.com/blog/entry/107717">https://codeforces.com/blog/entry/107717</a></p></blockquote><ul><li>$\lfloor\frac{a}{b}\rfloor$<ul><li>别用：<code>floor(1.0 * a / b)</code></li><li>要用：<code>a / b</code></li></ul></li><li>$\lceil\frac{a}{b}\rceil$<ul><li>别用：<code>ceil(1.0 * a / b)</code></li><li>要用：<code>(a + b - 1) / b</code>  （$\lceil\frac{a}{b}\rceil&#x3D;\lfloor\frac{a+b-1}{b}\rfloor$）</li></ul></li><li>$\lfloor\sqrt a\rfloor$<ul><li>别用：<code>(int) sqrt(a)</code></li><li>要用：二分查找 <a href="https://io.zouht.com/7.html">https://io.zouht.com/7.html</a></li></ul></li><li>$a^b$<ul><li>别用：<code>pow(a, b)</code></li><li>要用：快速幂 <a href="https://io.zouht.com/18.html">https://io.zouht.com/18.html</a></li></ul></li><li>$\lfloor\log_2 a\rfloor$<ul><li>别用：<code>log2(a)</code></li><li>要用：<code>__lg</code> （不规范，但是这是竞赛）&#x2F; <code>bit_width</code>（C++20 可用）</li></ul></li></ul><h2 id="4-9-gcd-lcm"><a href="#4-9-gcd-lcm" class="headerlink" title="4.9 gcd() &#x2F; lcm()"></a>4.9 <code>gcd()</code> &#x2F; <code>lcm()</code></h2><p>（C++17）返回最大公因数 &#x2F; 最小公倍数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">gcd</span>(<span class="number">8</span>, <span class="number">12</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> y = <span class="built_in">lcm</span>(<span class="number">8</span>, <span class="number">12</span>); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>如果不是 C++17，但是是 GNU 编译器（g++），那么可以用内置函数 <code>__gcd()</code>.</p><p>当然，<code>gcd</code> &#x2F; <code>lcm</code> 函数也挺好写，直接写也行（欧几里得算法）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记 240123 | 阅读、学习</title>
      <link href="/posts/19129/"/>
      <url>/posts/19129/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="此文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="552f3e59170ac87be2554046284505756937a99d052c77c83cd783f9312c9418">d7101d19ddf67ff2dbafa3145e5c10c3fcd3dc23544451617469759b043aba6c5060e5725510d17cc67eb109d1faefd5cf3f92858cc8acb786f421e38ec4570733e167ab28088b6d475179c099414e5f7c990022351a1e23ac26ea7daca501ce79005548d8160898af37570d8e5dcee039509d97275dc122528110f9a03f1f92c98d94946c5fe007851f08ab95081c55cf20f3825c60bb1c5883be67668188742bd5dd2bebc467923ff6a99ebc7dd1524f6d924618b3c017dec0dff63bc36ff69f84de13d37c766c7d0f55ba4b11bc8fa70267ef9ab4d93ed264f3acc90a1bd56d4cdfa4a672e4769bec597491023d081aad5fc60ce3c6749ee405d40d4d20bf844166c8fbdf8762a57fb3ab106e1cecea5bf0130b384a98f2e92072d563bd1edb3989e801cdbad91f5ee6194a75d4dfabf103ad7a2fdcc34474ede617767f2e9b83e5639355e39545c50ceb81889c4afc13cadfd6de801342f6d98d49f568e034e49b87d74988324350e2ca7a800686518f7d3af9c460c4d47dedfa432ae2276c9079b2b01b148350ae540dc2aa32b828f5a30fde8df52e1a67543983f5fe78c6c2d11257cecce1282f9686fe1d39aa4ad5edac15ff1b4f64157143224c400a6817d9c5dbe6102ac221523f869db2ef0a586acec03e5f23e6146a5cadc54dfee499589dd1a9fe22b23508ea62217e6a0cd8562290871393225b5264f513f7cf42e575aab92cdb23e86700ee0ef5ab5e205f9011478b17040ee4178d389011d1f9529ab1833b2566f63c7a0e77499ee95e698379671cccc445b251cd111d442dcb60b152a366d1745d70112d7ca2c4f1946f101a8b11dbaa97c57f880d756b56e0665aaaabf9da69eec5b116359aadd929310931ed7272f1cabbb4706db61b6dcca30be8d449e26895ebd9fd607581b783ac14de6af4db4deeeb0d83698fbdde</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小记 </tag>
            
            <tag> 语录 </tag>
            
            <tag> 空无 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记 240122 | 阅读、生活</title>
      <link href="/posts/30817/"/>
      <url>/posts/30817/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="此文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="35017a14ebdf15a584cbad8d04aeec5210e37fde31279c6a062f38bb35dd771d">73516ce51c0febcc53f6c4242687819e8dc370c68773b6e036b2f1a13120eff95124eae5b1fdd972c5d7c771802df0a631773307a654c48ecf0735ef6526b926733a9b593bd6fd70bc2631e060f83ef121d6d9fb2400845285251ae2649a878ec86fd1c393f91cc10c5f9d48b85b045c066896a6ae86cd5a396505dceba32ebaad2038f8fce8580fd447547bcd3c067cbc4a0603e256da4f8ce3cdb1afa93eb0ad32d31997d273fcb00548ef309ce2ace1817097881a655ebf9f63e5650b096ffdbe39bf3966c3cdc334edcc98bba9f2b419154853a71cf7818db13cb61aecaa7bc713d1f819bb527391a5786098b3328b6e025749ddfc01607a561c8d27c886dff95dd8d39b590749d15dfa521749200c5ba76c53c806de83ce4c9134307dd3a26211951dd5d3da20a5ea7f3b605c43bbc36a14c1577b2be8f0644835bd2281b6728056a24dcf43e7023ddccd22b73b4766fa6b1acf771eb52f7fd81e32930726ca6b443b8ab10f880768d14b017ced9f8ce8a6ece4b3ef1d950eb9dc34ff158df2fe31b3a916e5ad35367359dce7b20113d525fc2658a308322eabb5290f23e34af28ec5e3938ed1950be16a45acda68a0628860eb0ce5cbd31b9d399ad722c18a9901d5cf9c393dc7b8c77be01c45c6d3ee8a4ac3818147c71a8e4721fac38088dfb12a5a35c34c622eff435741533a7ca595c8fb472d0eca2472681dcf6bea4e1a142f1c4b0d23709462efd6fff6584eb7cf8273f5cd2a24eb912a725b1274fa28a553107ee4972b7062eed770a11dac7fb69e49a1aa314959414d8f3f4f6c335dd1325e6f323f19cbb9e57e818d7235ca881c45271fc4c9a9655121f172cf97448aa7d04f179e5fb0da034ef9ec68e50a4262f778e0b552d9818674842018b8d506423b4abee939b87da2ff59ae642463801ca7ff7bf139751ce2897b8055b3a3c5300d13da76712080893e61f9c1ee8278e65741fc012ce9e286296d397062c26b3574bddf45710a594e48e60b51bf8b52be2eea31ed823a979019fcb516beccb743b0116659b071864175fba30ceec4b2cdf5f2bad36a14da3ee2b373047e3f8ae9cf403cf0c8110e2717964b389a6e6c34fab906128cbf4cd269637ae9ed0e9ed21a9a2cc19ec226676e50b057013d8706efa323af4aac743f752bfe57fd96323c9fd10736db3f5459cfa6bb7bb816f72335b5b861d808db16b7bfbc484294fafe65ce666f5fa68fa093d7c38caa3d04ef0a9733f01883be0ee7c001dbd3d693c871c3da9adcbe3c2a058294e5d63d74bd6009c6a30a3df92e48f4b4826212eeef6e3e672802e9e3c8453f66bba8e7ebb16f014d094db6fd2571b70850526477925be7538ddbe327ef061ed6a3356ecaf0c2e53f123cb77ca9e586ed48f8c5ef9d180f0bd0b6a2b1d31583b5fdf057fd9a9c63437d5d917664205d0660866da329cf1e3d874036dbd2503371546b23e709a55fbb6ac8361e503736650a995de924a7bd513d08ef5116faaa9cdd345c0aefd7edda12ffd4e6483c1043c43d77a540d87c1a5fa48f35d63c4c5e227526ae9f64acd892235657b87057454efb7546d63260d93fd54802f7ef6040946a2b736afe1022f6d602833e6b26efd99dfa737f964514d743108696d2ccbfb1638991c083c44ea7f757c99e11d5096c0e4f92880ea3a88d1a1a9c64edf1acf5ffd96419a840c04e6906b5a151e48f4aab5fa5a760e745481ce059367d83a861383acfe19db8139b0987b0a47a64019373b8334bd64c5663f01127590b306a18a40d04d367bc3696f64ea0ca98638f1924eb628b35ae8a76b8db8f7222806da41c317a066001beeed5f83cb3c01d10f30479714211db429a5cf797dfc9a4109efe3c6f1d2d5d4cc574dc19f7c438c68dd4f9e7e090839ba5a87c1d440fcd34</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小记 </tag>
            
            <tag> 语录 </tag>
            
            <tag> 空无 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 787. 归并排序</title>
      <link href="/posts/4234/"/>
      <url>/posts/4234/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><blockquote><ul><li><a href="https://www.cnblogs.com/littlehb/p/15223759.html">AcWing 787. 归并排序 - 糖豆爸爸 - 博客园</a></li></ul></blockquote><hr><h1 id="AcWing-787-归并排序【简单】"><a href="#AcWing-787-归并排序【简单】" class="headerlink" title="AcWing 787. 归并排序【简单】"></a><a href="https://www.acwing.com/problem/content/789/">AcWing 787. 归并排序【简单】</a></h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定你一个长度为 n 的整数数列。<br>请你使用归并排序对这个数列按照从小到大进行排序。<br>并将排好序的数列按顺序输出。</p><p><strong>输入格式</strong><br>输入共两行，第一行包含整数 n。<br>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。</p><p><strong>输出格式</strong><br>输出共一行，包含 n 个整数，表示排好序的数列。</p><p><strong>数据范围</strong><br>1≤n≤100000</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h2 id="二、算法原理"><a href="#二、算法原理" class="headerlink" title="二、算法原理"></a>二、算法原理</h2><p>相关的分析、总结都在这篇帖子了：</p><blockquote><p><a href="https://akari2333.github.io/posts/3605/">第一讲 基础算法 - 02归并排序 | Akari的小站</a></p></blockquote><h2 id="三、实例模拟"><a href="#三、实例模拟" class="headerlink" title="三、实例模拟"></a>三、实例模拟</h2><p>具体的我们以一组无序数列{14，12，15，13，11，16}<br>为例分解说明，如下图所示：</p><p><img src="https://telegraph-image-box.pages.dev/file/e409821ae30d5fe202fb1.jpg" alt="1"><br>上图中首先把一个未排序的序列从中间分割成 2 部分，再把 2 部分分成 4 部分，依次分割下去，直到分割成一个一个的数据，再把这些数据两两归并到一起，使之有序，不停的归并，最后成为一个排好序的序列。</p><h2 id="四、AC代码"><a href="#四、AC代码" class="headerlink" title="四、AC代码"></a>四、AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @version:</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-22 11:50:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deb(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, q[N], tmp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_soft</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">merge_soft</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_soft</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = (l + (r - l) / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">merge_soft</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_soft</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一讲 基础算法 - 02归并排序</title>
      <link href="/posts/3605/"/>
      <url>/posts/3605/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><blockquote><ul><li><em><a href="https://www.acwing.com/blog/content/4018/">AcWing《算法基础课》第1章 算法基础 - AcWing</a></em></li><li><em><a href="https://www.cnblogs.com/littlehb/p/15223759.html">AcWing 787. 归并排序 - 糖豆爸爸 - 博客园</a></em></li><li><em><a href="https://blog.csdn.net/qq_45438600/article/details/116795979">AcWing 算法基础课笔记 1.基础算法-CSDN博客</a></em></li><li><em><a href="https://www.runoob.com/w3cnote/merge-sort.html">1.5 归并排序 | 菜鸟教程</a></em></li></ul></blockquote><blockquote><ul><li>推荐一个数据结构可视化网站，可以看到归并排序的推理过程：<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html</a></li></ul></blockquote><hr><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ol><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ol><h2 id="二、算法步骤"><a href="#二、算法步骤" class="headerlink" title="二、算法步骤"></a>二、算法步骤</h2><p>菜鸟教程：</p><blockquote><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol></blockquote><p><img src="https://telegraph-image-box.pages.dev/file/ef3ac94ba77c4fbf9aaad.gif" alt="gif"></p><h2 id="三、基本思想"><a href="#三、基本思想" class="headerlink" title="三、基本思想"></a>三、基本思想</h2><p>基于分治，以中间为分界。</p><ol><li><strong>确定分界点</strong> mid &#x3D; (l + r) &#x2F; 2</li><li>递归处理左右两段</li><li>归并——合二为一（双指针算法，指针表示剩余部分中最小元素的位置）（<strong>较难部分</strong>）</li></ol><p><img src="https://telegraph-image-box.pages.dev/file/9a9bf2e7054338d090387.jpg" alt="1"></p><h2 id="四、实例说明"><a href="#四、实例说明" class="headerlink" title="四、实例说明"></a>四、实例说明</h2><p><strong>Q：</strong> 归并排序的第二步递归排序左右两段是怎么实现的？为啥递归后就有序了？是什么原理？<br><strong>A：</strong> 纸上画一下你就理解了，递归相当于一个树形的结构，归并排序的话先递归，递归到最后一层就是树的叶子结点，也就是数组中的单个元素，不需要比较，然后返回上层，就是两个元素，然后排序这两个元素，然后再返回上层递归，依次类推，这样就能排好序了。</p><p><strong>如下图所示：</strong></p><p><img src="https://telegraph-image-box.pages.dev/file/216ab5659939cc867d4b3.png" alt="2"></p><p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。<strong>分</strong> 阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p><p><strong>合并相邻有序子序列</strong><br>再来看看 <strong>治</strong> 阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4,5,7,8] 和 [1,2,3,6] 两个已经有序的子序列，合并为最终序列 [1,2,3,4,5,6,7,8]，来看下实现步骤。</p><p><img src="https://telegraph-image-box.pages.dev/file/f24426581b348c259fb51.png" alt="3"><br><img src="https://telegraph-image-box.pages.dev/file/1ca005af2ce546a45770e.png" alt="4"></p><h2 id="五、代码模板"><a href="#五、代码模板" class="headerlink" title="五、代码模板"></a>五、代码模板</h2><p><strong>注意：</strong><br>在归并步骤时，如果碰到相同元素的插入，每次都选择第1段（左边）的元素插入，则能使归并算法<strong>稳定</strong>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_soft</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;   <span class="comment">// 基本情况：如果左边界大于等于右边界，则返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = (l + (r - l) / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">merge_soft</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_soft</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;  <span class="comment">// 初始化用于合并的变量</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)      <span class="comment">// 比较左右两半的元素，按顺序合并到临时数组 tmp 中</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];  <span class="comment">// 处理左半段中剩余的元素（如果有）</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];    <span class="comment">// 处理右半段中剩余的元素（如果有）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];  <span class="comment">// 将合并后的元素复制回原数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Q：</strong> 最后一步合并后的元素复制回原数组是怎么实现的？初始化条件是怎么设置的？<br><strong>A：</strong> 这段代码是在归并排序的最后阶段，将排好序的临时数组 <strong>tmp</strong> 中的元素复制回原始数组 <strong>q</strong> 中。在归并排序的过程中，数组被分割和合并，最终需要将合并后的结果放回原数组，以完成整个排序过程。<br>具体来说，这个循环的作用是将 <strong>tmp</strong> 数组中的元素按顺序复制回原数组 q。循环的初始条件是 <strong>i</strong> 等于左边界 <strong>l</strong>，而 <strong>j</strong> 则从 <strong>0</strong> 开始。在每一次迭代中，将 <strong>tmp[j]</strong> 复制到 <strong>q[i]</strong> ，然后分别增加 <strong>i</strong> 和 <strong>j</strong> 的值。这个过程一直持续，直到 <strong>i</strong> 大于右边界 <strong>r</strong>。<br>这样，经过这个循环，排好序的元素就被正确地放回到原数组 <strong>q</strong> 中，完成了整个归并排序的过程。</p>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记 240119</title>
      <link href="/posts/31372/"/>
      <url>/posts/31372/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="此文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f840c48de1b3c2cae77385f9827328307e3adcdc48f36e17874c234f30237abe">6eea61888870a3d7f027c4b8a742d1e2eeedcea4f9e83fd948fdd0ae1c63478bc5d36a7146a6bce8c79094ac7d8497331e6be0c9883ab8565bc8257bd43d162c35b5e799ea89e5c0007bc84aa8f76dabfe58f9faaec6d0aa8a8dd8237b95cdfb058f0b0a1deb1c1a220538d3a9553663ed3cc2aeda0b27c94d02a0d406302ab4bef9425dd51c8ebc5ac3a401edbfe0cc815fbc89f04d80b5b78e26d5ff39e16110a686312134910c832cc3d33f22103d02e4ad4faf0b10de8dd06fe464ada6ca2bf62b96546c791c6a2000986192977f887f6880803d32f8ac37ee74dee31df71f12128b5dd5a74342a307a89c67a7343a209b4067466501ca8801cf0bb7b5f99256ce70e09ff704721aec443042161895621a952da5db6a517f11bfcbb108057d2fc6293d6fc23ada4612273e36c17de2bb5e22de583f0d2329528f4a27e2dca30a89b683f403b585c6a8e6947d254738623aa08795caad7f85df9400ec7cf2ce576370fa9cd0ee8329440b2667af8d85ec547b4d4bf142fa5ba54a7a8bd6a438d5545198d7a0d3e3eed6e1277d2b4289b9df4444261af0aec7681d9b68595535d5bfe508ba327c095b6592eb585d85d63e5621da63db76960a5a1c0c5139dff4c2ef7bfa406384946a7749371eff21f7a49a8eb422ec2e9604d120d9bfac3afaf3f93a2b642d3eee46ad97458b587e1894a7c636ddacd036bd148171d0efea921533e1d7e5346f48b473c44ab40d13042fb930ec43e98a5345f40818fd8b14d0a6fbc7f38a3860528705adf09a3aace2e9fde17cee3584d7fa5b78f114bd36167b496c500409ace3c32adb37b66d3b3dd7f8a30040f85220a86bdc6ba18c3d5394ef0777b9dd35002df6b17c4ecbae7aa0e7d9559d9aa4e4ed9526b812d7f16e299710afd084a5426b51d3a069e8a3edd2bbb63db1e4d8cff704a62f415ba613a072adb6f2170e0cea4aa018ab9b7366c56f7b711d6ac009370ec7820060a56d897dc8fb5ddd67bd5844aac9c8175e09230494f456fb08a81b5cbc56e82af3fd1b3b05229884c22a6f825ac3ae613afbda17465e8907a4c47f4186ea8196e31808782d50db1769c8851f284ca35979c01f4d5687a8e371afe4c254f349a0f1bd13ea1607fbacd9da0b1e052f6e0b5d20e413b109910e18742d3800b2372da8d6cb231204021b158c3c3f2f22012e302584bdc9cc27f3d31737d5bf7b7fc2b54367d85269613230cd2d480db127690d363e9ee5ffddae0bd2553a5d955baec9cb0df3c0859c422129a1acfe8eed33aa3100e62ddaf6f3e201dbddf442cc1b3286cc54860b2ac50f4f744905ffc460241e125c17cfa40ca9703186388499eb25ed496bcd5d0bd1c7dbde9ef33541b51ce76e64c3bc328fd66347eb7b3a21f5ab25116615ef89a058b4cccd1348fdccf1de177f7a43c96c5f62ba797a4d959c96942c20488fa4afd01e6d1680e0f5d0f64709ae057a44e776110b34034482eb990d1fca284a34f61b728ac785a0143925ae2f96ee17baff901725a64865e011b56ff09a80e84aa41ffdac14a7b67b8f13ab110101ea1055e6ecccca8eeb542c127420e24ce44f7f7bd92f20ec1e19eb0aa5bdd4d0dbd58e6bf48eed17fd05b3f4f35a8aee2217c30b7a86f009140dd3095242b51d91ae6d4c743462265d3508d538e05bbcf05eef1c196cd8aec00e6234a55ceefd31a9130ae2bd87f0869367597664872ab2874f08dd8a9f0d21d57289fa7eb81da249eb703032103aee6507eb83ec043af48ee60ff7f2b7f69ce240127d1166c12781f88947755028a9ab449d856f91a677ff6fe51866c5121cd6ad32a10e70b711847baf978e72c4f769074d84d123b24107e61f500aea1a8c570723c48e9a30918333e90025051257f32dfece46e2cff00c0fd8dbd82a9f3e307d20c4bdb95340aef84447212fb1e4760ee72b4c33e44a5589eb22da766837de08b7228cd70b736ca04bbacde03a80ced242c3c4c52275bd1840e67b62d0a359d46dcbd247bdd2db60b941243c6eeacd7494a789414b5ae6eecf028607a946e30e6f64541343141be4ff03489aeea045a5dcef8fa361e219d3bbda889f268bc4b902f65f4abee5134db5ca64e11f409325d6a307674bae9df237a2f52988f9aff7b42a2ddd30d20d85a18e24eed6ee408d6d908e48c7a6d21e9b9895b42bc799179abd50c4bb4a06a5f88618dbfef045a72a9a281ec199e08375061ad7c05e075cfa231b40e74287ee717bdc32ec096d6fd9203bd987795112f2252add9a1d34354d92ac589ca9fcc54e1ab1c5bcfbf783c65f3b2162755ebfcf8e00faa4cac9dbf352ce6d936c9ab17f38d50d5294979b44b29684665fe27ca1b0e6a55b7e59b9c10dbaa5735a1e86c0fd09772a4e6499156e54394de463478d078abba69a279c5d7b23add100a7f30da2ce00e0ff7f5311f799b744316beb349ba71c2a6cfc6f732ba1286d890cd28563df4ced5a51731feb6a35b3a8bf0a84fd0abfca8767b5beca78a37df49978fc40cf6e61bbe4eece254f9e5dd2fc461c19a2b4a97bd35089102f4bd40ebe60089b7f6ba4d1043ccfc1338720360abc3ce0e4882e63ac600cbd0f742cd5650edb590652c8100cb8115777d41be637a48f7c9f41033785a5e822e432234c777e6e382674adc6950083bc1f8a1df60bd501cf425ece5698c5a7e77e1333f680fd76b457979486aa79eea7b21aecc14d56638eaec099677ed103821522bae4b9b874c28271be480787327e1104ed38346deced90588aac6045387bcc74af796515569972d428812f544f5e9338d25dd40edb31ade4e9f751cc7a0b2f7d2a39d5a79d5a8a7a719a37e1e7257779abf526a847b0792ca50cc3a975fdc27f4b727d308782e5e3e1e71d7e3cc67e02ce0a7d8568eea9ede8fa532c1880d76c9a43efeea7701424ecd2c63f88a090211bf45c7efdc7ee1a6e71419fc978eaa62115d513843b7d3db04794cb5cd7a933b122f261b2301ef662fd3f4d0ccb5326546b4bc0c85e10a0e7e7a4a3f3d03c8875dbfc04120f4ef30ba4de66b7bf289b2de56d95be03584edd3de10478ac691f7b269883a62a9e670093471cf5f98bfca2599c5c511f352cb48ca27f9e1f713e09f8a88653cf57aa81edd9ba315b5ed12f5534e4905f3c3d0bc47f0435d69638a7593fd2ac2bdd35b02f73a888f961abd0e799fdd51d6ab70599494bad9399509881c37de88050c605f26305028b9e1b55e8cc87ab896fb64a71bf3f2ac0e85a7f14c953d97624d81f72e361b3bac5a7965ae201672bfef346a444cc19150d2c089dd70a07738c69ffc3bc7f440a48d3e6f16a71fc7d43a98d6a3cad5d18fe5f9077911435d977d5c48de058c7994e2fb4e7eaa9e86ea91ce424e3f8cf019b0d46a0701db87c8a496bb97c6922b4604f003473a33fff8e6ba096c6470ebacfe33b563cc021cb9716563dc8e4704e5d522bfb4eaf5e825034dcc5b73e60f57fc5a1d0eafe867ecb876bd957a540ed3cadf8af9463a235497876ce3953c3a28504e931382d1a9c766c8f02d2f7279340f0584c8fbf1588ffde939bba6fd50301cbfca911d34939b2222bf3000c269658df3ccc6286fd72419ef6759a322ecdf382d0fae3445384c54a67a0c5249b0d55455cc4564de2ede8f8f04e3fcfbf4425ac27c11dd50d9bededbbee31ab2f3653be773ead56d6119e423e7c770d8d5d614ce02f67f15cb460df304f03c1352fa0c75eb99bb32ee77775f180edc19c53618596afcae77250c30cf20c0be9a1698d4b8191835606384eecebf9f1ecbb370d91690683c5abd54b5ea4a46a2be5e5fd5b883a130bce6bfc6143f742068bb346a0947d1c966707558673e5cf3dcdd400ccf952bd6a4cce6d21db67ca6dfb657eacef0d00c9f6a630df6fc795e4842eaf16ab6c09f13b526c7bb89d2314c0b8cd4915b0716eb9e1ca39729a2c616f30fbd72e00a6028384adbc901bacaa5981ddf30fa0eeaf114c4ae98682bc0b3dfd69b39773b2210486005e6930a0c2d31d9cdd66deb3aec86261a97e819584c36116219cc3e922e993d87c0316ed78b39251d443a4a6f8fb75610a4e5ef000bb9960198164ae3300348bff78be338252e01f803c7bee5444d3d15ed6df93e6cc639bd7084b789915bbf62a6b6ea0b16e6eb8b7c52e2ef87c6e2284ba0e1accbc7b02054f9d0db2782fef84b167eed94536d5c3331ec42eb0eae5a286d9eae0849218b76fe312510f5dc97f27cefcda26f7b27d297558db6b71fb5db021e1bcb9d7f83655858deb98448be8c9cb04b01ca8d64206e60b0aea30695f72d5889d3d66d46fd08ba1aa77f2ef453f1645be6c69b914d4a44d003054a26e1af46bc669ba92a01fc37815a640ae6f2515aa6cc37c0c20570a6e789df61c97da6d588576c3569a99d1c66c81de2a82557b60e3b8ea6a3cddc88ff73b0ae3a4ef4a1cf79644f2cdfe9ae3b8f9227eec36c13498f854bdcd193e92611fb6cbb5da88c92e13491e29ab9f7288819da630cf3c3bd520cc9805d7973fd3b393fc266b1cca7b5172cab8efe27fc2a2b51853a7bb96ac73f2c51ad96d4dfd2ace14c3b1fa485184213ca9768ff10821654e41a66ea1b1354e8d5fb9dc5a99e887dd062ab52862c63d314f983f244129076b4859d500542b19a7c83cb4c8a0bec183e8d6aa94e0847e1dddcdb5bb9e33cd9e054017a3c26faba20370468b15e95d3aa66f9c7d93650ab9d587a055e40ad11d8b1a52cbdec66a5e743fe92d58f1027ceb26e9f719cd5b4185576657d7fee30ec5cc8f59bbc2320ae7f6e645ef26278a03a890011aba71451ccbc16fe98c065890ad004671244f98e041899f3e0d7818f8891b57250c3a7cccaa91ee03f0fc3bcbba81e742d1e6b92ff50f746e06cd93d335443a9b3103edefe5bc1deb84fe853ca02b02c6864621dc42a6274fc9b674552e87b2b7bea8caeabb4e31838b815f6b688f48817b0d6a97b59906ef898aba40a1eca006d4e855c9d38eda7fd7276304f869f328fe5386d2bc6f42f57cd891610a6fd3dd0ccc982cc78ba6148b708d476d4fdfb9526ae3c121bc6b08667e415666605031e4fffcc8659be70cbffa0527e1594e7d552f2f77e2b104efa03bfca3fbd81db975455ae192e2d76317e38480c98eb927da1e9426ffb16b23339ce64c3ae48ba0636c1fa27541e5d764ac6fc08e0b67e45a00cd2eafe366e172872d58165ff07d42747351311e2fee65d5d8697d611646ae113e128cbbb0a639ee10db0f7a4a1fd98064ebcf3d014aa6fe03f7f657577388fdd8d9b645737fdde41e1b8a413302516ceacded0b1df3661151daf18a28e2a7429c94ae5c74f24108faef7bb3f948cfcb8e55208a9f078211b1aa236729fc083ecb8827b027d1472288c87cffe1f9c37df178dd0cf18004c64f069cc7eb7d65e91b42016acfd0cd3f279435848e30038f43d9066ba613a680312bebd71d59651a7ae68790fe37e6bba697a52d3565059e6f382a39d955287a912d28cfdd4701c285a26cbaf5197679fb538ec080ff4820952bb61793bd5e530722afb2758295a557a4bc555297de25d30301a2f1e76041ba8deb6c7db7fbba1d7a7867683e6f44f663febcb8de719bdc5bbab820e5e0e74a900f1185a170b1df2f5761f42c269e08ff322fef0501084e0a100c15c481e5d153aa900a265b1291b220befb9a0df4cb2e211401e65fb61cdca10b0809ecaab46e2993b0f050b611010d4baf14ee89b84ef8c65b184e4146ad77b5c10db3481b6ae54f72935c4bc1f501af4cd519734e97dc3e6e5ad938690fa358fb6c3d11512a1401cfb03d159768d8375ddeaa6f33e275887988be7eb64def67e57b37879f64c58437d2ea794af0a3b3e8912765676042ad1101f73789df60882d08873b5ae0a24a1c6725fc296d894c4c91c1242237e19b782b209322f16af87ee909b4174d61be5529aeb274b887a6b05a169e042ba4cb9a8bc2ee87f79a4418dc9d697519f35d4af9b8f547aea8356d79d5b7063bbd2820c12a09836bd0b164ad8e534ea1b31e2be8b2ee7c596cc8aa18278b503338e2f8ee54932f698ac13f36f143b11304d6a0a7a872e44e032180d2aeb623f7577f25b5566d6d078cbe1deee82ea29025b7cb6163e8470f14d7668f51b8fc9feebe8aca0585030643848b15bfc58768e3f5461dfaf4967f58f9de0c1e3dc7a281aeded0b6e6c78cdf5c7685980f8fd1f88f154270fa8fd9b00c74cb11e698021c76936bf2aa6cc8693d12586621d72cfbea1dfff60903decd47eda3a416563cbe9e972142ed8f53108a179d8163aea2a6c3ba9ae86fde9fa0479f44d049d7836461604ac184db49f98880f7f6b359c58db723ee556e8d56b7af1926603094595b311eaa2509fbef28c80409a08d2700752a5d286128c4834f953f6cb58ba69a7d07da8725b31a2b3ebf01b3980f22736815d586c5736f9e9a54704caa8e8885678056a89d28f8cf424f1b55ddb944285e0a738afaf8be868d48631e068ec58724c60ffc62e9ab27174829a5b44f236023186e0251fc814ae5e4991ff59c8776b1b8bc09359539f0d724557ac6f948711ab4835048e8cb585665a7beb93af4c1ed48a3c54f3ba4dbbc4c72736120ca4fe42775acd4503abc40f56e885f0073e393d4d9f94e465873d9a96169a5cc82584acc25ee458a382c432d3ed51890af005e3d494d79e9ca82faad281486fe0409742d8a196d3a9acd2e7662c320b6f0f80615318a8bf712c7b1396d575180019d759967323791f24f5d7c890ee257451da118a9199c6090f9e09548bd65bd9fa9bcacc3dd1a3ffeda6a8ae4bd14010477d5bc03d265216f27130dccb67cb74baf43ad43b5b7690a7ea83db933907b0cb82b4f69299d67e20ab42b76ca099a66b98861f259bfa18ad881d480c98afc8923215edb6bb1bf4afd164919105c3eeb75a7f27e4b291b5d9889db48f92af212fbc4d9bc2477623b9d1e72c3387299d9e5b9b43cffd5aeb7b17dbbb6dcc49fff72361c98e58b02b1920cc0c1d02cdd7fa29bdde443bcded724d691f4168510e8f89278fbd4bb9ed6cc358fe687f3217abaeacfca557d076199b88aed28899325e3e6fb1272422043ddff4e37059393e20989a530aa6f5a8b71b001561eb9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小记 </tag>
            
            <tag> 语录 </tag>
            
            <tag> 空无 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 786. 第k个数 *</title>
      <link href="/posts/13597/"/>
      <url>/posts/13597/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><blockquote><p><em><a href="https://www.cnblogs.com/littlehb/p/15222977.html">AcWing 786. 第k个数 - 糖豆爸爸 - 博客园</a></em></p></blockquote><hr><h1 id="AcWing-786-第k个数【简单】"><a href="#AcWing-786-第k个数【简单】" class="headerlink" title="AcWing 786. 第k个数【简单】*"></a><a href="https://www.acwing.com/problem/content/788/">AcWing 786. 第k个数【简单】*</a></h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。</p><p><strong>输入格式</strong><br>第一行包含两个整数 n 和 k。<br>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整数数列。</p><p><strong>输出格式</strong><br>输出一个整数，表示数列的第 k 小数。</p><p><strong>数据范围</strong><br>1≤n≤100000,<br>1≤k≤n</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 4 1 5 3</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="二、AC代码"><a href="#二、AC代码" class="headerlink" title="二、AC代码"></a>二、AC代码</h2><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/8305bb225e3aedf6f2371.jpg" alt="$fileName" width="70%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div><h3 id="version-1-0-模板"><a href="#version-1-0-模板" class="headerlink" title="version 1.0 模板"></a>version 1.0 模板</h3><p>这是我一开始写的，肯定是能过的，没想那么多，总结交了——直到我看了题解。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q[k - <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + (r- l) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="version-2-0-y总"><a href="#version-2-0-y总" class="headerlink" title="version 2.0 y总"></a>version 2.0 y总</h3><div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/02fb36cad9b6c4d3d61aa.jpg" alt="$fileName" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 85%; padding: 1px;">        y总讲解    </div></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y总</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>, k)); <span class="comment">// 这里传入的是 k</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> q[l];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + (r - l) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sl = j - l + <span class="number">1</span>;     <span class="comment">// 左侧长度</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= sl) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(q, l, j, k);     <span class="comment">// 左侧</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r, k - sl);    <span class="comment">// 右侧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="version-3-0-y总改良版"><a href="#version-3-0-y总改良版" class="headerlink" title="version 3.0 y总改良版"></a>version 3.0 y总改良版</h3><p>缩小范围的递归判断条件可以更简洁一些，直接判断下标即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tonngw</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为 int</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回的就是第 k 大的数，注意这里传入的是下标 k - 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">quick_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>, k - <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果找到了则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> q[l];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + (r - l) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第 k 大的数在左半边，则递归左半边寻找</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= j) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(l, j, k);</span><br><span class="line">    <span class="comment">// 否则递归右半边</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、错误分析"><a href="#三、错误分析" class="headerlink" title="三、错误分析"></a>三、错误分析</h2><p>暂且不表，先不深入探究，老是刨根问底太浪费时间了······</p><h3 id="1-为什么y总的main函数里传过来的是-k-而不是-k-1？"><a href="#1-为什么y总的main函数里传过来的是-k-而不是-k-1？" class="headerlink" title="1. 为什么y总的main函数里传过来的是 k 而不是 k - 1？"></a>1. 为什么y总的main函数里传过来的是 <code>k</code> 而不是 <code>k - 1</code>？</h3><div align="left" >    <img src="https://telegraph-image-box.pages.dev/file/ff86bfe3779b4a25c58f0.jpg" alt="$fileName" width="35%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 85%; padding: 1px;">        “学长”答疑    </div></div><p><code>printf(&quot;%d\n&quot;, quick_sort(q, 0, n - 1, k));</code></p><p>评论区里写法不太一样，用的是下标，所以是 <code>k - 1</code>。</p><h3 id="2-为什么评论区的写法更好？"><a href="#2-为什么评论区的写法更好？" class="headerlink" title="2. 为什么评论区的写法更好？"></a>2. 为什么评论区的写法更好？</h3><blockquote><p>tonngw：<strong>缩小范围的递归判断条件可以更简洁一些，直接判断下标即可。</strong></p></blockquote><h3 id="3-一些相关帖子"><a href="#3-一些相关帖子" class="headerlink" title="3. 一些相关帖子"></a>3. 一些相关帖子</h3><ol><li><a href="https://www.acwing.com/solution/content/220832/">AcWing 786. 保证 [l, j-1] &lt;&#x3D; pivot, [j+1, r] &gt;&#x3D; pivot, 同时[j] &#x3D;&#x3D; pivot 的解法 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/16777/">AcWing 785. 快速排序算法的证明与边界分析 - AcWing</a></li></ol><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>我：<del><em>嗯，确实是简单题，基本上跟上一道模板题一模一样。</em></del><br>好像忘了看题解······</p><p><strong>卧槽！是我头脑简单了。</strong></p><hr><blockquote><ol><li>这是快速排序模板的练习题。</li><li>不一样的地方在于它可以利用快排模板，但却不需要真的把所有数据排序完成，每次一分为二后，只关心自己所有的那一半，就是可以节约一半的递归时间。</li><li>由于是关心 <strong>位置</strong>（第几个），所以在递归时需要携带这个参数。</li><li>位置这个参数 <strong>不是一成不变的</strong>，因为如果在左侧，那么就是原来的位置，如果在右侧，那就需要减去整个左侧的长度。这个 k 参数可以理解为 <strong>在当前数组中的位置</strong>，最终将确定这个位置上的值。</li><li>最后，直接使用 <strong>q[k]</strong> 就是拿到了最终这个位置上应该存在的值。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 算法基础课 - 模板</title>
      <link href="/posts/18027/"/>
      <url>/posts/18027/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-算法基础课-模板"><a href="#AcWing-算法基础课-模板" class="headerlink" title="AcWing 算法基础课 - 模板"></a>AcWing 算法基础课 - 模板</h1><h2 id="一、基础算法"><a href="#一、基础算法" class="headerlink" title="一、基础算法"></a>一、基础算法</h2><h3 id="1-快速排序算法模板"><a href="#1-快速排序算法模板" class="headerlink" title="1. 快速排序算法模板"></a>1. 快速排序算法模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-归并排序算法模板"><a href="#2-归并排序算法模板" class="headerlink" title="2. 归并排序算法模板"></a>2. 归并排序算法模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-整数二分算法模板"><a href="#3-整数二分算法模板" class="headerlink" title="3. 整数二分算法模板"></a>3. 整数二分算法模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-浮点数二分算法模板"><a href="#4-浮点数二分算法模板" class="headerlink" title="4. 浮点数二分算法模板"></a>4. 浮点数二分算法模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-高精度加法"><a href="#5-高精度加法" class="headerlink" title="5. 高精度加法"></a>5. 高精度加法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-高精度减法"><a href="#6-高精度减法" class="headerlink" title="6. 高精度减法"></a>6. 高精度减法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-高精度乘低精度"><a href="#7-高精度乘低精度" class="headerlink" title="7. 高精度乘低精度"></a>7. 高精度乘低精度</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-高精度除以低精度"><a href="#8-高精度除以低精度" class="headerlink" title="8. 高精度除以低精度"></a>8. 高精度除以低精度</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-一维前缀和"><a href="#9-一维前缀和" class="headerlink" title="9. 一维前缀和"></a>9. 一维前缀和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="10-二维前缀和"><a href="#10-二维前缀和" class="headerlink" title="10. 二维前缀和"></a>10. 二维前缀和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">    S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="11-一维差分"><a href="#11-一维差分" class="headerlink" title="11. 一维差分"></a>11. 一维差分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给区间[l, r]中的每个数加上c： B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure><h3 id="12-二维差分"><a href="#12-二维差分" class="headerlink" title="12. 二维差分"></a>12. 二维差分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br></pre></td></tr></table></figure><h3 id="13-位运算"><a href="#13-位运算" class="headerlink" title="13. 位运算"></a>13. 位运算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">求n的第k位数： n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>： <span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure><hr><h3 id="14-双指针算法"><a href="#14-双指针算法" class="headerlink" title="14. 双指针算法"></a>14. 双指针算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><h3 id="15-离散化"><a href="#15-离散化" class="headerlink" title="15. 离散化"></a>15. 离散化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-区间合并"><a href="#16-区间合并" class="headerlink" title="16. 区间合并"></a>16. 区间合并</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>区间合并最后的 <strong>segs &#x3D; res;</strong> 改写成 <strong>swap(res, segs);</strong> 应该效率更高一些，容器交换的时间复杂度是 *O(1)*，不用再拷贝一次了。</p></blockquote><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2. 双链表"></a>2. 双链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h3><h4 id="（1）普通队列"><a href="#（1）普通队列" class="headerlink" title="（1）普通队列"></a>（1）普通队列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）循环队列"><a href="#（2）循环队列" class="headerlink" title="（2）循环队列"></a>（2）循环队列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-单调栈"><a href="#5-单调栈" class="headerlink" title="5. 单调栈"></a>5. 单调栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-单调队列"><a href="#6-单调队列" class="headerlink" title="6. 单调队列"></a>6. 单调队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-KMP"><a href="#7-KMP" class="headerlink" title="7. KMP"></a>7. KMP</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Trie树"><a href="#8-Trie树" class="headerlink" title="8. Trie树"></a>8. Trie树</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-并查集"><a href="#9-并查集" class="headerlink" title="9. 并查集"></a>9. 并查集</h3><h4 id="（1）朴素并查集"><a href="#（1）朴素并查集" class="headerlink" title="（1）朴素并查集"></a>（1）朴素并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><h4 id="（2）维护size的并查集"><a href="#（2）维护size的并查集" class="headerlink" title="（2）维护size的并查集"></a>（2）维护size的并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><h4 id="（3）维护到祖宗节点距离的并查集"><a href="#（3）维护到祖宗节点距离的并查集" class="headerlink" title="（3）维护到祖宗节点距离的并查集"></a>（3）维护到祖宗节点距离的并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">            d[x] += d[p[x]];</span><br><span class="line">            p[x] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure><h3 id="10-堆"><a href="#10-堆" class="headerlink" title="10. 堆"></a>10. 堆</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><h3 id="11-一般哈希"><a href="#11-一般哈希" class="headerlink" title="11. 一般哈希"></a>11. 一般哈希</h3><h4 id="（1）拉链法"><a href="#（1）拉链法" class="headerlink" title="（1）拉链法"></a>（1）拉链法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-开放寻址法"><a href="#2-开放寻址法" class="headerlink" title="(2) 开放寻址法"></a>(2) 开放寻址法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="12-字符串哈希"><a href="#12-字符串哈希" class="headerlink" title="12. 字符串哈希"></a>12. 字符串哈希</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-C-STL简介"><a href="#13-C-STL简介" class="headerlink" title="13. C++ STL简介"></a>13. C++ STL简介</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure><h2 id="三、搜索与图论"><a href="#三、搜索与图论" class="headerlink" title="三、搜索与图论"></a>三、搜索与图论</h2><h3 id="1-树与图的存储"><a href="#1-树与图的存储" class="headerlink" title="1. 树与图的存储"></a>1. 树与图的存储</h3><p>树是一种特殊的图，与图的存储方式相同。<br>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。<br>因此我们可以只考虑有向图的存储。</p><h4 id="1-邻接矩阵：g-a-b-存储边-a-b"><a href="#1-邻接矩阵：g-a-b-存储边-a-b" class="headerlink" title="(1) 邻接矩阵：g[a][b] 存储边 a-&gt;b"></a>(1) 邻接矩阵：<code>g[a][b]</code> 存储边 <code>a-&gt;b</code></h4><h4 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="(2) 邻接表"></a>(2) 邻接表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure><h3 id="2-树与图的遍历"><a href="#2-树与图的遍历" class="headerlink" title="2. 树与图的遍历"></a>2. 树与图的遍历</h3><p>时间复杂度 <em>O(n+m)</em>, <em>n</em> 表示点数，<em>m</em> 表示边数</p><h4 id="1-深度优先遍历-——-模板题-AcWing-846-树的重心"><a href="#1-深度优先遍历-——-模板题-AcWing-846-树的重心" class="headerlink" title="(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心"></a>(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-宽度优先遍历-——-模板题-AcWing-847-图中点的层次"><a href="#2-宽度优先遍历-——-模板题-AcWing-847-图中点的层次" class="headerlink" title="(2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次"></a>(2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-拓扑排序"><a href="#3-拓扑排序" class="headerlink" title="3. 拓扑排序"></a>3. 拓扑排序</h3><p>时间复杂度 <em>O(n+m)</em>, <em>n</em> 表示点数，<em>m</em> 表示边数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-朴素dijkstra算法"><a href="#4-朴素dijkstra算法" class="headerlink" title="4. 朴素dijkstra算法"></a>4. 朴素dijkstra算法</h3><p>时间复杂是 <em>O(n2+m)</em>, <em>n</em> 表示点数，<em>m</em> 表示边数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-堆优化版dijkstra"><a href="#5-堆优化版dijkstra" class="headerlink" title="5. 堆优化版dijkstra"></a>5. 堆优化版dijkstra</h3><p>时间复杂度 <em>O(mlogn), <em>n</em> 表示点数，</em>m* 表示边数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Bellman-Ford算法"><a href="#6-Bellman-Ford算法" class="headerlink" title="6. Bellman-Ford算法"></a>6. Bellman-Ford算法</h3><p>时间复杂度 <em>O(nm)</em>, <em>n</em> 表示点数，<em>m</em> 表示边数</p><p>注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-spfa-算法（队列优化的Bellman-Ford算法）"><a href="#7-spfa-算法（队列优化的Bellman-Ford算法）" class="headerlink" title="7. spfa 算法（队列优化的Bellman-Ford算法）"></a>7. spfa 算法（队列优化的Bellman-Ford算法）</h3><p>时间复杂度 平均情况下 <em>O(m)<em>，最坏情况下 <em>O(nm)</em>, <em>n</em> 表示点数，</em>m</em> 表示边数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-spfa判断图中是否存在负环"><a href="#8-spfa判断图中是否存在负环" class="headerlink" title="8. spfa判断图中是否存在负环"></a>8. spfa判断图中是否存在负环</h3><p>时间复杂度是 <em>O(nm)</em>, <em>n</em> 表示点数，<em>m</em> 表示边数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-floyd算法"><a href="#9-floyd算法" class="headerlink" title="9. floyd算法"></a>9. floyd算法</h3><p>时间复杂度是 <em>O(n^3)</em>, <em>n</em> 表示点数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-朴素版prim算法"><a href="#10-朴素版prim算法" class="headerlink" title="10. 朴素版prim算法"></a>10. 朴素版prim算法</h3><p>时间复杂度是 <em>O(n2+m)</em>, <em>n</em> 表示点数，<em>m</em> 表示边数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Kruskal算法"><a href="#11-Kruskal算法" class="headerlink" title="11. Kruskal算法"></a>11. Kruskal算法</h3><p>时间复杂度是 <em>O(mlogm)</em>, <em>n</em> 表示点数，<em>m</em> 表示边数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-染色法判别二分图"><a href="#12-染色法判别二分图" class="headerlink" title="12. 染色法判别二分图"></a>12. 染色法判别二分图</h3><p>时间复杂度是<em>O(n+m)</em>, <em>n</em> 表示点数，<em>m</em> 表示边数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-匈牙利算法"><a href="#13-匈牙利算法" class="headerlink" title="13. 匈牙利算法"></a>13. 匈牙利算法</h3><p>时间复杂度是 <em>O(nm)</em>, <em>n</em> 表示点数，<em>m</em> 表示边数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;。</span><br></pre></td></tr></table></figure><h2 id="四、数学知识"><a href="#四、数学知识" class="headerlink" title="四、数学知识"></a>四、数学知识</h2><h3 id="1-试除法判定质数"><a href="#1-试除法判定质数" class="headerlink" title="1. 试除法判定质数"></a>1. 试除法判定质数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-试除法分解质因数"><a href="#2-试除法分解质因数" class="headerlink" title="2. 试除法分解质因数"></a>2. 试除法分解质因数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-朴素筛法求素数"><a href="#3-朴素筛法求素数" class="headerlink" title="3. 朴素筛法求素数"></a>3. 朴素筛法求素数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线性筛法求素数"><a href="#4-线性筛法求素数" class="headerlink" title="4. 线性筛法求素数"></a>4. 线性筛法求素数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-试除法求所有约数"><a href="#5-试除法求所有约数" class="headerlink" title="5. 试除法求所有约数"></a>5. 试除法求所有约数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-约数个数和约数之和"><a href="#6-约数个数和约数之和" class="headerlink" title="6. 约数个数和约数之和"></a>6. 约数个数和约数之和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck</span><br><span class="line">约数个数： (c1 + <span class="number">1</span>) * (c2 + <span class="number">1</span>) * ... * (ck + <span class="number">1</span>)</span><br><span class="line">约数之和： (p1^<span class="number">0</span> + p1^<span class="number">1</span> + ... + p1^c1) * ... * (pk^<span class="number">0</span> + pk^<span class="number">1</span> + ... + pk^ck)</span><br></pre></td></tr></table></figure><h3 id="7-欧几里得算法"><a href="#7-欧几里得算法" class="headerlink" title="7. 欧几里得算法"></a>7. 欧几里得算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-求欧拉函数"><a href="#8-求欧拉函数" class="headerlink" title="8. 求欧拉函数"></a>8. 求欧拉函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-筛法求欧拉函数"><a href="#9-筛法求欧拉函数" class="headerlink" title="9. 筛法求欧拉函数"></a>9. 筛法求欧拉函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-快速幂"><a href="#10-快速幂" class="headerlink" title="10. 快速幂"></a>10. 快速幂</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">求 m^k mod p，时间复杂度 <span class="built_in">O</span>(logk)。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-扩展欧几里得算法"><a href="#11-扩展欧几里得算法" class="headerlink" title="11. 扩展欧几里得算法"></a>11. 扩展欧几里得算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-高斯消元"><a href="#12-高斯消元" class="headerlink" title="12. 高斯消元"></a>12. 高斯消元</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )   <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);      <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )       <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-递推法求组合数"><a href="#13-递推法求组合数" class="headerlink" title="13. 递推法求组合数"></a>13. 递推法求组合数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br></pre></td></tr></table></figure><h3 id="14-通过预处理逆元的方式求组合数"><a href="#14-通过预处理逆元的方式求组合数" class="headerlink" title="14. 通过预处理逆元的方式求组合数"></a>14. 通过预处理逆元的方式求组合数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</span></span><br><span class="line"><span class="comment">// 如果取模的数是质数，可以用费马小定理求逆元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span>    <span class="comment">// 快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-Lucas定理"><a href="#15-Lucas定理" class="headerlink" title="15. Lucas定理"></a>15. Lucas定理</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：</span></span><br><span class="line">    <span class="built_in">C</span>(n, m) = <span class="built_in">C</span>(n % p, m % p) * <span class="built_in">C</span>(n / p, m / p) (mod p)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">qmi</span>(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)  <span class="comment">// 快速幂模板</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span>  <span class="comment">// 通过定理求组合数C(a, b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LL x = <span class="number">1</span>, y = <span class="number">1</span>;  <span class="comment">// x是分子，y是分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i --, j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * i % p;</span><br><span class="line">        y = (LL) y * j % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * (LL)<span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-分解质因数法求组合数"><a href="#16-分解质因数法求组合数" class="headerlink" title="16. 分解质因数法求组合数"></a>16. 分解质因数法求组合数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</span></span><br><span class="line"><span class="comment">//     1. 筛法求出范围内的所有质数</span></span><br><span class="line"><span class="comment">//     2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...</span></span><br><span class="line"><span class="comment">//     3. 用高精度乘法将所有质因子相乘</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];     <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span>      <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span>       <span class="comment">// 求n！中的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span>       <span class="comment">// 高精度乘低精度模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(a);  <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++ )</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br></pre></td></tr></table></figure><h3 id="17-卡特兰数"><a href="#17-卡特兰数" class="headerlink" title="17. 卡特兰数"></a>17. 卡特兰数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为：</span></span><br><span class="line"><span class="built_in">Cat</span>(n) = <span class="built_in">C</span>(<span class="number">2</span>n, n) / (n + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="18-NIM游戏"><a href="#18-NIM游戏" class="headerlink" title="18. NIM游戏"></a>18. NIM游戏</h3><p>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p><p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p><p>定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An !&#x3D; 0</p><h3 id="19-公平组合游戏ICG"><a href="#19-公平组合游戏ICG" class="headerlink" title="19. 公平组合游戏ICG"></a>19. 公平组合游戏ICG</h3><p>若一个游戏满足：</p><ol><li>由两名玩家交替行动；</li><li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li><li>不能行动的玩家判负；</li></ol><p>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><h3 id="20-有向图游戏"><a href="#20-有向图游戏" class="headerlink" title="20. 有向图游戏"></a>20. 有向图游戏</h3><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p><h3 id="21-Mex运算"><a href="#21-Mex运算" class="headerlink" title="21. Mex运算"></a>21. Mex运算</h3><p>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：<br>mex(S) &#x3D; min{x}, x属于自然数，且x不属于S</p><h3 id="22-SG函数"><a href="#22-SG函数" class="headerlink" title="22. SG函数"></a>22. SG函数</h3><p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：<br>SG(x) &#x3D; mex({SG(y1), SG(y2), …, SG(yk)})<br>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) &#x3D; SG(s)。</p><h3 id="23-有向图游戏的和-——-模板题-AcWing-893-集合-Nim游戏"><a href="#23-有向图游戏的和-——-模板题-AcWing-893-集合-Nim游戏" class="headerlink" title="23. 有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏"></a>23. 有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏</h3><p>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：<br>SG(G) &#x3D; SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</p><h3 id="24-定理"><a href="#24-定理" class="headerlink" title="24. 定理"></a>24. 定理</h3><p>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 785. 快速排序</title>
      <link href="/posts/50685/"/>
      <url>/posts/50685/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p><strong>琢磨太深，使人痛苦！！！</strong><br><strong>琢磨太深，使人痛苦！！！</strong><br><strong>琢磨太深，使人痛苦！！！</strong></p><blockquote><p><strong>推荐阅读：</strong></p><ul><li><em><a href="https://www.acwing.com/solution/content/16777/">AcWing 785. 快速排序算法的证明与边界分析 - AcWing</a></em></li><li><em><a href="https://www.acwing.com/solution/content/2089/">AcWing 785. 快速排序算法、时间复杂度、代码</a></em></li><li><em><a href="https://www.cnblogs.com/littlehb/p/15000855.html">AcWing 785. 快速排序 - 糖豆爸爸 - 博客园</a></em></li><li><em><a href="https://blog.csdn.net/qq_36533552/article/details/106328719">快速排序最好、最坏以及平均复杂度推导理解 - CSDN</a></em></li></ul></blockquote><hr><h1 id="785-快速排序-AcWing【简单】"><a href="#785-快速排序-AcWing【简单】" class="headerlink" title="785. 快速排序 - AcWing【简单】"></a><a href="https://www.acwing.com/problem/content/description/787/">785. 快速排序 - AcWing【简单】</a></h1><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定你一个长度为 n 的整数数列。<br>请你使用快速排序对这个数列按照从小到大进行排序。<br>并将排好序的数列按顺序输出。</p><p><strong>输入格式</strong><br>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。</p><p><strong>输出格式</strong><br>输出共一行，包含 n 个整数，表示排好序的数列。</p><p><strong>数据范围：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1≤n≤100000</span><br></pre></td></tr></table></figure><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h2 id="二、AC代码"><a href="#二、AC代码" class="headerlink" title="二、AC代码"></a>二、AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// q[l]时间超限、q[r]内存超限、q[(l + r) / 2]通过</span></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、错误分析"><a href="#三、错误分析" class="headerlink" title="三、错误分析"></a>三、错误分析</h2><h3 id="基准位置的选择问题"><a href="#基准位置的选择问题" class="headerlink" title="基准位置的选择问题"></a>基准位置的选择问题</h3><p>视频里y总用的是 <code>q[l]</code>，过了——但是网站里的模板是 <code>q[l + r &gt;&gt; 1]</code></p><blockquote><ol><li><p>尝试 <code>q[l]</code>：<strong>Time Limit Exceeded</strong></p></li><li><p>尝试 <code>q[r]</code>：<strong>Memory Limit Exceeded</strong></p></li><li><p>尝试 <code>q[l + r &gt;&gt; 1]</code>、<code>q[l + (r - l) &gt;&gt; 1]</code> 和 <code>q[(l + r) / 2]</code> 、<code>q[l + (r - l) / 2]</code>：<strong>Accepted</strong></p></li></ol></blockquote><p>但其实 <code>q[(l + r) / 2]</code> 和 <code>q[l + r &gt;&gt; 1]</code> 都是不对的：</p><ol><li><p>溢出问题<br><code>q[(l + r) / 2]</code> 和 <code>q[l + r &gt;&gt; 1]</code> 中尽管除了2，但是 <code>l + r</code> 是可能溢出的，会超出 int 的整数范围</p></li><li><p>运算符优先级、规范问题<br>在 <code>q[l + r &gt;&gt; 1]</code> 中这个写法是不规范的，虽然 <code>&gt;&gt;</code> 优先级比较低，但是编译器会提示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[警告] suggest parentheses around <span class="string">&#x27;+&#x27;</span> inside <span class="string">&#x27;&gt;&gt;&#x27;</span> [-Wparentheses]</span><br></pre></td></tr></table></figure><p>这个警告的意思是编译器建议在 (r - l) &#x2F; 2 这个表达式中的 + 周围加上括号，以明确运算的顺序。这是由于 C++ 中运算符的优先级，+ 的优先级高于右移运算符 &gt;&gt;，因此在不加括号的情况下，编译器会先执行加法，然后再进行右移操作。<br>虽然在这种情况下不加括号也是合法的，但为了代码的清晰度和防止可能的误解，编译器给出了这个警告。<br>所以，加上 ()比较好。</p></li></ol><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="1-基准位置的写法"><a href="#1-基准位置的写法" class="headerlink" title="1. 基准位置的写法"></a>1. 基准位置的写法</h3><p><code>q[(l + (r - l)) &gt;&gt; 1]</code> ：使用位运算右移 &gt;&gt;，在很多情况下性能相对较好，因为位运算通常比除法运算更快。<br><code>q[l + (r - l) / 2]</code>：使用除法运算 &#x2F;，更直观，可读性更好，而且在大多数现代编译器和处理器上，性能差异可能不太明显。</p><p>所以我还是喜欢：<code>l + (r - l) / 2</code>。</p><h3 id="2-基准位置选择中间位置的原因"><a href="#2-基准位置选择中间位置的原因" class="headerlink" title="2. 基准位置选择中间位置的原因"></a>2. 基准位置选择中间位置的原因</h3><p>选择数组的中间位置作为快速排序的基准元素是一种常见的做法，这是因为在很多情况下它能够提高快速排序的性能。这是基于以下考虑：</p><ol><li><strong>均匀分割</strong>： 选择中间位置的元素可以使数组在每一轮分割中相对均匀地被划分成两部分。这有助于确保在每次分割中，基准元素两侧的元素数量相对平衡。</li><li><strong>减少最坏情况发生的概率</strong>： 在选择中间位置的元素作为基准的情况下，快速排序在平均情况下的性能较好。虽然快速排序的平均时间复杂度为 O(nlogn)，但在最坏情况下，它可能达到 O(n^2)。通过选择中间位置，有助于减少最坏情况发生的概率。</li><li><strong>避免有序性对性能的影响</strong>： 如果选择第一个或最后一个元素作为基准，而数组已经有序，那么在每一轮分割中都可能导致不均匀的划分，性能下降。选择中间位置的元素能够在某种程度上避免这种情况。<br>总的来说，选择中间位置的元素是一种在大多数情况下表现良好的策略，有助于提高快速排序的效率。然而，在某些特殊情况下，也有其他选择基准的方法，这取决于具体的实现和问题要求。</li></ol><h3 id="3-快速排序算法的证明与边界分析-【了解】"><a href="#3-快速排序算法的证明与边界分析-【了解】" class="headerlink" title="3. 快速排序算法的证明与边界分析 【了解】"></a>3. 快速排序算法的证明与边界分析 【了解】</h3><p><img src="https://telegraph-image-box.pages.dev/file/51b85118c2f09cade4506.png" alt="1"></p><p><strong>琢磨太深，使人痛苦！！！</strong><br><strong>琢磨太深，使人痛苦！！！</strong><br><strong>琢磨太深，使人痛苦！！！</strong></p><hr><p>顺带一提用 i 做划分时的模板</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = q[(l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>]; <span class="comment">// 非得要用i这里要修改！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, i - <span class="number">1</span>), <span class="built_in">quick_sort</span>(q, i, r); <span class="comment">// 非得要用i这里要修改！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安知鱼主题标签 Tag Plugins</title>
      <link href="/posts/39262/"/>
      <url>/posts/39262/</url>
      
        <content type="html"><![CDATA[<div class="note blue anzhiyufont anzhiyu-icon-bullhorn simple"><p><code>AnZhiYu主题</code>中大部分标签移植于<a href="https://akilar.top/">店长</a>的<a href="https://www.npmjs.com/package/hexo-butterfly-tag-plugins-plus">hexo-butterfly-tag-plugins-plus</a>，转载请注明来自<a href="https://blog.anheyu.com/posts/d50a.html">安知鱼</a></p></div><h2 id="段落文本-p"><a href="#段落文本-p" class="headerlink" title="段落文本 p"></a>段落文本 p</h2><div class="tabs" id="p"><ul class="nav-tabs"><button type="button" class="tab " data-href="p-1">标签语法</button><button type="button" class="tab " data-href="p-2">配置参数</button><button type="button" class="tab  active" data-href="p-3">样式预览</button><button type="button" class="tab " data-href="p-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="p-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="p-2"><ol><li>字体: logo, code</li><li>颜色: <span class='p red'>red</span>,<span class='p yellow'>yellow</span>,<span class='p green'>green</span>,<span class='p cyan'>cyan</span>,<span class='p blue'>blue</span>,<span class='p gray'>gray</span></li><li>大小: small, h4, h3, h2, h1, large, huge, ultra</li><li>对齐方向: left, center, right</li></ol></div><div class="tab-item-content active" id="p-3"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p></li></ul></div><div class="tab-item-content" id="p-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">  在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">  文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">  &#123;% p center logo large, Volantis %&#125;</span><br><span class="line">  &#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="行内文本-span"><a href="#行内文本-span" class="headerlink" title="行内文本 span"></a>行内文本 span</h2><div class="tabs" id="span"><ul class="nav-tabs"><button type="button" class="tab " data-href="span-1">标签语法</button><button type="button" class="tab " data-href="span-2">配置参数</button><button type="button" class="tab  active" data-href="span-3">样式预览</button><button type="button" class="tab " data-href="span-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="span-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="span-2"><ol><li>字体: logo, code</li><li>颜色: <span class='p red'>red</span>,<span class='p yellow'>yellow</span>,<span class='p green'>green</span>,<span class='p cyan'>cyan</span>,<span class='p blue'>blue</span>,<span class='p gray'>gray</span></li><li>大小: small, h4, h3, h2, h1, large, huge, ultra</li><li>对齐方向: left, center, right</li></ol></div><div class="tab-item-content active" id="span-3"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul></div><div class="tab-item-content" id="span-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">  在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">  文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">  &#123;% span center logo large, Volantis %&#125;</span><br><span class="line">  &#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="行内文本样式-text"><a href="#行内文本样式-text" class="headerlink" title="行内文本样式 text"></a>行内文本样式 text</h2><div class="tabs" id="text"><ul class="nav-tabs"><button type="button" class="tab " data-href="text-1">标签语法</button><button type="button" class="tab  active" data-href="text-2">样式预览</button><button type="button" class="tab " data-href="text-3">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="text-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content active" id="text-2"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol></div><div class="tab-item-content" id="text-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="分栏-tab"><a href="#分栏-tab" class="headerlink" title="分栏 tab"></a>分栏 tab</h2><div class="note blue anzhiyufont anzhiyu-icon-bullhorn simple"><p>分栏支持内置阿里图标，如果开启了 <code>fontawesome</code>可以使用 fontawesome 的图标，否则只能使用默内置阿里图标</p></div><div class="tabs" id="folding"><ul class="nav-tabs"><button type="button" class="tab " data-href="folding-1">标签语法</button><button type="button" class="tab " data-href="folding-2">配置参数</button><button type="button" class="tab  active" data-href="folding-3">样式预览</button><button type="button" class="tab " data-href="folding-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="folding-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line"></span><br><span class="line">Any content (support inline tags too).</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="folding-2"><ol><li>Unique name :<ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id 中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子&#x2F;页面的 URL 必须是唯一的！</li></ul></li><li>[index]:<ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果 index 为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li>[Tab caption]:<ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li>[@icon]: - FontAwesome 图标名称（全名，看起来像“ fas fa-font”） - 可以指定带空格或不带空格； - 例如’Tab caption @icon’ 和 ‘Tab caption@icon’. - 可选参数。</li></ol></div><div class="tab-item-content active" id="folding-3"><div class="note primary flat"><p>Demo 1 - 预设选择第一个【默认】</p></div><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="note primary flat"><p>Demo 2 - 预设选择 tabs</p></div><div class="tabs" id="test2"><ul class="nav-tabs"><button type="button" class="tab " data-href="test2-1">test2 1</button><button type="button" class="tab " data-href="test2-2">test2 2</button><button type="button" class="tab  active" data-href="test2-3">test2 3</button></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="note primary flat"><p>Demo 3 - 没有预设值</p></div><div class="tabs" id="test3"><ul class="nav-tabs no-default"><button type="button" class="tab " data-href="test3-1">test3 1</button><button type="button" class="tab " data-href="test3-2">test3 2</button><button type="button" class="tab " data-href="test3-3">test3 3</button></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="note primary flat"><p>Demo 4 - 自定义 Tab 名 + 只有 icon + icon 和 Tab 名</p></div><div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">第一个Tab</button><button type="button" class="tab " data-href="test4-2"><i class="anzhiyufont anzhiyu-icon-oranges" style="text-align: center;"></i></button><button type="button" class="tab " data-href="test4-3"><i class="anzhiyufont anzhiyu-icon-oranges"></i>炸弹</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab 名字为第一个 Tab</strong></p></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有 Tab 名字</strong></p></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></div><div class="tab-item-content" id="folding-4"><div class="note primary flat"><p>Demo 1 - 预设选择第一个【默认】</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>Demo 2 - 预设选择 tabs</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>Demo 3 - 没有预设值</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>Demo 4 - 自定义 Tab 名 + 只有 icon + icon 和 Tab 名</p></div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**tab 名字为第一个 Tab**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**只有图标 没有 Tab 名字**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="按钮-btns"><a href="#按钮-btns" class="headerlink" title="按钮 btns"></a>按钮 btns</h2><div class="tabs" id="btns"><ul class="nav-tabs"><button type="button" class="tab " data-href="btns-1">标签语法</button><button type="button" class="tab " data-href="btns-2">参数配置</button><button type="button" class="tab  active" data-href="btns-3">样式预览</button><button type="button" class="tab " data-href="btns-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="btns-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="btns-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;标题&lt;/b&gt; </code>和<code> &lt;p&gt;描述文字&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">wide</td><td align="left">宽一点的按钮</td></tr><tr><td align="left">fill</td><td align="left">填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td align="left">center</td><td align="left">居中，按钮之间是固定间距</td></tr><tr><td align="left">around</td><td align="left">居中分散</td></tr><tr><td align="left">grid2</td><td align="left">等宽最多 2 列，屏幕变窄会适当减少列数</td></tr><tr><td align="left">grid3</td><td align="left">等宽最多 3 列，屏幕变窄会适当减少列数</td></tr><tr><td align="left">grid4</td><td align="left">等宽最多 4 列，屏幕变窄会适当减少列数</td></tr><tr><td align="left">grid5</td><td align="left">等宽最多 5 列，屏幕变窄会适当减少列数</td></tr></tbody></table></div><div class="tab-item-content active" id="btns-3"><ol><li>如果需要显示类似「团队成员」之类的一组含有头像的链接：</li></ol><div class="btns circle grid5">            <a class="button no-text-decoration" href='https://xaoxuu.com' title='xaoxuu'><img src='https://bu.dusays.com/2023/06/01/64787e6a5816d.png'>xaoxuu</a><a class="button no-text-decoration" href='https://xaoxuu.com' title='xaoxuu'><img src='https://bu.dusays.com/2023/06/01/64787e6a5816d.png'>xaoxuu</a><a class="button no-text-decoration" href='https://xaoxuu.com' title='xaoxuu'><img src='https://bu.dusays.com/2023/06/01/64787e6a5816d.png'>xaoxuu</a><a class="button no-text-decoration" href='https://xaoxuu.com' title='xaoxuu'><img src='https://bu.dusays.com/2023/06/01/64787e6a5816d.png'>xaoxuu</a><a class="button no-text-decoration" href='https://xaoxuu.com' title='xaoxuu'><img src='https://bu.dusays.com/2023/06/01/64787e6a5816d.png'>xaoxuu</a>          </div><ol start="2"><li>或者含有图标的按钮：</li></ol><div class="btns rounded grid5">            <a class="button no-text-decoration" href='/' title='下载源码'><i class='anzhiyufont anzhiyu-icon-bolt'></i>下载源码</a><a class="button no-text-decoration" href='/' title='查看文档'><i class='anzhiyufont anzhiyu-icon-book'></i>查看文档</a>          </div><ol start="3"><li>圆形图标 + 标题 + 描述 + 图片 + 网格 5 列 + 居中</li></ol><div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1' class="no-text-decoration"><i class='anzhiyufont anzhiyu-icon-heartbeat'></i><b>心率管家</b><p class='p red'>专业版</p><img src='https://cdn1.tianli0.top/gh/xaoxuu/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1' class="no-text-decoration"><i class='anzhiyufont anzhiyu-icon-heartbeat'></i><b>心率管家</b><p class='p green'>免费版</p><img src='https://cdn1.tianli0.top/gh/xaoxuu/cdn-assets/qrcode/heartmate_lite.png'></a>          </div></div><div class="tab-item-content" id="btns-4"><ol><li>如果需要显示类似「团队成员」之类的一组含有头像的链接：</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://bu.dusays.com/2023/06/01/64787e6a5816d.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://bu.dusays.com/2023/06/01/64787e6a5816d.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://bu.dusays.com/2023/06/01/64787e6a5816d.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://bu.dusays.com/2023/06/01/64787e6a5816d.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://bu.dusays.com/2023/06/01/64787e6a5816d.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>或者含有图标的按钮：</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, anzhiyufont anzhiyu-icon-bolt %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, anzhiyufont anzhiyu-icon-book %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>圆形图标 + 标题 + 描述 + 图片 + 网格 5 列 + 居中</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;no-text-decoration&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;anzhiyufont anzhiyu-icon-heartbeat&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">&#123;% p red, 专业版 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://bu.dusays.com/2023/06/01/64787e2a1347c.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;no-text-decoration&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;anzhiyufont anzhiyu-icon-heartbeat&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">&#123;% p green, 免费版 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://bu.dusays.com/2023/06/01/64787e515e261.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="按钮-btn"><a href="#按钮-btn" class="headerlink" title="按钮 btn"></a>按钮 btn</h2><div class="tabs" id="btn"><ul class="nav-tabs"><button type="button" class="tab " data-href="btn-1">标签语法</button><button type="button" class="tab " data-href="btn-2">参数配置</button><button type="button" class="tab  active" data-href="btn-3">样式预览</button><button type="button" class="tab " data-href="btn-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="btn-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;</span><br><span class="line"></span><br><span class="line">[url] : 链接</span><br><span class="line">[text] : 按钮文字</span><br><span class="line">[icon] : [可选] 图标</span><br><span class="line">[color] : [可选] 按钮背景顔色(默认 style 时）</span><br><span class="line">按钮字体和边框顔色(outline 时)</span><br><span class="line">default/blue/pink/red/purple/orange/green</span><br><span class="line">[style] : [可选] 按钮样式 默认实心</span><br><span class="line">outline/留空</span><br><span class="line">[layout] : [可选] 按钮佈局 默认为 line</span><br><span class="line">block/留空</span><br><span class="line">[position] : [可选] 按钮位置 前提是设置了 layout 为 block 默认为左边</span><br><span class="line">center/right/留空</span><br><span class="line">[size] : [可选] 按钮大小</span><br><span class="line">larger/留空</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="btn-2"><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">链接</td></tr><tr><td align="left">text</td><td align="left">按钮文字</td></tr><tr><td align="left">icon</td><td align="left">[可选] 图标，如果开启了 <code>fontawesome</code>可以使用 fontawesome 的图标，否则只能使用默内置图标</td></tr><tr><td align="left">color</td><td align="left">[可选] 按钮背景顔色(默认 style 时）按钮字体和边框顔色(outline 时)default&#x2F;blue&#x2F;pink&#x2F;red&#x2F;purple&#x2F;orange&#x2F;green</td></tr><tr><td align="left">style</td><td align="left">[可选] 按钮样式 默认实心数，outline&#x2F;留空</td></tr><tr><td align="left">layout</td><td align="left">[可选] 按钮佈局 默认为 line block&#x2F;留空</td></tr><tr><td align="left">position</td><td align="left">[可选] 按钮位置 前提是设置了 layout 为 block 默认为左边 center&#x2F;right&#x2F;留空数</td></tr><tr><td align="left">size</td><td align="left">[可选] 按钮大小 larger&#x2F;留空</td></tr></tbody></table></div><div class="tab-item-content active" id="btn-3"><ol><li>一组按钮</li></ol><p>This is my website, click the button <a class="btn-anzhiyu " href="https://anheyu.com/"   title="AnZhiYu"><span>AnZhiYu</span></a><br>This is my website, click the button <a class="btn-anzhiyu " href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><br>This is my website, click the button <a class="btn-anzhiyu outline" href="https://anheyu.com/"   title="AnZhiYu"><span>AnZhiYu</span></a><br>This is my website, click the button <a class="btn-anzhiyu outline" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><br>This is my website, click the button <a class="btn-anzhiyu larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a></p><ol start="2"><li>调整位置&#x2F;大小</li></ol><p><a class="btn-anzhiyu block" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><br><a class="btn-anzhiyu block center larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><br><a class="btn-anzhiyu block right outline larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a></p><ol start="3"><li>more than one button in center</li></ol><span><a class="btn-anzhiyu larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu blue larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu pink larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu red larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu purple larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu orange larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu green larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a></span><ol start="4"><li>居中按钮</li></ol><div class="btn-center"><a class="btn-anzhiyu outline larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu outline blue larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu outline pink larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu outline red larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu outline purple larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu outline orange larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a><a class="btn-anzhiyu outline green larger" href="https://anheyu.com/"   title="AnZhiYu"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>AnZhiYu</span></a></div></div><div class="tab-item-content" id="btn-4"><ol><li>一组按钮</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is my website, click the button &#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,,outline %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,outline %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,larger %&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调整位置&#x2F;大小</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,block %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,block center larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,block right outline larger %&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>more than one button in center</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,blue larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,pink larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,red larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,purple larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,green larger %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>居中按钮</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-center&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,outline larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,outline blue larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,outline pink larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,outline red larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,outline purple larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,outline orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://anheyu.com/&#x27;,AnZhiYu,anzhiyufont anzhiyu-icon-circle-arrow-right,outline green larger %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="网站卡片-sites"><a href="#网站卡片-sites" class="headerlink" title="网站卡片 sites"></a>网站卡片 sites</h2><div class="tabs" id="site"><ul class="nav-tabs"><button type="button" class="tab " data-href="site-1">标签语法</button><button type="button" class="tab  active" data-href="site-2">样式预览</button><button type="button" class="tab " data-href="site-3">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="site-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content active" id="site-2"><div class="site-card-group"><a class="site-card" href="https://xaoxuu.com" data-title=简约风格><div class="wrapper cover"><img class="cover fadeIn" src="https://bu.dusays.com/2023/06/01/6478965ce6557.webp"/></div><div class="info"><img class="flink-avatar" src="https://cdn1.tianli0.top/gh/xaoxuu/cdn-assets/avatar/avatar.png"/><span class="site-title">xaoxuu</span></div></a><a class="site-card" href="https://colsrch.top" data-title=这是一段关于这个网站的描述文字><div class="wrapper cover"><img class="cover fadeIn" src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img class="flink-avatar" src="https://cdn1.tianli0.top/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="site-title">Colsrch</span></div></a><a class="site-card" href="https://linhk1606.github.io" data-title=这是一段关于这个网站的描述文字><div class="wrapper cover"><img class="cover fadeIn" src="https://bu.dusays.com/2023/06/01/6478963584621.png"/></div><div class="info"><img class="flink-avatar" src="https://bu.dusays.com/2023/06/01/6478968743368.png"/><span class="site-title">Linhk1606</span></div></a></div></div><div class="tab-item-content" id="site-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://bu.dusays.com/2023/06/01/6478965ce6557.webp, avatar=https://cdn1.tianli0.top/gh/xaoxuu/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn1.tianli0.top/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://bu.dusays.com/2023/06/01/6478963584621.png, avatar=https://bu.dusays.com/2023/06/01/6478968743368.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="单张图片-image"><a href="#单张图片-image" class="headerlink" title="单张图片 image"></a>单张图片 image</h2><div class="tabs" id="image"><ul class="nav-tabs"><button type="button" class="tab " data-href="image-1">标签语法</button><button type="button" class="tab " data-href="image-2">参数配置</button><button type="button" class="tab  active" data-href="image-3">样式预览</button><button type="button" class="tab " data-href="image-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="image-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="image-2"><ol><li>图片宽度高度：width&#x3D;300px, height&#x3D;32px</li><li>图片描述：alt&#x3D;图片描述（butterfly 需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg&#x3D;#f2f2f2</li></ol></div><div class="tab-item-content active" id="image-3"><ol start="4"><li>添加描述：</li></ol><div class="img-wrap"><div class="img-bg"><img class="img" src="https://bu.dusays.com/2023/06/01/6478937d7de6f.webp" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div><ol start="2"><li>指定宽度：</li></ol><div class="img-wrap"><div class="img-bg"><img class="img" src="https://bu.dusays.com/2023/06/01/6478937d7de6f.webp" style="width:400px;"/></div></div><ol start="3"><li>指定宽度并添加描述：</li></ol><div class="img-wrap"><div class="img-bg"><img class="img" src="https://bu.dusays.com/2023/06/01/6478937d7de6f.webp" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div><ol start="4"><li>设置占位背景色：</li></ol><div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://bu.dusays.com/2023/06/01/6478937d7de6f.webp" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div></div><div class="tab-item-content" id="image-4"><ol><li>添加描述：</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% image https://bu.dusays.com/2023/06/01/6478937d7de6f.webp, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>指定宽度：</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% image https://bu.dusays.com/2023/06/01/6478937d7de6f.webp, width=400px %&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>指定宽度并添加描述：</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% image https://bu.dusays.com/2023/06/01/6478937d7de6f.webp, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>设置占位背景色：</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% image https://bu.dusays.com/2023/06/01/6478937d7de6f.webp, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="inlineImg-行内图片"><a href="#inlineImg-行内图片" class="headerlink" title="inlineImg 行内图片"></a>inlineImg 行内图片</h2><div class="tabs" id="inlineimg"><ul class="nav-tabs"><button type="button" class="tab " data-href="inlineimg-1">标签语法</button><button type="button" class="tab " data-href="inlineimg-2">参数配置</button><button type="button" class="tab  active" data-href="inlineimg-3">样式预览</button><button type="button" class="tab " data-href="inlineimg-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="inlineimg-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% inlineImg [src] [height] %&#125;</span><br><span class="line"></span><br><span class="line">[src] : 图片链接</span><br><span class="line">[height] ： 图片高度限制【可选】</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="inlineimg-2"><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">src</td><td align="left">图片链接</td></tr><tr><td align="left">height</td><td align="left">图片高度限制【可选】</td></tr></tbody></table></div><div class="tab-item-content active" id="inlineimg-3"><p>你看我长得漂亮不</p><p><img src="https://bu.dusays.com/2023/06/01/64787ded2ca1c.webp"></p><p>我觉得很漂亮 <img class="inline-img" src="https://bu.dusays.com/2023/06/01/64787da5251b3.png" style="height:150px"/></p></div><div class="tab-item-content" id="inlineimg-4"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你看我长得漂亮不</span><br><span class="line"></span><br><span class="line">![](https://i.loli.net/2021/03/19/2P6ivUGsdaEXSFI.png)</span><br><span class="line"></span><br><span class="line">我觉得很漂亮 &#123;% inlineImg https://i.loli.net/2021/03/19/5M4jUB3ynq7ePgw.png 150px %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="行内图片-inlineimage"><a href="#行内图片-inlineimage" class="headerlink" title="行内图片 inlineimage"></a>行内图片 inlineimage</h2><div class="tabs" id="inlineimage"><ul class="nav-tabs"><button type="button" class="tab " data-href="inlineimage-1">标签语法</button><button type="button" class="tab " data-href="inlineimage-2">参数配置</button><button type="button" class="tab  active" data-href="inlineimage-3">样式预览</button><button type="button" class="tab " data-href="inlineimage-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="inlineimage-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="inlineimage-2"><ol><li>高度：height&#x3D;20px</li></ol></div><div class="tab-item-content active" id="inlineimage-3"><p>这是 <img no-lazy class="inline" src="https://bu.dusays.com/2023/06/01/647895232e5d5.webp" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://bu.dusays.com/2022/05/19/6285328a83ca7.gif" style="height:40px;"/> 一段话。</p></div><div class="tab-item-content" id="inlineimage-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://bu.dusays.com/2023/06/01/647895232e5d5.webp %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://bu.dusays.com/2022/05/19/6285328a83ca7.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="label-标签"><a href="#label-标签" class="headerlink" title="label 标签"></a>label 标签</h2><div class="tabs" id="label"><ul class="nav-tabs"><button type="button" class="tab " data-href="label-1">标签语法</button><button type="button" class="tab " data-href="label-2">参数配置</button><button type="button" class="tab  active" data-href="label-3">样式预览</button><button type="button" class="tab " data-href="label-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="label-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="label-2"><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">文字</td></tr><tr><td align="left">color</td><td align="left">【可选】背景颜色，默认为 default，default&#x2F;blue&#x2F;pink&#x2F;red&#x2F;purple&#x2F;orange&#x2F;green</td></tr></tbody></table></div><div class="tab-item-content active" id="label-3"><p>臣亮言：<mark class="hl-label default">先帝</mark> 创业未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此诚<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈于内；<mark class="hl-label purple">忠志之士</mark> ，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中、府中，俱为一体；陟罚臧否，不宜异同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</p></div><div class="tab-item-content" id="label-4"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">臣亮言：&#123;% label 先帝 %&#125;创业未半，而&#123;% label 中道崩殂 blue %&#125;。今天下三分，&#123;% label 益州疲敝 pink %&#125;，此诚&#123;% label 危急存亡之秋 red %&#125;也！然侍衞之臣，不懈于内；&#123;% label 忠志之士 purple %&#125;，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">宫中、府中，俱为一体；陟罚臧否，不宜异同。若有&#123;% label 作奸 orange %&#125;、&#123;% label 犯科 green %&#125;，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="timeline"><a href="#timeline" class="headerlink" title="timeline"></a>timeline</h2><div class="tabs" id="timeline"><ul class="nav-tabs"><button type="button" class="tab " data-href="timeline-1">标签语法</button><button type="button" class="tab " data-href="timeline-2">参数配置</button><button type="button" class="tab  active" data-href="timeline-3">样式预览</button><button type="button" class="tab " data-href="timeline-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="timeline-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% timeline title,color %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline title --&gt;</span><br><span class="line"></span><br><span class="line">xxxxx</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline title --&gt;</span><br><span class="line"></span><br><span class="line">xxxxx</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="timeline-2"><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">标题&#x2F;时间线</td></tr><tr><td align="left">color</td><td align="left">timeline 颜色，default(留空) &#x2F; blue &#x2F; pink &#x2F; red &#x2F; purple &#x2F; orange &#x2F; green</td></tr></tbody></table></div><div class="tab-item-content active" id="timeline-3"><ol><li><p>默认颜色</p><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div></li><li><p>blue</p><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div></li><li><p>pink</p><div class="timeline pink"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div></li><li><p>red</p><div class="timeline red"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div></li><li><p>purple</p><div class="timeline purple"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div></li><li><p>orange</p><div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div></li><li><p>green</p><div class="timeline green"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div></li></ol></div><div class="tab-item-content" id="timeline-4"><ol><li>默认颜色</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline 2022 %&#125;</span><br><span class="line">&lt;!-- timeline 01-02 --&gt;</span><br><span class="line"></span><br><span class="line">这是测试页面</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>blue</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline 2022,blue %&#125;</span><br><span class="line">&lt;!-- timeline 01-02 --&gt;</span><br><span class="line"></span><br><span class="line">这是测试页面</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>pink</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline 2022,pink %&#125;</span><br><span class="line">&lt;!-- timeline 01-02 --&gt;</span><br><span class="line"></span><br><span class="line">这是测试页面</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>red</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline 2022,red %&#125;</span><br><span class="line">&lt;!-- timeline 01-02 --&gt;</span><br><span class="line"></span><br><span class="line">这是测试页面</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>purple</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline 2022,purple %&#125;</span><br><span class="line">&lt;!-- timeline 01-02 --&gt;</span><br><span class="line"></span><br><span class="line">这是测试页面</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>orange</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline 2022,orange %&#125;</span><br><span class="line">&lt;!-- timeline 01-02 --&gt;</span><br><span class="line"></span><br><span class="line">这是测试页面</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>green</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% timeline 2022,green %&#125;</span><br><span class="line">&lt;!-- timeline 01-02 --&gt;</span><br><span class="line"></span><br><span class="line">这是测试页面</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="flink-友链标签"><a href="#flink-友链标签" class="headerlink" title="flink 友链标签"></a>flink 友链标签</h2><div class="note blue anzhiyufont anzhiyu-icon-bullhorn simple"><p>可在任何界面插入类似<code>友情链接</code>列表效果，内容格式与友情链接界面一样，支持 <code>yml 格式</code>,注意<code>yml数据</code>具有格式要求，请注意格式对齐，防止被编辑器格式化导致格式错误从而报错。</p></div><div class="tabs" id="btn"><ul class="nav-tabs"><button type="button" class="tab " data-href="btn-1">标签语法</button><button type="button" class="tab " data-href="btn-2">参数配置</button><button type="button" class="tab  active" data-href="btn-3">样式预览</button><button type="button" class="tab " data-href="btn-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="btn-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% flink %&#125;</span><br><span class="line">xxxxxx</span><br><span class="line">&#123;% endflink %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="btn-2"><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">class_name</td><td align="left">h2标题</td></tr><tr><td align="left">flink_style</td><td align="left">【可选】友链样式，默认为 flexcard，flexcard&#x2F;anzhiyu</td></tr><tr><td align="left">link_list</td><td align="left">【可选】友链样式，默认为 flexcard，flexcard&#x2F;anzhiyu</td></tr></tbody></table></div><div class="tab-item-content active" id="btn-3"><div class="flink"><div class="flink-name">推荐博客</div> <div class="flink-list"><div class="flexcard-flink-list">              <a href="https://anheyu.com/" title="安知鱼" target="_blank" class="flink-list-card cf-friends-link">                <div class="wrapper cover">                    <img class="no-lightbox cover fadeIn" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/anheyu.com.jpg" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="安知鱼" />                </div>                <div class="info">                  <img class="no-lightbox cf-friends-avatar flink-avatar" src="https://img02.anheyu.com/adminuploads/1/2022/09/15/63232b7d91d22.jpg" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="安知鱼"/>                  <span class="flink-sitename cf-friends-name">安知鱼</span>                </div>              </a></div></div><div class="flink-name">网站</div><div class="flink-desc">值得推荐的网站</div> <div class="flink-list"><div class="anzhiyu-flink-list">            <div class="flink-list-item">              <a href="https://www.youtube.com/" title="Youtube" class="cf-friends-link" target="_blank">                <div class="flink-item-icon">                  <img class="no-lightbox cf-friends-avatar" src="https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Youtube" />                </div>                <div class="flink-item-info">                  <div class="flink-item-name">Youtube</div>                  <div class="flink-item-desc" title="视频网站">视频网站</div>                </div>              </a>            </div>            <div class="flink-list-item">              <a href="https://www.weibo.com/" title="Weibo" class="cf-friends-link" target="_blank">                <div class="flink-item-icon">                  <img class="no-lightbox cf-friends-avatar" src="https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Weibo" />                </div>                <div class="flink-item-info">                  <div class="flink-item-name">Weibo</div>                  <div class="flink-item-desc" title="中国最大社交分享平台">中国最大社交分享平台</div>                </div>              </a>            </div>            <div class="flink-list-item">              <a href="https://twitter.com/" title="Twitter" class="cf-friends-link" target="_blank">                <div class="flink-item-icon">                  <img class="no-lightbox cf-friends-avatar" src="https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Twitter" />                </div>                <div class="flink-item-info">                  <div class="flink-item-name">Twitter</div>                  <div class="flink-item-desc" title="社交分享平台">社交分享平台</div>                </div>              </a>            </div></div></div></div></div><div class="tab-item-content" id="btn-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% flink %&#125;</span><br><span class="line"><span class="bullet">-</span> class<span class="emphasis">_name: 推荐博客</span></span><br><span class="line"><span class="emphasis">  flink_</span>style: flexcard</span><br><span class="line">  link<span class="emphasis">_list:</span></span><br><span class="line"><span class="emphasis">    - name: 安知鱼</span></span><br><span class="line"><span class="emphasis">      link: https://anheyu.com/</span></span><br><span class="line"><span class="emphasis">      avatar: https://img02.anheyu.com/adminuploads/1/2022/09/15/63232b7d91d22.jpg</span></span><br><span class="line"><span class="emphasis">      descr: 生活明朗，万物可爱</span></span><br><span class="line"><span class="emphasis">      siteshot: https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/anheyu.com.jpg</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- class_</span>name: 网站</span><br><span class="line">  class<span class="emphasis">_desc: 值得推荐的网站</span></span><br><span class="line"><span class="emphasis">  flink_</span>style: anzhiyu</span><br><span class="line">  link<span class="emphasis">_list:</span></span><br><span class="line"><span class="emphasis">    - name: Youtube</span></span><br><span class="line"><span class="emphasis">      link: https://www.youtube.com/</span></span><br><span class="line"><span class="emphasis">      avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png</span></span><br><span class="line"><span class="emphasis">      descr: 视频网站</span></span><br><span class="line"><span class="emphasis">    - name: Weibo</span></span><br><span class="line"><span class="emphasis">      link: https://www.weibo.com/</span></span><br><span class="line"><span class="emphasis">      avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png</span></span><br><span class="line"><span class="emphasis">      descr: 中国最大社交分享平台</span></span><br><span class="line"><span class="emphasis">    - name: Twitter</span></span><br><span class="line"><span class="emphasis">      link: https://twitter.com/</span></span><br><span class="line"><span class="emphasis">      avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png</span></span><br><span class="line"><span class="emphasis">      descr: 社交分享平台</span></span><br><span class="line"><span class="emphasis">&#123;% endflink %&#125;</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="mermaid-图"><a href="#mermaid-图" class="headerlink" title="mermaid 图"></a>mermaid 图</h2><div class="note blue anzhiyufont anzhiyu-icon-bullhorn simple"><p>使用<code>mermaid标签</code>可以绘制Flowchart（流程图）、Sequence diagram（时序图 ）、Class Diagram（类别图）、State Diagram（状态图）、Gantt（甘特图）和Pie Chart（圆形图），具体可以查看<a href="https://mermaid.js.org/#/">mermaid文档</a></p></div><p>修改 <code>主题配置文件</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid</span></span><br><span class="line"><span class="comment"># see https://github.com/mermaid-js/mermaid</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># built-in themes: default/forest/dark/neutral</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure><div class="tabs" id="mermaid"><ul class="nav-tabs"><button type="button" class="tab " data-href="mermaid-1">标签语法</button><button type="button" class="tab  active" data-href="mermaid-2">样式预览</button><button type="button" class="tab " data-href="mermaid-3">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="mermaid-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content active" id="mermaid-2"><p><img src="https://bu.dusays.com/2023/06/01/647889d3a16f8.png" alt="mermaid"></p></div><div class="tab-item-content" id="mermaid-3"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">pie</span><br><span class="line">    title Key elements in Product X</span><br><span class="line">    &quot;Calcium&quot; : 42.96</span><br><span class="line">    &quot;Potassium&quot; : 50.05</span><br><span class="line">    &quot;Magnesium&quot; : 10.01</span><br><span class="line">    &quot;Iron&quot; :  5</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="复选列表-checkbox"><a href="#复选列表-checkbox" class="headerlink" title="复选列表 checkbox"></a>复选列表 checkbox</h2><div class="tabs" id="checkbox"><ul class="nav-tabs"><button type="button" class="tab " data-href="checkbox-1">标签语法</button><button type="button" class="tab " data-href="checkbox-2">配置参数</button><button type="button" class="tab  active" data-href="checkbox-3">样式预览</button><button type="button" class="tab " data-href="checkbox-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="checkbox-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="checkbox-2"><ol><li>样式: plus, minus, times</li><li>颜色: <span class='p red'>red</span>,<span class='p yellow'>yellow</span>,<span class='p green'>green</span>,<span class='p cyan'>cyan</span>,<span class='p blue'>blue</span>,<span class='p gray'>gray</span></li><li>选中状态: checked</li></ol></div><div class="tab-item-content active" id="checkbox-3"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div>   <div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div>   <div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div>   <div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div>   <div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div>   <div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div>   <div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div>   <div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div>   <div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div>   <div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div></div><div class="tab-item-content" id="checkbox-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="dogeplayer-多吉云播放器"><a href="#dogeplayer-多吉云播放器" class="headerlink" title="dogeplayer 多吉云播放器"></a>dogeplayer 多吉云播放器</h2><div class="note blue anzhiyufont anzhiyu-icon-bullhorn simple"><p>快捷引入<a href="https://console.dogecloud.com/vod/overview">多吉云视频</a></p></div><div class="tabs" id="label"><ul class="nav-tabs"><button type="button" class="tab " data-href="label-1">标签语法</button><button type="button" class="tab " data-href="label-2">参数配置</button><button type="button" class="tab  active" data-href="label-3">样式预览</button><button type="button" class="tab " data-href="label-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="label-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% dogeplayer 4945 ebb742fd1f0b5a7b %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="label-2"><p>获取<code>userId</code>与<code>vcode</code></p><p><img src="https://bu.dusays.com/2023/06/01/64788b5bad729.webp"></p><table><thead><tr><th align="left">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">userId</td><td align="left">多吉云userId</td></tr><tr><td align="left">vcode</td><td align="left">视频vcode</td></tr></tbody></table></div><div class="tab-item-content active" id="label-3"><p><img src="https://bu.dusays.com/2023/06/01/64788c12883b8.webp"></p></div><div class="tab-item-content" id="label-4"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% dogeplayer 4945 ebb742fd1f0b5a7b %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="折叠框-folding"><a href="#折叠框-folding" class="headerlink" title="折叠框 folding"></a>折叠框 folding</h2><div class="note blue anzhiyufont anzhiyu-icon-bullhorn disabled"><p>折叠框folding</p></div><div class="tabs" id="folding"><ul class="nav-tabs"><button type="button" class="tab " data-href="folding-1">标签语法</button><button type="button" class="tab " data-href="folding-2">配置参数</button><button type="button" class="tab  active" data-href="folding-3">样式预览</button><button type="button" class="tab " data-href="folding-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="folding-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://bu.dusays.com/2023/06/01/64788d71c832d.webp</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="folding-2"><ol><li>颜色：blue, cyan, green, yellow, red</li><li>状态：状态填写 open 代表默认打开。</li></ol></div><div class="tab-item-content active" id="folding-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://bu.dusays.com/2023/06/01/64788d71c832d.webp"></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">https://bu.dusays.com/2023/06/01/64788d71c832d.webp</span>)</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://bu.dusays.com/2023/06/01/64788cd5a356b.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details></div><div class="tab-item-content" id="folding-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://bu.dusays.com/2023/06/01/64788d71c832d.webp</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://bu.dusays.com/2023/06/01/64788cd5a356b.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="Gallery-相册图库"><a href="#Gallery-相册图库" class="headerlink" title="Gallery 相册图库"></a>Gallery 相册图库</h2><p>一个图库集合。</p><div class="tabs" id="gallery"><ul class="nav-tabs"><button type="button" class="tab " data-href="gallery-1">标签语法</button><button type="button" class="tab " data-href="gallery-2">参数配置</button><button type="button" class="tab  active" data-href="gallery-3">样式预览</button><button type="button" class="tab " data-href="gallery-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="gallery-1"><ol><li><p>gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>gallery 相册</p></li></ol><div class="tabs" id="gallery相册"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="gallery相册-1">本地</button><button type="button" class="tab " data-href="gallery相册-2">远程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="gallery相册-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% gallery true,220,10 %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% gallery true,,10 %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>lazyload</td><td>【可选】点击按钮加载更多图片，填写 true&#x2F;false。默认为 <code>false</code>。</td></tr><tr><td>rowHeight</td><td>【可选】图片显示的高度，如果需要一行显示更多的图片，可设置更小的数字。默认为 <code>220</code>。</td></tr><tr><td>limit</td><td>【可选】每次加载多少张照片。默认为 <code>10</code>。</td></tr></tbody></table></div><div class="tab-item-content" id="gallery相册-2"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery url,[link],[lazyload],[rowHeight],[limit] %&#125;</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>url</td><td>【必须】 识别词</td></tr><tr><td>link</td><td>【必须】远程的 json 链接</td></tr><tr><td>lazyload</td><td>【可选】点击按钮加载更多图片，填写 true&#x2F;false。默认为 <code>false</code>。</td></tr><tr><td>rowHeight</td><td>【可选】图片显示的高度，如果需要一行显示更多的图片，可设置更小的数字。默认为 <code>220</code>。</td></tr><tr><td>limit</td><td>【可选】每次加载多少张照片。默认为 <code>10</code>。</td></tr></tbody></table><blockquote><p>远程链接 Json 的例子</p></blockquote><p>有三个参数，<code>url</code>是必须存在的，<code>alt</code> 和 <code>title</code> 可有，也可没有。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn1.tianli0.top/gh/jerryc127/CDN/img/IMG_0556.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IMG_0556.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这是title&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn1.tianli0.top/gh/jerryc127/CDN/img/IMG_0472.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IMG_0472.jpg&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn1.tianli0.top/gh/jerryc127/CDN/img/IMG_0453.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn1.tianli0.top/gh/jerryc127/CDN/img/IMG_0931.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>示例</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery url,https://xxxx.com/sss.json %&#125;</span><br><span class="line">&#123;% endgallery %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% gallery url,https://xxxx.com/sss.json,true,220,10 %&#125;</span><br><span class="line">&#123;% endgallery %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% gallery url,https://xxxx.com/sss.json,true,,10 %&#125;</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></div><div class="tab-item-content" id="gallery-2"><ul><li><p>gallerygroup 相册图库</p><table><thead><tr><th align="left">参数名</th><th align="left">释义</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">图库名字</td></tr><tr><td align="left">description</td><td align="left">图库描述</td></tr><tr><td align="left">link</td><td align="left">链接到对应相册的地址</td></tr><tr><td align="left">img-url</td><td align="left">图库封面</td></tr></tbody></table></li></ul><div class="note info flat"><p>思维拓展一下，相册图库的实质其实就是个快捷方式，可以自定义添加描述、封面、链接。那么我们未必要把它当做一个相册，完全可以作为一个链接卡片，链接到视频、QQ、友链都是不错的选择。</p></div><ul><li>gallery 相册<br>区别于旧版的 Gallery 相册,新的 Gallery 相册会自动根据图片长度进行排版，书写也更加方便，与 markdown 格式一样。可根据需要插入到相应的 md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</li></ul><div class="tabs" id="gallery相册参数"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="gallery相册参数-1">本地</button><button type="button" class="tab " data-href="gallery相册参数-2">远程</button></ul><div class="tab-contents"><div class="tab-item-content active" id="gallery相册参数-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% gallery true,220,10 %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% gallery true,,10 %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>lazyload</td><td>【可选】点击按钮加载更多图片，填写 true&#x2F;false。默认为 <code>false</code>。</td></tr><tr><td>rowHeight</td><td>【可选】图片显示的高度，如果需要一行显示更多的图片，可设置更小的数字。默认为 <code>220</code>。</td></tr><tr><td>limit</td><td>【可选】每次加载多少张照片。默认为 <code>10</code>。</td></tr></tbody></table></div><div class="tab-item-content" id="gallery相册参数-2"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery url,[link],[lazyload],[rowHeight],[limit] %&#125;</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>url</td><td>【必须】 识别词</td></tr><tr><td>link</td><td>【必须】远程的 json 链接</td></tr><tr><td>lazyload</td><td>【可选】点击按钮加载更多图片，填写 true&#x2F;false。默认为 <code>false</code>。</td></tr><tr><td>rowHeight</td><td>【可选】图片显示的高度，如果需要一行显示更多的图片，可设置更小的数字。默认为 <code>220</code>。</td></tr><tr><td>limit</td><td>【可选】每次加载多少张照片。默认为 <code>10</code>。</td></tr></tbody></table><blockquote><p>远程链接 Json 的例子</p></blockquote><p>有三个参数，<code>url</code>是必须存在的，<code>alt</code> 和 <code>title</code> 可有，也可没有。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn1.tianli0.top/gh/jerryc127/CDN/img/IMG_0556.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IMG_0556.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这是title&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn1.tianli0.top/gh/jerryc127/CDN/img/IMG_0472.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IMG_0472.jpg&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn1.tianli0.top/gh/jerryc127/CDN/img/IMG_0453.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn1.tianli0.top/gh/jerryc127/CDN/img/IMG_0931.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><blockquote><p>示例</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery url,https://xxxx.com/sss.json %&#125;</span><br><span class="line">&#123;% endgallery %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% gallery url,https://xxxx.com/sss.json,true,220,10 %&#125;</span><br><span class="line">&#123;% endgallery %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% gallery url,https://xxxx.com/sss.json,true,,10 %&#125;</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div></div><div class="tab-item-content active" id="gallery-3"><ul><li>gallerygroup 相册图库</li></ul><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://bu.dusays.com/2023/06/01/64788f24d05bd.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/wordScenery/'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://bu.dusays.com/2023/06/01/64788f456fc3d.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/thousand/'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://bu.dusays.com/2023/06/01/64788f83e5fa1.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/wallpaper/'></a>  </figcaption>  </figure>  </div><ul><li>gallery 相册</li></ul><div class="gallery">  <div class="fj-gallery page_img_lazyload lazyload btn_album_detail_lazyload data" data-rowHeight="220" data-limit="2">    <span class="gallery-data">[{"url":"https://bu.dusays.com/2023/06/01/647896b15759c.jpg","alt":""},{"url":"https://bu.dusays.com/2023/06/01/647896cabde59.jpg","alt":""},{"url":"https://bu.dusays.com/2023/06/01/647896eb0f3ea.jpg","alt":""},{"url":"https://bu.dusays.com/2023/06/01/647896ed810b3.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg","alt":""}]</span>  </div><button class="gallery-load-more" style="opacity:0">  <span>加载更多</span>  <i class="anzhiyufont anzhiyu-icon-arrow-down"></i>  </button></div></div><div class="tab-item-content" id="gallery-4"><div class="note info flat"><p>对于很多同学提问的<code>gallerygroup</code>和<code>gallery</code>相册页的链接问题。这里说下我个人的使用习惯。<br>一般使用相册图库的话，可以在导航栏加一个 gallery 的 page(<strong>使用指令<code>hexo new page gallery</code>添加</strong>)，里面放相册图库作为封面。然后在<code>[Blogroot]/source/gallery/</code>下面建立相应的文件夹，例如若按照这里的示例，若欲使用<code>/gallery/MC/</code>路径访问 MC 相册，则需要新建<code>[Blogroot]/source/gallery/MC/index.md</code>，并在里面填入<code>gallery</code>相册内容。</p><p>注意 ⚠️：本站相册集为单独优化，可参考<a href="https://anheyu.com/posts/220c.html">配置相册页面</a>。</p></div><ol><li><p>gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line"> &#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/wordScenery/&#x27; https://bu.dusays.com/2023/06/01/64788f24d05bd.webp %&#125;</span><br><span class="line"> &#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/thousand/&#x27; https://bu.dusays.com/2023/06/01/64788f456fc3d.webp %&#125;</span><br><span class="line"> &#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/wallpaper/&#x27; https://bu.dusays.com/2023/06/01/64788f83e5fa1.webp %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>gallery 相册</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery true,,2 %&#125;</span><br><span class="line">![](<span class="link">https://bu.dusays.com/2023/06/01/647896b15759c.jpg</span>)</span><br><span class="line">![](<span class="link">https://bu.dusays.com/2023/06/01/647896cabde59.jpg</span>)</span><br><span class="line">![](<span class="link">https://bu.dusays.com/2023/06/01/647896eb0f3ea.jpg</span>)</span><br><span class="line">![](<span class="link">https://bu.dusays.com/2023/06/01/647890012b1ec.webp</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure></li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="tag-hide"><a href="#tag-hide" class="headerlink" title="tag-hide"></a>tag-hide</h2><div class="note blue anzhiyufont anzhiyu-icon-bullhorn flat"><p>如果你想把一些文字、内容隐藏起来，并提供按钮让用户点击显示。可以使用这个标签外挂。<br>请注意，tag-hide内的标签外挂content内都不建议有h1 - h6 等标题。因为Toc会把隐藏内容标题也显示出来，而且当滚动屏幕时，如果隐藏内容没有显示出来，会导致Toc的滚动出现异常。</p></div><div class="tabs" id="tag-hide"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="tag-hide-1">inline</button><button type="button" class="tab " data-href="tag-hide-2">Block</button><button type="button" class="tab " data-href="tag-hide-3">Toggle</button></ul><div class="tab-contents"><div class="tab-item-content active" id="tag-hide-1"><p><code>inline</code> 在文本里面添加按钮隐藏内容，只限文字</p><p>( content不能包含英文逗号，可用<code>&amp;sbquo;</code>)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>content: 文本内容</p></li><li><p>display: 按钮显示的文字(可选)</p></li><li><p>bg: 按钮的背景颜色(可选)</p></li><li><p>color: 按钮文字的颜色(可选)</p></li></ul><blockquote><p>Demo</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;</span><br><span class="line"></span><br><span class="line">门里站着一个人? &#123;% hideInline 闪 %&#125;</span><br></pre></td></tr></table></figure><p>哪个英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案<br>  </button><span class="hide-content">因为西装裤(C装酷)</span></span></p><p>门里站着一个人? <span class="hide-inline"><button type="button" class="hide-button" style="">Click<br>  </button><span class="hide-content">闪</span></span></p></div><div class="tab-item-content" id="tag-hide-2"><p><code>block</code>独立的block隐藏内容，可以隐藏很多内容，包括图片，代码块等等</p><p>( display 不能包含英文逗号，可用<code>&amp;sbquo;</code>)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>content: 文本内容</p></li><li><p>display: 按钮显示的文字(可选)</p></li><li><p>bg: 按钮的背景颜色(可选)</p></li><li><p>color: 按钮文字的颜色(可选)</p></li></ul><blockquote><p>Demo</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">查看答案</span><br><span class="line">&#123;% hideBlock 查看答案 %&#125;</span><br><span class="line">傻子，怎么可能有答案</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><p>查看答案</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案    </button><div class="hide-content"><p>傻子，怎么可能有答案</p></div></div></div><div class="tab-item-content" id="tag-hide-3"><p>如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。</p><p>( display 不能包含英文逗号，可用<code>&amp;sbquo;</code>)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Demo</p></blockquote><details class="toggle" ><summary class="toggle-button" style="">AnZhiYu主题安装方法</summary><div class="toggle-content"><p>在你的博客根目录里</p><p>git clone -b master <a href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git">https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git</a> themes&#x2F;anzhiyu</p><p>如果想要安装比较新的dev分支，可以</p><p>git clone -b dev <a href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git">https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git</a> themes&#x2F;anzhiyu</p></div></details></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="链接卡片-link"><a href="#链接卡片-link" class="headerlink" title="链接卡片 link"></a>链接卡片 link</h2><div class="tabs" id="link"><ul class="nav-tabs"><button type="button" class="tab " data-href="link-1">标签语法</button><button type="button" class="tab  active" data-href="link-2">样式预览</button><button type="button" class="tab " data-href="link-3">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="link-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% link 标题, 站点描述, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content active" id="link-2"><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://github.com/owen0o0/getFavicon">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="">          <i class="anzhiyufont anzhiyu-icon-link" style=""></i>        </div>        <div class="tag-link-right">            <div class="tag-link-title">获取网站的Favicon图标并显示在你的网页上</div>            <div class="tag-link-sitename">owen0o0</div>        </div>        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>    </div>    </a></div></div><div class="tab-item-content" id="link-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% link 获取网站的Favicon图标并显示在你的网页上,owen0o0,https://github.com/owen0o0/getFavicon %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="单选列表-radio"><a href="#单选列表-radio" class="headerlink" title="单选列表 radio"></a>单选列表 radio</h2><div class="tabs" id="radio"><ul class="nav-tabs"><button type="button" class="tab " data-href="radio-1">标签语法</button><button type="button" class="tab " data-href="radio-2">配置参数</button><button type="button" class="tab  active" data-href="radio-3">样式预览</button><button type="button" class="tab " data-href="radio-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="radio-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="radio-2"><ol><li>颜色: <span class='p red'>red</span>,<span class='p yellow'>yellow</span>,<span class='p green'>green</span>,<span class='p cyan'>cyan</span>,<span class='p blue'>blue</span>,<span class='p gray'>gray</span></li><li>选中状态: checked</li></ol></div><div class="tab-item-content active" id="radio-3"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div>   <div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div>   <div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div>   <div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div>   <div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div>   <div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div>   <div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div></div><div class="tab-item-content" id="radio-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="上标标签-tip"><a href="#上标标签-tip" class="headerlink" title="上标标签 tip"></a>上标标签 tip</h2><div class="tip cogs"><p>主要样式参考自<a href="https://www.antmoe.com/posts/3b43914f/">小康的 butterfly 渐变背景标签</a></p></div><div class="tabs" id="tip"><ul class="nav-tabs"><button type="button" class="tab " data-href="tip-1">标签语法</button><button type="button" class="tab " data-href="tip-2">配置参数</button><button type="button" class="tab  active" data-href="tip-3">样式预览</button><button type="button" class="tab " data-href="tip-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="tip-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="tip-2"><ol><li>样式: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li>自定义图标: 支持 fontawesome。</li></ol></div><div class="tab-item-content active" id="tip-3"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义 font awesome 图标</p></div></div><div class="tab-item-content" id="tip-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义 font awesome 图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="Note-Bootstrap-Callout"><a href="#Note-Bootstrap-Callout" class="headerlink" title="Note (Bootstrap Callout)"></a>Note (Bootstrap Callout)</h2><div class="tabs" id="note"><ul class="nav-tabs"><button type="button" class="tab " data-href="note-1">通用配置</button><button type="button" class="tab " data-href="note-2">语法格式</button><button type="button" class="tab " data-href="note-3">配置参数</button><button type="button" class="tab  active" data-href="note-4">样式预览</button><button type="button" class="tab " data-href="note-5">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="note-1"><p>修改主题配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>Note</code>标签外挂有两种用法。<code>icons</code>和<code>light_bg_offset</code>只对方法一生效。</p><p><code>fontawesome</code>图标需开启主题配置文件中<code>icons.fontawesome</code></p></div><div class="tab-item-content" id="note-2"><p><code>方法一</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p><code>方法二</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="note-3"><p><code>方法一</code></p><table><thead><tr><th align="left">参数</th><th align="left">用法</th></tr></thead><tbody><tr><td align="left">class</td><td align="left">【可选】标识，不同的标识有不同的配色<br>（ default &#x2F; primary &#x2F; success &#x2F; info &#x2F; warning &#x2F; danger ）</td></tr><tr><td align="left">no-icon</td><td align="left">【可选】不显示 icon</td></tr><tr><td align="left">style</td><td align="left">【可选】可以覆盖配置中的 style<br>（simple&#x2F;modern&#x2F;flat&#x2F;disabled）</td></tr></tbody></table><p><code>方法二</code></p><table><thead><tr><th align="left">参数</th><th align="left">用法</th></tr></thead><tbody><tr><td align="left">class</td><td align="left">【可选】标识，不同的标识有不同的配色<br>（ default &#x2F; blue &#x2F; pink &#x2F; red &#x2F; purple &#x2F; orange &#x2F; green ）</td></tr><tr><td align="left">no-icon</td><td align="left">【可选】可配置自定义 icon (支持 fontawesome 图标和主题内置的阿里图标,<code>fontawesome</code>图标需开启主题配置文件中<code>icons.fontawesome</code>, 也可以配置 no-icon )</td></tr><tr><td align="left">style</td><td align="left">【可选】可以覆盖配置中的 style<br>（simple&#x2F;modern&#x2F;flat&#x2F;disabled）</td></tr></tbody></table></div><div class="tab-item-content active" id="note-4"><p><code>方法一</code></p><ol><li><code>simple</code>样式</li></ol><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div><ol start="2"><li><code>modern</code>样式</li></ol><div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><ol start="3"><li><code>flat</code>样式</li></ol><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><ol start="4"><li><code>disabled</code>样式</li></ol><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><ol start="5"><li><code>no-icon</code>样式</li></ol><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div><p><code>方法二</code></p><p>图标支持 <code>fontawesome</code> 和 <code>主题内置的阿里图标</code>，使用方法为加上对应的类名，<code>fontawesome</code>图标需开启主题配置文件中<code>icons.fontawesome</code>，默认未开启 fontawesome</p><ol><li>simple 样式</li></ol><p><code>主题内置阿里图标</code></p><div class="note anzhiyufont anzhiyu-icon-rocket simple"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue anzhiyufont anzhiyu-icon-bullhorn simple"><p>2022 年快到了….</p></div><div class="note pink anzhiyufont anzhiyu-icon-instagram simple"><p>小心开车 安全至上</p></div><div class="note red anzhiyufont anzhiyu-icon-fan simple"><p>这是三片呢？还是四片？</p></div><div class="note orange anzhiyufont anzhiyu-icon-dengpao simple"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple anzhiyufont anzhiyu-icon-sanmingzhi simple"><p>剪刀石头布</p></div><div class="note green anzhiyufont anzhiyu-icon-ic_train simple"><p>前端最讨厌的浏览器</p></div><p><code>fontawesome 图标</code>，开启主题配置文件中的<code>icons.fontawesome</code>为<code>true</code>后可见</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2022 年快到了….</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-fan simple"><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏器</p></div><ol start="2"><li>modern 样式</li></ol><p><code>主题内置阿里图标</code></p><div class="note anzhiyufont anzhiyu-icon-rocket modern"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue anzhiyufont anzhiyu-icon-bullhorn modern"><p>2022 年快到了….</p></div><div class="note pink anzhiyufont anzhiyu-icon-instagram modern"><p>小心开车 安全至上</p></div><div class="note red anzhiyufont anzhiyu-icon-fan modern"><p>这是三片呢？还是四片？</p></div><div class="note orange anzhiyufont anzhiyu-icon-dengpao modern"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple anzhiyufont anzhiyu-icon-sanmingzhi modern"><p>剪刀石头布</p></div><div class="note green anzhiyufont anzhiyu-icon-ic_train modern"><p>前端最讨厌的浏览器</p></div><p><code>fontawesome 图标</code>，开启主题配置文件中的<code>icons.fontawesome</code>为<code>true</code>后可见</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021 年快到了….</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-fan modern"><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><ol start="3"><li>flat 样式</li></ol><p><code>主题内置阿里图标</code></p><div class="note anzhiyufont anzhiyu-icon-rocket flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue anzhiyufont anzhiyu-icon-bullhorn flat"><p>2022 年快到了….</p></div><div class="note pink anzhiyufont anzhiyu-icon-instagram flat"><p>小心开车 安全至上</p></div><div class="note red anzhiyufont anzhiyu-icon-fan flat"><p>这是三片呢？还是四片？</p></div><div class="note orange anzhiyufont anzhiyu-icon-dengpao flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple anzhiyufont anzhiyu-icon-sanmingzhi flat"><p>剪刀石头布</p></div><div class="note green anzhiyufont anzhiyu-icon-ic_train flat"><p>前端最讨厌的浏览器</p></div><p><code>fontawesome 图标</code>，开启主题配置文件中的<code>icons.fontawesome</code>为<code>true</code>后可见</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021 年快到了….</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-fan flat"><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><ol start="4"><li>disabled 样式</li></ol><p><code>主题内置阿里图标</code></p><div class="note anzhiyufont anzhiyu-icon-rocket disabled"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue anzhiyufont anzhiyu-icon-bullhorn disabled"><p>2022 年快到了….</p></div><div class="note pink anzhiyufont anzhiyu-icon-instagram disabled"><p>小心开车 安全至上</p></div><div class="note red anzhiyufont anzhiyu-icon-fan disabled"><p>这是三片呢？还是四片？</p></div><div class="note orange anzhiyufont anzhiyu-icon-dengpao disabled"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple anzhiyufont anzhiyu-icon-sanmingzhi disabled"><p>剪刀石头布</p></div><div class="note green anzhiyufont anzhiyu-icon-ic_train disabled"><p>前端最讨厌的浏览器</p></div><p><code>fontawesome 图标</code>，开启主题配置文件中的<code>icons.fontawesome</code>为<code>true</code>后可见</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021 年快到了….</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-fan disabled"><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><ol start="5"><li>no-icon 样式</li></ol><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021 年快到了….</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div></div><div class="tab-item-content" id="note-5"><p><code>方法一</code></p><ol><li><code>simple</code>样式</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>modern</code>样式</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>flat</code>样式</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>disabled</code>样式</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>no-icon</code>样式</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p><code>方法二</code></p><p>图标支持 <code>fontawesome</code> 和 <code>主题内置的阿里图标</code>，使用方法为加上对应的类名，<code>fontawesome</code>图标需开启主题配置文件中<code>icons.fontawesome</code>，默认未开启 fontawesome</p><ol><li><p>simple 样式<br><code>主题内置阿里图标</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;anzhiyufont anzhiyu-icon-rocket&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;anzhiyufont anzhiyu-icon-bullhorn&#x27; simple %&#125;2022 年快到了....&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;anzhiyufont anzhiyu-icon-instagram&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;anzhiyufont anzhiyu-icon-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;anzhiyufont anzhiyu-icon-dengpao&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;anzhiyufont anzhiyu-icon-sanmingzhi&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;anzhiyufont anzhiyu-icon-ic<span class="emphasis">_train&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span></span><br></pre></td></tr></table></figure><p><code>fontawesome 图标</code>，开启主题配置文件中的<code>icons.fontawesome</code>为<code>true</code>后可见</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2022 年快到了....&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;icon-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li><li><p>modern 样式<br><code>主题内置阿里图标</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;anzhiyufont anzhiyu-icon-rocket&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;anzhiyufont anzhiyu-icon-bullhorn&#x27; modern %&#125;2022 年快到了....&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;anzhiyufont anzhiyu-icon-instagram&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;anzhiyufont anzhiyu-icon-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;anzhiyufont anzhiyu-icon-dengpao&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;anzhiyufont anzhiyu-icon-sanmingzhi&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;anzhiyufont anzhiyu-icon-ic<span class="emphasis">_train&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span></span><br></pre></td></tr></table></figure><p><code>fontawesome 图标</code>，开启主题配置文件中的<code>icons.fontawesome</code>为<code>true</code>后可见</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021 年快到了....&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;icon-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li><li><p>flat 样式<br><code>主题内置阿里图标</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;anzhiyufont anzhiyu-icon-rocket&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;anzhiyufont anzhiyu-icon-bullhorn&#x27; flat %&#125;2022 年快到了....&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;anzhiyufont anzhiyu-icon-instagram&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;anzhiyufont anzhiyu-icon-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;anzhiyufont anzhiyu-icon-dengpao&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;anzhiyufont anzhiyu-icon-sanmingzhi&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;anzhiyufont anzhiyu-icon-ic<span class="emphasis">_train&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span></span><br></pre></td></tr></table></figure><p><code>fontawesome 图标</code>，开启主题配置文件中的<code>icons.fontawesome</code>为<code>true</code>后可见</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021 年快到了....&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;icon-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li><li><p>disabled 样式<br><code>主题内置阿里图标</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;anzhiyufont anzhiyu-icon-rocket&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;anzhiyufont anzhiyu-icon-bullhorn&#x27; disabled %&#125;2022 年快到了....&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;anzhiyufont anzhiyu-icon-instagram&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;anzhiyufont anzhiyu-icon-fan&#x27; disabled%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;anzhiyufont anzhiyu-icon-dengpao&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;anzhiyufont anzhiyu-icon-sanmingzhi&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;anzhiyufont anzhiyu-icon-ic<span class="emphasis">_train&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span></span><br></pre></td></tr></table></figure><p><code>fontawesome 图标</code>，开启主题配置文件中的<code>icons.fontawesome</code>为<code>true</code>后可见</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021 年快到了....&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;icon-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li><li><p>no-icon 样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue no-icon %&#125;2021 年快到了....&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="音频-audio"><a href="#音频-audio" class="headerlink" title="音频 audio"></a>音频 audio</h2><div class="tabs" id="audio"><ul class="nav-tabs"><button type="button" class="tab " data-href="audio-1">标签语法</button><button type="button" class="tab  active" data-href="audio-2">样式预览</button><button type="button" class="tab " data-href="audio-3">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="audio-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content active" id="audio-2"><div class="audio"><audio controls preload><source src='https://npm.elemecdn.com/anzhiyu-music@1.0.4/%E9%9D%92%E8%8A%B1%E7%93%B7/%E9%9D%92%E8%8A%B1%E7%93%B7.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div></div><div class="tab-item-content" id="audio-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% audio https://npm.elemecdn.com/anzhiyu-music@1.0.4/%E9%9D%92%E8%8A%B1%E7%93%B7/%E9%9D%92%E8%8A%B1%E7%93%B7.mp3 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="视频-video"><a href="#视频-video" class="headerlink" title="视频 video"></a>视频 video</h2><div class="tabs" id="video"><ul class="nav-tabs"><button type="button" class="tab " data-href="video-1">标签语法</button><button type="button" class="tab " data-href="video-2">参数配置</button><button type="button" class="tab  active" data-href="video-3">样式预览</button><button type="button" class="tab " data-href="video-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="video-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="video-2"><ol><li>对其方向：left, center, right</li><li>列数：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol></div><div class="tab-item-content active" id="video-3"><ol start="3"><li>100%宽度</li></ol><p><img src="https://bu.dusays.com/2023/06/01/6478a1eeb1386.png" alt="100%宽度"></p><ol start="2"><li>50%宽度</li></ol><p><img src="https://bu.dusays.com/2023/06/01/6478a20a5f242.png" alt="50%宽度"></p><ol start="3"><li>25%宽度</li></ol><p><img src="https://bu.dusays.com/2023/06/01/6478a22b26088.png" alt="25%宽度"></p></div><div class="tab-item-content" id="video-4"><ol><li>100%宽度</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>50%宽度</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>25%宽度</li></ol><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一讲 基础算法 - 01快速排序</title>
      <link href="/posts/51175/"/>
      <url>/posts/51175/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><blockquote><ul><li><em><a href="https://akari2333.github.io/posts/38023/">十大排序——快速排序 | Akari的小站</a></em></li><li><em><a href="https://www.acwing.com/file_system/file/content/whole/index/content/10646438/">Acwing 基础算法总结 - AcWing</a></em></li><li><em><a href="https://blog.csdn.net/qq_45438600/article/details/116795979">AcWing 算法基础课笔记 - CSDN</a></em></li></ul></blockquote><hr><blockquote><p><strong>推荐阅读：</strong></p><ul><li><em><a href="https://www.acwing.com/solution/content/16777/">AcWing 785. 快速排序算法的证明与边界分析 - AcWing</a></em></li><li><em><a href="https://www.acwing.com/solution/content/2089/">AcWing 785. 快速排序算法、时间复杂度、代码</a></em></li><li><em><a href="https://www.cnblogs.com/littlehb/p/15000855.html">AcWing 785. 快速排序 - 糖豆爸爸 - 博客园</a></em></li><li><em><a href="https://blog.csdn.net/qq_36533552/article/details/106328719">快速排序最好、最坏以及平均复杂度推导理解 - CSDN</a></em></li></ul></blockquote><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>快速排序算法模板 —— <a href="https://www.acwing.com/problem/content/787/">模板题 AcWing 785. 快速排序</a></strong></p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>快速排序是一种常见且高效的排序算法。其基本思想可以归纳为以下几个步骤：</p><blockquote><ol><li>选择一个基准元素（通常是数组的第一个或最后一个元素）作为分割点。</li><li>将数组中小于基准的元素移动到基准的左边，大于基准的元素移动到右边。这个过程称为分区操作。</li><li>对分区后的左右两个子数组，重复步骤1和步骤2，直到子数组的大小为1或0，即已经排序完成。</li><li>最后将所有子数组拼接起来，即得到排好序的数组。</li></ol></blockquote><p>这种分而治之的思想使得快速排序具有较好的平均时间复杂度（O(nlogn)），并且它是一种原地排序算法，不需要额外的辅助空间。</p><p>需要注意的是，快速排序的性能高度依赖于选取的基准元素。不同的选择方式可能导致最好情况和最坏情况的时间复杂度差异较大，因此一些优化方法也被提出来，如随机选择基准元素、三数取中法等。</p><h2 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h2><p>基于分治。<br>第一步 <strong>确定分界点x</strong>：取左边界q[l]，或者取中间值q[(l+r)&#x2F;2]，或者取右边界q[r]，也可以随机。<br>第二步 <strong>调整区间</strong>(较难部分)：让小于等于x的数在一个区间，大于x的在另一个区间——最终效果是：<strong>x 左边的都是小于等于 x，x 右边的都是大于等于 x。</strong></p><div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/b3504a366ddeafe1ed610.png" alt="$fileName" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;">        调整区间    </div></div><p>第三步 递归处理左右两端</p><p><strong>平均时间复杂度</strong>： O(nlogn)<br>每层期望是 n&#x2F;2 ，递归深度 logn，故平均时间复杂度 O(nlogn)</p><h2 id="3-思路讲解"><a href="#3-思路讲解" class="headerlink" title="3. 思路讲解"></a>3. 思路讲解</h2><p><strong>思路1</strong>（暴力解法，需要额外空间放a b）：<br>但从时间复杂度上来说也是线性的，一共扫了2遍，时间复杂度为 O(n)，常数可以不考虑。</p><div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/f723b55b53d9db0452261.png" alt="$fileName" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;">        暴力解法    </div></div><p><strong>思路2</strong>（较优美的解法）：<br>使用双指针，从数组两端向中间靠拢。指针 i 从左端找大于等于 x 的数，指针 j 从右端找小于等于 x 的数，然后swap二者，直至 i 和 j 相遇。</p><div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/b23c1349788aceab31589.png" alt="$fileName" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;">        优美解法    </div></div><h2 id="4-快排模板"><a href="#4-快排模板" class="headerlink" title="4. 快排模板"></a>4. 快排模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];    <span class="comment">// 确定分界点 x</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;   <span class="comment">// 调整区间</span></span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);   <span class="comment">// 递归处理左, 右两部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归 quick_sort(q, l, j), quick_sort(q, j + 1, r); 中 j 也可以换成用 i 的写法，但是要注意 x 的取值边界问题。</p>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一癫 03</title>
      <link href="/posts/65/"/>
      <url>/posts/65/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 发电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找（折半查找） 之二</title>
      <link href="/posts/55426/"/>
      <url>/posts/55426/</url>
      
        <content type="html"><![CDATA[<p>前情提要：<del>写的也太垃圾了感觉，不忍看</del></p><blockquote><ul><li><em><a href="https://akari2333.github.io/posts/42877/">二分查找 | Akari的小站</a></em></li></ul></blockquote><p>参考：</p><blockquote><ul><li><em><a href="https://www.bilibili.com/video/av81382764/">懒猫老师-C语言-二分查找（折半查找）_哔哩哔哩</a></em></li><li><em><a href="https://www.zhihu.com/column/c_1377643225017176065">跟懒猫老师学C&#x2F;C++程序设计 - 知乎</a></em></li></ul></blockquote><hr><div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/9bcc00fac39bbdbffe20c.jpg" alt="$fileName" width="60%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;">        流程图    </div></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> length, <span class="type">int</span> target )</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = length<span class="number">-1</span>;       <span class="comment">// 左闭右开: int right = length; </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( left &lt;= right )&#123;</span><br><span class="line">        <span class="type">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( target &lt; a[middle] )</span><br><span class="line">            right = middle - <span class="number">1</span>;  <span class="comment">// 左闭右开：right = middle;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( target &gt; a[middle] )</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一、使用条件"><a href="#一、使用条件" class="headerlink" title="一、使用条件"></a>一、使用条件</h1><blockquote><ul><li>线性表中的记录必须按关键码有序</li><li>必须采用顺序存储</li></ul></blockquote><h1 id="二、low"><a href="#二、low" class="headerlink" title="二、low &lt;&#x3D; high ？"></a>二、low &lt;&#x3D; high ？</h1><p>之前我也有疑问，为什么呢？</p><div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/21b82be8b13bc2d1642a9.jpg" alt="$fileName" width="60%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;">        low、high、mid 重合    </div></div><p>如上图，在数组中查找 12，而 12 是不存在的。但当查找到最后一步三者重合时，由于<strong>区间变化规律</strong>，还是会继续查找，此时 high 和 low 交错，会无限循环——由于没有终止条件 <strong>while(low &lt;&#x3D; high)</strong>。</p><div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/56819d2bf42d5c646bf10.jpg" alt="$fileName" width="60%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;">        low、high 交错，退出循环    </div></div><p><strong>所以，while(low &lt;&#x3D; high)（或者while(low &lt; high)）是为了在找不到target时顺利地退出循环。</strong></p><h1 id="三、作业"><a href="#三、作业" class="headerlink" title="三、作业"></a>三、作业</h1><p>课上小任务，5分钟。</p><div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/9303ce4d33ec8ee9b5f7a.jpg" alt="$fileName" width="60%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;">        小任务    </div></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @version:</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-11 17:27:44</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      <span class="comment">// 二分查找 binarySearch</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> arrLength, <span class="type">int</span> targetNumber)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">13</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">41</span>, <span class="number">55</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">81</span>, <span class="number">98</span>&#125;;</span><br><span class="line">    <span class="type">int</span> targetNumber, result;</span><br><span class="line">    <span class="type">int</span> arrLength = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);   <span class="comment">// 获得数组长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入在以下数组中要查找的数字：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;targetNumber);</span><br><span class="line">    </span><br><span class="line">    result = binarySearch(<span class="built_in">array</span>, arrLength, targetNumber);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == result )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found! Target index: %d\n&quot;</span>, result + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[], <span class="type">int</span> arrLength, <span class="type">int</span> targetNumber)</span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high = arrLength - <span class="number">1</span>;   <span class="comment">// 左闭右开式：high = arrLength</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( low &lt;= high )&#123;</span><br><span class="line">        <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;   <span class="comment">// 防止越界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( targetNumber &gt; <span class="built_in">array</span>[mid] )</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( targetNumber &lt; <span class="built_in">array</span>[mid] )</span><br><span class="line">            high = mid - <span class="number">1</span>;     <span class="comment">// 左闭右开时：high = mid</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/d676ee13ae627fc2071f7.jpg" alt="$fileName" width="60%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;">        总结    </div></div><h2 id="4-1-老师推荐的刷题网站"><a href="#4-1-老师推荐的刷题网站" class="headerlink" title="4.1 老师推荐的刷题网站"></a>4.1 老师推荐的刷题网站</h2><blockquote><p><strong>NOI &#x2F; 1.11编程基础之二分查找：<a href="http://noi.openjudge.cn/ch0111/">http://noi.openjudge.cn/ch0111/</a></strong></p></blockquote><p>也就是小结中的第三点，不仅可以查找数据，还可以解决数学问题、几何问题。</p><h2 id="4-2-sizeof-array-sizeof-array-0"><a href="#4-2-sizeof-array-sizeof-array-0" class="headerlink" title="4.2 sizeof(array) &#x2F; sizeof(array[0])"></a>4.2 sizeof(array) &#x2F; sizeof(array[0])</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arrLength = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);   <span class="comment">// 获得数组长度</span></span><br></pre></td></tr></table></figure><p><strong>sizeof</strong> 是一个运算符，用于计算数据类型或对象所占用的字节数。对于数组，<strong>sizeof(array)</strong> 返回整个数组所占用的字节数，而 sizeof(array[0]) 返回数组中单个元素的字节数。</p><p>通过将整个数组所占用的字节数除以单个元素的字节数，就可以得到数组中元素的个数。<strong>这是因为整个数组所占用的字节数除以单个元素的字节数就是数组中元素的个数。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 排序和查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小站日记01——图床</title>
      <link href="/posts/59955/"/>
      <url>/posts/59955/</url>
      
        <content type="html"><![CDATA[<div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/3dcd3040f81dac5d75262.jpg" alt="$fileName" width="75%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;">        从昨天下午折腾到今天下午，真累啊...荧妹，嘿嘿，我的荧妹...包包，嘿嘿...包包...    </div></div><h1 id="1-使用过的图床"><a href="#1-使用过的图床" class="headerlink" title="1. 使用过的图床"></a>1. 使用过的图床</h1><h2 id="1-1-SunPics"><a href="#1-1-SunPics" class="headerlink" title="1.1 SunPics"></a>1.1 SunPics</h2><p><a href="https://pics.sunbangyan.cn/">SunPics - 基于EasyImage的开源免费图床</a></p><p><strong>特性：</strong></p><blockquote><ul><li>免费</li><li>空间无限制</li><li>支持导出 <strong>HTML、Markwown、直链</strong> 等格式</li><li>速度较快</li><li>会压缩图片</li><li>不支持后台管理</li></ul></blockquote><hr><p>但是由于恶意攻击，以后可能不能用了······所以不用了，唉。</p><div align="center" >    <img src="https://telegraph-image-box.pages.dev/file/11ca60f2a1b17fe53f259.png" alt="sunpics" width="100%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;"/>    <div style="color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;">        R.I.P    </div></div><h2 id="1-2-PicGo-Github"><a href="#1-2-PicGo-Github" class="headerlink" title="1.2 PicGo + Github"></a>1.2 PicGo + Github</h2><p>PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具。</p><blockquote><ul><li>PIcGo项目地址：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></li><li>PicGo官网：<a href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a></li><li>PicGo文档：<a href="https://picgo.github.io/PicGo-Doc/en/guide/#picgo-is-here">https://picgo.github.io/PicGo-Doc/en/guide/#picgo-is-here</a></li></ul></blockquote><p><strong>特性：</strong></p><blockquote><ul><li>免费</li><li>空间有限制——依托于GitHub，1GB大小</li><li>支持导出<strong>HTML、Markwown、直链、custom自定义</strong> 等格式</li><li><strong>速度慢，不稳定，上传经常失败</strong></li><li>不会压缩图片</li><li>不支持后台管理</li></ul></blockquote><p>参考教程：</p><blockquote><ul><li><em><a href="https://wlcheng.cc/posts/github_picture_bed/">Github 图床 PicGo 使用 - Wlcheng’s Life</a></em></li><li><em><a href="https://www.sunshuyi.vip/posts/48451/">exo+Next（2）PicGo图床搭建H | 我的小站</a></em></li><li><em><a href="https://zhuanlan.zhihu.com/p/489236769">使用Github+picGo搭建图床，保姆级教程来了 - 知乎</a></em></li><li><em><a href="https://zhuanlan.zhihu.com/p/353775844">如何利用 Github 搭建自己的免费图床？ - 知乎</a></em></li></ul></blockquote><p><strong>vscode 快捷方式：</strong></p><blockquote><ul><li><strong>Ctrl + Alt + u：</strong>从剪切板上传</li><li><strong>Ctrl + Alt + e：</strong>从资源管理器上传</li><li><strong>Ctrl + Alt + o：</strong>从输入框上传</li></ul></blockquote><h2 id="1-3-Telegraph-Image"><a href="#1-3-Telegraph-Image" class="headerlink" title="1.3 Telegraph-Image"></a>1.3 Telegraph-Image</h2><p>免费图片托管解决方案，Flickr&#x2F;imgur替代品。使用Cloudflare Pages和Telegraph。</p><blockquote><ul><li>项目地址：<a href="https://github.com/cf-pages/Telegraph-Image">https://github.com/cf-pages/Telegraph-Image</a></li><li>演示地址：<a href="https://im.gurl.eu.org/">https://im.gurl.eu.org/</a></li></ul></blockquote><p><strong>特性：</strong></p><blockquote><ol><li>无限图片储存数量，你可以上传不限数量的图片</li><li>无需购买服务器，托管于Cloudflare的网络上，当使用量不超过Cloudflare的免费额度时，完全免费</li><li>无需购买域名，可以使用Cloudflare Pages提供的 <code>*.pages.dev</code> 的免费二级域名，同时也支持绑定自定义域名</li><li>支持图片审查API，可根据需要开启，开启后不良图片将自动屏蔽，不再加载</li><li>支持后台图片管理，可以对上传的图片进行在线预览，添加白名单，黑名单等操作</li></ol></blockquote><p>折腾一会后，算是搞成了······</p><p><strong>但是：项目地址文档中说可以不使用 kv 加密，使用cloudflare access 更好，不会搞·····折腾半天，算了······</strong></p><blockquote><p><em>当然你也可以不设置这两个值，这样访问后台管理页面时将无需验证，直接跳过登录步骤，这一设计使得你可以结合 Cloudflare Access 进行使用，实现支持邮件验证码登录，Microsoft账户登录，Github账户登录等功能，能够与你域名上原有的登录方式所集成，无需再次记忆多一组后台的账号密码，添加Cloudflare Access的方式请参考官方文档，注意需要保护路径包括&#x2F;admin 以及 &#x2F;api&#x2F;manage&#x2F;</em> *</p></blockquote><h1 id="2-自定义链接格式控制图片样式"><a href="#2-自定义链接格式控制图片样式" class="headerlink" title="2. 自定义链接格式控制图片样式"></a>2. 自定义链接格式控制图片样式</h1><blockquote><ul><li><a href="https://wlcheng.cc/posts/github_picture_bed/">Github 图床 PicGo 使用 - Wlcheng’s Life</a></li></ul></blockquote><p>算是意外收获了，哈哈。在找 picgo 的教程时发现的，确实好！<br>正好 telegraph 只有直链，这些格式在文章中还是需要的啊。</p><hr><p><strong>改动如下：</strong></p><blockquote><ul><li>去掉了标题文字下划线</li><li>缩小了标题文字和图片之间的间隔</li></ul></blockquote><p><strong>总结如下：</strong></p><blockquote><ol><li><strong>控制大小</strong></li></ol>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;$url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;$fileName&quot;</span> <span class="attr">width</span>=<span class="string">&quot;75%&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>圆角</strong></li></ol>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;$url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;$fileName&quot;</span> <span class="attr">width</span>=<span class="string">&quot;75%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-radius:10px;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>阴影</strong></li></ol>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;$url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;$fileName&quot;</span> <span class="attr">width</span>=<span class="string">&quot;75%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>阴影 + 圆角</strong></li></ol>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;$url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;$fileName&quot;</span> <span class="attr">width</span>=<span class="string">&quot;75%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23); border-radius:10px;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>阴影 + 标题</strong></li></ol>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;$url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;$fileName&quot;</span> <span class="attr">width</span>=<span class="string">&quot;75%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23); margin-bottom: 3px;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;&quot;</span>&gt;</span></span><br><span class="line">        此处插入标题</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>圆角 + 标题</strong></li></ol>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;$url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;$fileName&quot;</span> <span class="attr">width</span>=<span class="string">&quot;75%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-radius:10px; margin-bottom: 3px;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;&quot;</span>&gt;</span></span><br><span class="line">        此处插入标题</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li><strong>阴影 + 圆角 + 标题</strong></li></ol>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;$url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;$fileName&quot;</span> <span class="attr">width</span>=<span class="string">&quot;75%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px; margin-bottom: 3px;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:orange; display: inline-block; color: #777; font-size: 90%; padding: 1px;&quot;</span>&gt;</span></span><br><span class="line">        此处插入标题</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><hr><p><em>此为原作者文章链接格式：</em></p><style>table th:first-of-type {    width: 16%;}table th:nth-of-type(2) {    width: 16%;}table th:nth-of-type(3) {    width: 68%;}</style><table><thead><tr><th align="center">美化方式</th><th align="center">效果图</th><th>链接格式</th></tr></thead><tbody><tr><td align="center">控制大小</td><td align="center"><div align="center" ><img src="https://fastly.jsdelivr.net/gh/wlchenGG/myPictureBed@main/images/wallpaper19.jpg" alt="wallpaper19" width="120"/></div></td><td><code>&lt;div align=&quot;center&quot; &gt;&lt;img src=&quot;$url&quot; alt=&quot;$fileName&quot; width=&quot;75%&quot;/&gt;&lt;/div&gt;</code></td></tr><tr><td align="center">圆角处理</td><td align="center"><div align="center" ><img src="https://fastly.jsdelivr.net/gh/wlchenGG/myPictureBed@main/images/wallpaper19.jpg" alt="wallpaper19" width="120" style="border-radius:10px;"/></div></td><td><code>&lt;div align=&quot;center&quot; &gt;&lt;img src=&quot;$url&quot; alt=&quot;$fileName&quot; width=&quot;75%&quot; style=&quot;border-radius:10px;&quot;/&gt;&lt;/div&gt;</code></td></tr><tr><td align="center">图片阴影</td><td align="center"><div align="center" ><img src="https://fastly.jsdelivr.net/gh/wlchenGG/myPictureBed@main/images/wallpaper19.jpg" alt="wallpaper19" width="120" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);"/></div></td><td><code>&lt;div align=&quot;center&quot; &gt;&lt;img src=&quot;$url&quot; alt=&quot;$fileName&quot; width=&quot;75%&quot; style=&quot;box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);&quot;/&gt;&lt;/div&gt;</code></td></tr><tr><td align="center">阴影+圆角</td><td align="center"><div align="center" ><img src="https://fastly.jsdelivr.net/gh/wlchenGG/myPictureBed@main/images/wallpaper19.jpg" alt="wallpaper19" width="120" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div></td><td><code>&lt;div align=&quot;center&quot; &gt;&lt;img src=&quot;$url&quot; alt=&quot;$fileName&quot; width=&quot;75%&quot; style=&quot;box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;&quot;/&gt;&lt;/div&gt;</code></td></tr><tr><td align="center">阴影+标题</td><td align="center"><div align="center" ><img src="https://fastly.jsdelivr.net/gh/wlchenGG/myPictureBed@main/images/wallpaper19.jpg" alt="wallpaper19" width="120" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);"/><br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #777; font-size: 90%; padding: 1px;">此处插入标题</div></div></td><td><code>&lt;div align=&quot;center&quot; &gt;&lt;img src=&quot;$url&quot; alt=&quot;$fileName&quot; width=&quot;75%&quot; style=&quot;box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);&quot;/&gt;&lt;br&gt;&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #777; font-size: 90%; padding: 1px;&quot;&gt;此处插入标题&lt;/div&gt;&lt;/div&gt;</code></td></tr><tr><td align="center">圆角+标题</td><td align="center"><div align="center" ><img src="https://fastly.jsdelivr.net/gh/wlchenGG/myPictureBed@main/images/wallpaper19.jpg" alt="wallpaper19" width="120" style="border-radius:10px;"/><br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #777; font-size: 90%; padding: 1px;">此处插入标题</div></div></td><td><code>&lt;div align=&quot;center&quot; &gt;&lt;img src=&quot;$url&quot; alt=&quot;$fileName&quot; width=&quot;75%&quot; style=&quot;border-radius:10px;&quot;/&gt;&lt;br&gt;&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #777; font-size: 90%; padding: 1px;&quot;&gt;此处插入标题&lt;/div&gt;&lt;/div&gt;</code></td></tr><tr><td align="center">阴影+圆角+标题</td><td align="center"><div align="center" ><img src="https://fastly.jsdelivr.net/gh/wlchenGG/myPictureBed@main/images/wallpaper19.jpg" alt="wallpaper19" width="120" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/><br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #777; font-size: 90%; padding: 1px;">此处插入标题</div></div></td><td><code>&lt;div align=&quot;center&quot; &gt;&lt;img src=&quot;$url&quot; alt=&quot;$fileName&quot; width=&quot;75%&quot; style=&quot;box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;&quot;/&gt;&lt;br&gt;&lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #777; font-size: 90%; padding: 1px;&quot;&gt;此处插入标题&lt;/div&gt;&lt;/div&gt;</code></td></tr></tbody></table><p>其中</p><blockquote><ul><li><strong>width&#x3D;”75%”：</strong>控制图片大小，百分比是占整个文档宽度的比例（方便适配不同网页大小），也可以直接写成<code>width=&quot;300&quot;</code>等整数用来控制图片的绝对大小。</li><li><strong>border-radius:10px：</strong>用来控制圆角大小。</li><li><strong>此处插入标题：</strong>为图片设置标题。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列——之二</title>
      <link href="/posts/41925/"/>
      <url>/posts/41925/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>参考：</p><blockquote><ul><li><em><a href="https://blog.csdn.net/liyuanyue2017/article/details/83688306">（CSDN）浙大版数据结构（四）队列</a></em></li><li><em><a href="https://github.com/CodePanda66/CSPostgraduate-408/tree/master">（GitHub）CSPostgraduate-408-王道</a></em></li><li><em><a href="https://blog.csdn.net/qq_55593227/article/details/123598044">（CSDN）王道数据结构学习笔记</a></em></li><li><em><a href="https://www.iloveflag.com/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0">（iloveflag’s blog）数据结构-王道考研复习笔记</a></em></li></ul></blockquote><p>前情提要：</p><blockquote><ul><li><em><a href="https://akari2333.github.io/posts/13537/">队列（循环队列）—— 线性结构的应用之一 | Akari的小站</a></em></li><li><em><a href="https://akari2333.github.io/posts/7017/">队列（链式队列）—— 线性结构的应用之一 | Akari的小站</a></em></li></ul></blockquote><hr><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><p><strong>队列（Queue）</strong>：具有一定操作约束的线性表，线性结构的两种常见应用之一，是一种可以实现”先进先出”的存储结构，类似于人排队买票。</p><blockquote><ul><li>插入和删除操作：只能在一端（front）插入，而在另一端（rear）删除</li><li>数据插入：入队列（AddQ）</li><li>数据删除：出队列（DeleteQ）</li><li>先进先出：FIFO</li></ul></blockquote><h1 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h1><blockquote><ol><li>静态队列：用数组实现 <strong>静态队列通常都必须是循环队列</strong></li><li>链式队列：用链表实现 （比较简单）</li></ol></blockquote><h1 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h1><p>所有和时间有关的事件都有队列的影子。</p><h1 id="4-学习循环队列需弄清楚的-7-个问题"><a href="#4-学习循环队列需弄清楚的-7-个问题" class="headerlink" title="4. 学习循环队列需弄清楚的 7 个问题"></a>4. 学习<code>循环队列</code>需弄清楚的 7 个问题</h1><p>静态队列通常都必须是循环队列，为了减少内存浪费。<br>循环队列的讲解：</p><blockquote><ol><li>静态队列为什么必须是循环队列</li><li>循环队列需要几个参数来确定</li><li>循环队列各个参数的含义</li><li>循环队列入队伪算法讲解</li><li>循环队列出队伪算法讲解</li><li>如何判断循环队列是否为空</li><li>如何判断循环队列是否已满</li></ol></blockquote><ol><li><p>静态队列为什么必须是循环队列：</p> <img src="https://picst.sunbangyan.cn/2024/01/04/d89740afd2d59b0381bfa4fd7d3cc70e.jpeg" alt="1" /><p> 如图，现在如果一个数组里面存了四个元素，一开始 <strong>队头 front</strong> 就指向第一个有效元素，而 <strong>队尾 real</strong> 指向最后一个元素的下一个元素。</p><blockquote><ul><li><p>如果进行出队操作，先进先出，则从队头 front 开始先出，假如出队到数组下标为 2 的元素位置，此位置变成了队头 front，那么数组下标为 0&#x2F;1 的元素内存被释放。<strong>出队后的数组元素内存无法重新入队，因为入队是从队尾 rear 开始，不能从队头 front 之前进行入队，而且数组中入队操作达到数组最大下标后，就无法入队操作。同理出队到数组最大下标，也无法出队操作，数组卡死，所以对静态队列必须使用循环队列来提高数组的利用率。</strong></p></li><li><p>如果要删除元素（出队），front 只能加(往数组最大下标方向增加)；如果要增加元素（入队），rear 只能加(往数组最大下标方向增加)。（按照一般数组的方法）。rear 指向当前队列的下一个位置。 队尾 rear 类似于<code>链表创建(尾插法)和链表遍历算法的演示</code> 中 <code>PNODE create_list(void)</code>此函数中的PNODE pTail 指向尾节点</p></li></ul></blockquote><p> 也就是说：</p><blockquote><ul><li><p>当<strong>增加元素</strong>时，只能在 rear 一端增加，即 rear 向上移。<strong>删除元素</strong>时，只能在 front 一端删除元素，即 front 向上移。</p></li><li><p>但是如果一直增增删删，那么就会造成 rear 端溢出，而 front 端浪费，所以对于这种情况，可以采用循环队列的形式，即当 rear 已经指向数组最后一个元素时，那么就可以转而将 rear 指向数组的第一个空出来的空间。</p></li></ul></blockquote></li><li><p>循环队列需要几个参数来确定<br> 需要 2 个参数来确定：front 和 rear</p></li><li><p>循环队列各个参数的含义：<br> 2 个参数在不同场合有不同的含义</p><blockquote><ol><li>队列初始化<br> front 和 rear 的值相等，均为 0</li><li>队列非空<br> front 代表的是队列的第一个元素<br> rear 代表的是队列的最后一个有效元素的下一个元素</li><li>队列空<br> front 和 rear 的值相等，但不一定为 0</li></ol></blockquote></li><li><p>循环队列入队伪算法讲解：<br> 准备工作：</p><blockquote><ol><li>入队前要先判断 rear 的位置，因为 rear 有可能正指向数组最后一个元素，所以 rear + 1 就越界了。</li><li>如何知道 rear 是否快越界了：rear + 1 后对整个数组长度求余数(%)，余数为 0，则 rear + 1 处于最后一个数组元素位置，即将越界。</li></ol></blockquote><p> 两步完成：</p><blockquote><ol><li>将值存入rear 所代表的位置</li><li>错误的写法：rear &#x3D; rear + 1;<br>正确的写法是：<strong>rear &#x3D; (rear+1) % 数组的长度</strong></li></ol></blockquote></li><li><p>循环队列出队伪算法讲解：<br> 同入队的伪算法一样：<br> <strong>front &#x3D;（front + 1）% 数组的长度</strong></p></li><li><p>如何判断循环队列是否为空：<br> <strong>front &#x3D;&#x3D; rear。</strong><br> 即如果 front 与 rear 的值相等，则该队列就一定为空。</p></li><li><p>如何判断循环队列是否已满：</p> <img src="https://picdl.sunbangyan.cn/2024/01/05/6ed436deed351af3430f4f41eeff760f.jpeg" alt="6" style="zoom:100%"/><p> 已知：上图中 front 的值和 rear 的值没有规律，即可以大(3&gt;1)，小(0&lt;4)，等(f&#x3D;r)。<br> 刚开始 f&#x3D;r 一定为空，那么之后经过一个循环后又 r&#x3D;f 了，但此时 r&#x3D;f 为满，即不能通过 r&#x3D;f 这个条件来判断其既是空又是满。所以必须通过 f和r 的其他关系来判断其为满。</p><p> 所以有两种方式:</p><blockquote><ol><li>多增加一个标识是否满的参数(但每次对队列进行操作这个标志参数都要更新，浪费系统资源)</li><li>少用一个元素 <strong>【通常用此种方式】</strong><br>  如果 front和rear 的值相差 1，且 front&gt;rear，则证明队列已满。</li></ol></blockquote><p> 用 C 语言伪算法表示为：</p><blockquote><p><strong>if ((rear+1)%数组长度&#x3D;&#x3D;front)<br> &emsp;&emsp;已满<br> else<br> &emsp;&emsp;未满</strong></p></blockquote> <img src="https://picss.sunbangyan.cn/2024/01/05/6f98de33bb4fce96496da94fd59937b3.jpeg" alt="7" style="zoom:100%"/></li></ol><h1 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h1><h2 id="5-1-静态队列（循环队列）"><a href="#5-1-静态队列（循环队列）" class="headerlink" title="5.1 静态队列（循环队列）"></a>5.1 静态队列（循环队列）</h2><p>关于 <code>Init(QUEUE* pQ)</code> 的内存分配方式：有 2 种(不过没什么区别感觉)</p><ol><li><p>malloc</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pQ-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* MaxSize);   <span class="comment">// 长度为 MaxSize 个元素的数组</span></span><br></pre></td></tr></table></figure></li><li><p>static</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态分配，不使用动态内存分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticArray[MaxSize];</span><br><span class="line">pQ-&gt;pBase = staticArray;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-1-1-C——郝斌老师"><a href="#5-1-1-C——郝斌老师" class="headerlink" title="5.1.1 C——郝斌老师"></a>5.1.1 C——郝斌老师</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-05 17:15:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 20  <span class="comment">// 队列最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    <span class="type">int</span>* pBase;</span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队头下标</span></span><br><span class="line">    <span class="type">int</span> rear;   <span class="comment">// 队尾下标</span></span><br><span class="line">&#125;QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(QUEUE* pQ)</span>;   <span class="comment">// 初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Enter</span><span class="params">(QUEUE* pQ, <span class="type">int</span> val)</span>; <span class="comment">// 入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Out</span><span class="params">(QUEUE* pQ, <span class="type">int</span>* pVal)</span>; <span class="comment">// 出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Full</span><span class="params">(QUEUE* pQ)</span>;    <span class="comment">// 是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Empty</span><span class="params">(QUEUE* pQ)</span>;   <span class="comment">// 是否为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(QUEUE* pQ)</span>;   <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    Init(&amp;Q);</span><br><span class="line">    Enter(&amp;Q, <span class="number">1</span>);</span><br><span class="line">    Enter(&amp;Q, <span class="number">2</span>);</span><br><span class="line">    Enter(&amp;Q, <span class="number">3</span>);</span><br><span class="line">    Enter(&amp;Q, <span class="number">4</span>);</span><br><span class="line">    Enter(&amp;Q, <span class="number">5</span>);</span><br><span class="line">    Traverse(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pVal;</span><br><span class="line">    <span class="keyword">if</span> ( Out(&amp;Q, &amp;pVal) )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队成功！\n出队的元素是：%d\n&quot;</span>, pVal);</span><br><span class="line">    Traverse(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(QUEUE* pQ)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 静态分配，不使用动态内存分配</span></span><br><span class="line"><span class="comment">       static int staticArray[MaxSize];</span></span><br><span class="line"><span class="comment">       pQ-&gt;pBase = staticArray;*/</span></span><br><span class="line">    pQ-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * MaxSize);   <span class="comment">// 长度为 MaxSize 个元素的数组</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == pQ-&gt;pBase )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pQ-&gt;front = <span class="number">0</span>;  <span class="comment">// 队头下标为 0</span></span><br><span class="line">        pQ-&gt;rear = <span class="number">0</span>;   <span class="comment">// 队尾下标为 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Enter</span><span class="params">(QUEUE* pQ, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Is_Full(pQ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pQ-&gt;pBase[pQ-&gt;rear] = val;  <span class="comment">// 从队尾开始，数据入队</span></span><br><span class="line">        pQ-&gt;rear = (pQ-&gt;rear + <span class="number">1</span>) % MaxSize;    <span class="comment">// 队尾 rear 加 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Out</span><span class="params">(QUEUE* pQ, <span class="type">int</span>* pVal)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Is_Empty(pQ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *pVal = pQ-&gt;pBase[pQ-&gt;front];   <span class="comment">// 从 front 开始出队</span></span><br><span class="line">        pQ-&gt;front = (pQ-&gt;front + <span class="number">1</span>) % MaxSize;  <span class="comment">// 获取新的队头</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  队列满时 rear/front 紧挨着，由于是循环所以对数组长度取余，</span></span><br><span class="line"><span class="comment">  且 rear 是最后一个有效元素的下一个元素，</span></span><br><span class="line"><span class="comment">  rear 指向的元素是空起来不使用的，空一元素判断队满。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Full</span><span class="params">(QUEUE* pQ)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (pQ-&gt;rear + <span class="number">1</span>) % MaxSize == pQ-&gt;front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Empty</span><span class="params">(QUEUE* pQ)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (pQ-&gt;front == pQ-&gt;rear) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(QUEUE* pQ)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pQ-&gt;front;          <span class="comment">// 获取队头，从队头开始出队</span></span><br><span class="line">    <span class="keyword">while</span> ( i != pQ-&gt;rear )&#123;    <span class="comment">// 是否出队到队尾</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pQ-&gt;pBase[i]);</span><br><span class="line">        i = (i + <span class="number">1</span>) % MaxSize;  <span class="comment">// 通过空一个元素不使用，判断是否到队尾，front+1 后对数组长度取余</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-C——浙大数据结构"><a href="#5-1-2-C——浙大数据结构" class="headerlink" title="5.1.2 C——浙大数据结构"></a>5.1.2 C——浙大数据结构</h3><blockquote><p><em><a href="https://blog.csdn.net/liyuanyue2017/article/details/83688306">（浙大版）数据结构（四）队列</a></em></p></blockquote><ul><li><p><strong>fprintf 函数</strong><br>  <strong>fprintf</strong> 是 C 语言中的一个函数，用于将格式化的数据写入到文件流中。具体来说，fprintf 的函数原型：</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>stream</strong> 是一个指向文件流的指针，表示数据将被写入到哪个文件流中。在上述代码中，使用的是 stderr，它代表标准错误流。</li><li><strong>format</strong> 是一个字符串，包含了格式化输出的控制字符和要输出的数据。</li><li><strong>…</strong> 表示可变数量的参数，即要写入的数据。</li></ul></blockquote><p>  示例：</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用了 fprintf 来将字符串 &quot;内存分配失败&quot; 写入到标准错误流中。</span></span><br><span class="line"><span class="comment">//这是一种报告错误的方式，通常用于指示程序在运行时遇到了问题。     </span></span><br><span class="line">Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == Q )&#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>**fprintf(stderr, “内存分配失败\n”)**：使用 <strong>fprintf</strong> 函数将错误消息写入标准错误流 <strong>(stderr)<strong>。</strong>stderr</strong> 是一个专门用于输出错误信息的流，与标准输出 <strong>(stdout)</strong> 区分开来。在这里，用于将错误消息输出到屏幕上。</p></li><li><p><strong>exit(EXIT_FAILURE)<strong>：</strong>exit</strong> 函数用于终止程序的执行。<strong>EXIT_FAILURE</strong> 是一个宏，表示程序以失败的状态退出。这是一个标准的返回代码，用于表示程序没有成功执行。</p></li></ul></blockquote></li></ul><p>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量 front 以及一个记录队列尾元素位置的变量 rear 组成，其中 front 指向整个队列的头一个元素的再前一个，rear 指向的是整个队列的最后一个元素，从 rear 入队，从 front 出队，且仅使用 n-1 个数组空间。</p><hr><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-08 11:39:47</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;    <span class="comment">// 假定是int类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front;   <span class="comment">// 记录队头</span></span><br><span class="line">    <span class="type">int</span> rear;    <span class="comment">// 记录队尾</span></span><br><span class="line">&#125;*Queue;</span><br><span class="line"></span><br><span class="line">Queue <span class="title function_">createQueue</span><span class="params">()</span>;    <span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addQ</span><span class="params">(Queue Q, ElementType e)</span>;  <span class="comment">// 入队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue Q)</span>;    <span class="comment">// 判断队列是否已满</span></span><br><span class="line">ElementType <span class="title function_">deleteQ</span><span class="params">(Queue Q)</span>;       <span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue Q)</span>;   <span class="comment">// 判断队列是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Q = createQueue();</span><br><span class="line">    </span><br><span class="line">    addQ(Q, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1入队\n&quot;</span>);</span><br><span class="line">    addQ(Q, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2入队\n&quot;</span>);</span><br><span class="line">    addQ(Q, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3入队\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d出队\n&quot;</span>, deleteQ(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d出队\n&quot;</span>, deleteQ(Q));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Queue <span class="title function_">createQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == Q )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;front = <span class="number">-1</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否已满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q-&gt;rear + <span class="number">1</span>) % MaxSize == Q-&gt;front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addQ</span><span class="params">(Queue Q, ElementType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( isFull(Q) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;rear] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q-&gt;rear == Q-&gt;front));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">ElementType <span class="title function_">deleteQ</span><span class="params">(Queue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( isEmpty(Q) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">        <span class="keyword">return</span> Q-&gt;Data[Q-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-C-——王道"><a href="#5-1-3-C-——王道" class="headerlink" title="5.1.3 C++——王道"></a>5.1.3 C++——王道</h3><blockquote><ul><li><em><a href="https://blog.csdn.net/qq_55593227/article/details/123598044">数据结构学习笔记（王道）</a></em></li><li><em><a href="https://www.iloveflag.com/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0">数据结构-王道考研复习笔记 · iloveflag’s Blog</a></em></li><li><em><a href="https://github.com/CodePanda66/CSPostgraduate-408/blob/master/DataStructure/Src/DS_2_StackAndQueue/DS_2_3_SqQueue0.cpp">CSPostgraduate-408&#x2F;DataStructure&#x2F;Src&#x2F;DS_2_StackAndQueue&#x2F;DS_2_3_SqQueue0.cpp</a></em></li></ul></blockquote><h4 id="5-1-3-1-C-引用"><a href="#5-1-3-1-C-引用" class="headerlink" title="5.1.3.1 C++ 引用"></a>5.1.3.1 C++ 引用</h4><blockquote><p><em>主要区别是使用了 C++ 的引用，而不是传递指针。 引用是 C++ 中的特性，允许在函数中修改传递的参数，而无需显式地使用指针</em></p></blockquote><ol><li><p>定义：<br> 在C++中，引用是一个别名，它提供了对变量的另一个名称。引用在C++中是通过使用 <strong>&amp;</strong> 符号进行声明和定义的。引用必须在初始化时被绑定到一个对象，而且一旦绑定，它将一直引用该对象。</p></li><li><p>基本语法：</p> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type &amp;refName = originalVariable;</span><br></pre></td></tr></table></figure><p> 其中，<strong>type</strong> 是原始变量的类型，<strong>refName</strong> 是引用的名称，<strong>originalVariable</strong> 是原始变量。引用的声明和初始化必须同时进行。</p></li><li><p>示例：</p> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">99</span>;  <span class="comment">// 修改引用，也会修改原始变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中：b 是 a 的引用，它们实际上指向同一个内存地址。因此，对 b 的修改也会影响到 a。</p></li><li><p>引用有一些重要的特性和规则：</p><blockquote><ol><li>引用必须在声明时初始化，而且一旦初始化，就无法改变引用的目标。</li><li>引用不占用额外的内存空间，它只是目标变量的另一个名字。</li><li>引用通常用于函数参数，允许在函数中直接操作原始变量，而不是其副本。</li><li>引用用于提供对对象的更直观、更自然的访问。</li></ol></blockquote><p> 引用在C++中广泛用于函数传递、返回引用值、操作符重载等场景。</p></li><li><p>引用和指针的异同：<br> 引用（Reference）和指针（Pointer）是 C++ 中两种用于引用和操作变量的机制，它们有相似之处，也有一些重要的区别。以下是引用和指针的异同点：</p></li></ol><p><strong>相同点：</strong></p><ol><li><strong>别名机制：</strong><br>引用和指针都提供了对变量的别名机制，可以通过它们来访问和操作变量。</li><li><strong>用于传递参数：</strong><br>引用和指针都可以用于函数参数，使得函数能够直接操作原始变量，而不是对变量的副本进行操作。</li><li><strong>用于修改变量值：</strong><br>通过引用或指针，可以修改原始变量的值，而不仅仅是传递它们的副本。</li></ol><p><strong>不同点：</strong></p><ol><li><strong>语法和操作：</strong><ul><li><strong>引用：</strong><ul><li>引用在声明时使用 &amp; 符号，例如 int &amp;ref &#x3D; variable;。</li><li>引用一旦初始化，就不能再引用其他变量，一直引用同一个对象。</li><li>引用不需要使用解引用操作符（*）来访问目标对象。</li><li>引用不能为 NULL，引用必须在初始化时指向一个有效的对象。</li></ul></li><li><strong>指针：</strong><ul><li>指针在声明时使用 * 符号，例如 int *ptr &#x3D; &variable;。</li><li>指针可以在任何时候重新指向其他对象。</li><li>使用解引用操作符（*）来访问目标对象。</li><li>指针可以为 NULL，即指向空地址，表示不指向任何有效的对象。</li></ul></li></ul></li><li><strong>内存占用：</strong><ul><li><strong>引用：</strong><ul><li>引用在内存中不占用额外的空间，它只是目标变量的别名。</li></ul></li><li><strong>指针：</strong><ul><li>指针需要占用额外的内存空间来存储变量的地址。</li></ul></li></ul></li><li><strong>空引用和空指针：</strong><ul><li><strong>引用：</strong><ul><li>引用在定义时必须初始化，不存在空引用的概念。</li></ul></li><li><strong>指针：</strong><ul><li>指针可以为 NULL，表示不指向任何有效的对象，称为空指针。</li></ul></li></ul></li><li><strong>操作符重载：</strong><ul><li>引用不支持操作符重载。</li><li>指针支持操作符重载，可以通过指针实现一些底层的操作。</li></ul></li><li><strong>适用场景：</strong><ul><li><strong>引用：</strong><ul><li>适用于不需要改变指向的情况，提供了更直观的语法。</li></ul></li><li><strong>指针：</strong><ul><li>适用于需要在运行时改变指向的情况，更灵活。</li></ul></li></ul></li><li><strong>访问对象成员：</strong><ul><li><strong>引用：</strong><ul><li>引用使用 <code>.</code><strong>点运算符</strong>访问对象的成员，因为引用本质上是一个别名，就是绑定到某个对象上的别名，它可以像对象本身一样访问成员。</li></ul></li><li><strong>指针:</strong><ul><li>当有一个指向结构体或类的指针时，使用<code>-&gt;</code><strong>箭头运算符</strong>来访问对象的成员。</li></ul></li></ul></li></ol><p>在选择使用引用还是指针时，取决于具体的场景和需求：<strong>通常情况下，引用更适用于作为函数参数传递，而指针更适用于需要动态分配内存、在运行时改变指向等场景。</strong></p><hr><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-08 12:22:10</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/**定义模块**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 用静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;    <span class="comment">// 队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(SqQueue &amp;Q)</span></span>; <span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span></span>;    <span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">(SqQueue Q)</span></span>;     <span class="comment">// 判满</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span></span>;   <span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span>; <span class="comment">// 出队，用 e 返回</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span>;  <span class="comment">// 获取队头元素，用 e 返回</span></span><br><span class="line"><span class="comment">/**定义模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printQueue</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**实现模块**/</span></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;   <span class="comment">// 初始化时，队头队尾都指向 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Q.rear == Q.front )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为满</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (Q.rear + <span class="number">1</span>) % MaxSize == Q.front )&#123;   <span class="comment">// 牺牲一个单元区分队空和队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果队列已满直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isFull</span>(Q) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;    <span class="comment">// 通过取余操作让整个队列循环起来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果队列为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**实现模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br><span class="line"><span class="comment">// 打印整个队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始打印队列\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ( Q.front != Q.rear )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Q.data[Q.front]);</span><br><span class="line">        Q.front = (Q.front + <span class="number">1</span>) % MaxSize;  <span class="comment">// 输出后更新下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结束打印\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始测试\n&quot;</span>);</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">initQueue</span>(Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">1</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功！\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">2</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功！\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">3</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功！\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printQueue</span>(Q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">outQueue</span>(Q, e) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队成功，弹出的元素是：%d\n&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">getHead</span>(Q, e) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取队头成功！队头元素是：%d\n&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取队头失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队非空\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结束测试\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br></pre></td></tr></table></figure><h2 id="5-2-链式队列"><a href="#5-2-链式队列" class="headerlink" title="5.2 链式队列"></a>5.2 链式队列</h2><h3 id="5-2-0-头结点有无与否"><a href="#5-2-0-头结点有无与否" class="headerlink" title="5.2.0 头结点有无与否"></a>5.2.0 头结点有无与否</h3><p>在链式队列中，是否使用头结点<strong>主要影响链表的头指针和尾指针的处理方式</strong>。</p><ol><li><p><strong>带头结点的链式队列：</strong></p><blockquote><ul><li><strong>头结点存在：</strong> 链表中会额外添加一个头结点，头结点的 Next 指针指向队列的头元素，而尾指针指向队列的尾元素。这样，头结点的存在使得链表中的每个节点都有一个前驱节点。</li><li><strong>操作方便：</strong> 在插入和删除操作时，无需特殊处理头节点的情况，简化了代码逻辑。</li><li><strong>判空方便：</strong> 判断队列是否为空可以通过检查头结点的 Next 指针是否为空来实现。</li></ul></blockquote></li><li><p><strong>不带头结点的链式队列：</strong></p><blockquote><ul><li><strong>头结点不存在：</strong> 链表的头指针直接指向队列的头元素，而尾指针指向队列的尾元素。链表中的第一个节点即为队列的头元素。</li><li><strong>操作需特殊处理：</strong> 在插入和删除操作时，需要特殊处理头节点的情况，因为头节点和其他节点的处理方式不同。</li><li><strong>判空需特殊处理：</strong> 判断队列是否为空通常需要检查头指针和尾指针是否相等，因为没有头结点来帮助判断。</li></ul></blockquote></li></ol><p>选择是否使用头结点主要取决于具体的设计需求和实现偏好。<br>带头结点的链表在某些情况下（<strong>适用于对插入和删除操作的简洁性有较高要求的情况</strong>）对边界情况的处理上更加方便，可以使代码更加简洁；而不带头结点的链表（<strong>适用于对内存占用比较敏感的情况，且可以接受插入和删除操作的代码逻辑稍微复杂一些</strong>）更接近实际队列的逻辑。</p><h3 id="5-2-1-C-——郝斌老师"><a href="#5-2-1-C-——郝斌老师" class="headerlink" title="5.2.1 C++——郝斌老师"></a>5.2.1 C++——郝斌老师</h3><h4 id="5-2-1-1-Clear"><a href="#5-2-1-1-Clear" class="headerlink" title="5.2.1.1 Clear();"></a>5.2.1.1 Clear();</h4><p><strong>错误写法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>( !<span class="keyword">this</span>-&gt;<span class="built_in">isEmpty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">outQueue</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确写法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Out_Queue</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要使用循环：在每次调用 Out_Queue 之后，函数内部已经包含了循环的逻辑。只要队列不为空，就会一直执行出队操作。因此，在 Clear_Queue 中只需调用一次 Out_Queue 即可达到清空队列的目的。</p><h4 id="5-2-1-2-Queue"><a href="#5-2-1-2-Queue" class="headerlink" title="5.2.1.2 ~Queue();"></a>5.2.1.2 ~Queue();</h4><p><strong>错误写法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">Queue</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确写法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">Queue</span>()&#123;</span><br><span class="line">    <span class="built_in">Clear</span>();</span><br><span class="line">    <span class="keyword">delete</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>在析构函数中不需要显式调用 this-&gt;Clear()，因为析构函数会在对象销毁时自动调用。</em></p><p>在C++中，<strong>类的析构函数（Destructor）</strong>是一个特殊的成员函数，它在对象被销毁时自动调用。析构函数的作用是释放对象占用的资源，执行清理工作。</p><p>在示例代码中，析构函数的主要目的是清理队列，即释放队列中节点所占用的内存。已经定义了 <strong>Clear</strong> 函数来完成这个清理工作，所以在析构函数中调用 <strong>Clear</strong> 是合理的。</p><p>然而，<strong>根据C++的析构函数自动调用机制</strong>，如果析构函数中没有显式调用 <strong>Clear</strong>，对象销毁时也会自动调用 <strong>Clear</strong>，因为 <strong>Clear</strong> 包含了释放队列中节点内存的逻辑。</p><p>所以，可以不在析构函数中显式调用 <strong>Clear</strong>，而是依赖析构函数自动调用它。这样的做法更加简洁，因为析构函数的主要职责是清理资源，而 <strong>Clear</strong> 已经负责了这部分工作。</p><hr><p><strong>带头结点。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-08 20:05:37</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带头结点版本。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *pNext;</span><br><span class="line">&#125;NODE, *PNODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PNODE pHead, pTail; <span class="comment">// pHead指向无用的头结点 pHead-&gt;pNext才是指向队首元素, pTail指向队尾元素</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Queue</span>() : <span class="built_in">pHead</span>(<span class="keyword">new</span> NODE), <span class="built_in">pTail</span>(pHead)&#123;    <span class="comment">// 在构造函数中使用初始化列表</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;pHead-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数：在对象被销毁时自动调用</span></span><br><span class="line">    ~<span class="built_in">Queue</span>()&#123;</span><br><span class="line">        <span class="built_in">Clear</span>();</span><br><span class="line">        <span class="keyword">delete</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历队列元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traverse</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>() )&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列为空，无法遍历！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        PNODE pTemp = <span class="keyword">this</span>-&gt;pHead-&gt;pNext;</span><br><span class="line">        <span class="keyword">while</span> ( pTemp != <span class="literal">nullptr</span> )&#123;</span><br><span class="line">            cout &lt;&lt; pTemp-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            pTemp = pTemp-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">// 简化返回语句</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;pHead == <span class="keyword">this</span>-&gt;pTail);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        PNODE pNew = <span class="keyword">new</span> NODE;</span><br><span class="line">        pNew-&gt;data = val;</span><br><span class="line">        pNew-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>-&gt;pTail-&gt;pNext = pNew;  <span class="comment">// 将pNew挂到队列尾部</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;pTail = pNew; <span class="comment">// 注意是尾指针上移</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outQueue</span><span class="params">(<span class="type">int</span> &amp;val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>() )&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列为空，无法出队！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PNODE pTemp = <span class="keyword">this</span>-&gt;pHead-&gt;pNext;   <span class="comment">//pHead不是要删除的队首元素，pHead-&gt;pNext所指向的元素才是要删除的元素</span></span><br><span class="line">        val = pTemp-&gt;data;  <span class="comment">// 保存出队元素</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;pHead-&gt;pNext = pTemp-&gt;pNext;  <span class="comment">// 更新首节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> pTemp;</span><br><span class="line">        pTemp = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == <span class="keyword">this</span>-&gt;pHead-&gt;pNext)&#123;  <span class="comment">// 如果队列为空</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;pTail = <span class="keyword">this</span>-&gt;pHead;       <span class="comment">// 尾指针要指向无用的头结点，则将 pTail 移回 pHead</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空队列</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="built_in">outQueue</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )&#123;</span><br><span class="line">        Q.<span class="built_in">enQueue</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.<span class="built_in">Traverse</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> ( Q.<span class="built_in">outQueue</span>(val) )&#123; <span class="comment">// 用引用代替&amp;val</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;出队成功，出队的元素是: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;出队失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Q.<span class="built_in">Traverse</span>();</span><br><span class="line">    </span><br><span class="line">    Q.<span class="built_in">Clear</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-C——浙大数据结构"><a href="#5-2-2-C——浙大数据结构" class="headerlink" title="5.2.2 C——浙大数据结构"></a>5.2.2 C——浙大数据结构</h3><blockquote><p><em><a href="https://blog.csdn.net/liyuanyue2017/article/details/83688306">CSDN——数据结构（四）队列</a></em></p></blockquote><p><strong>不带头结点。</strong></p><p>​队列的链式存储结构也可以用一个单链表实现。插入和删除操作分别在链表的两头进行，front 在链表头，rear 在链表尾，从 rear 入队，从 front 出队。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-08 21:55:20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列（不带带头节点版本）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span>  <span class="comment">// 指向队尾结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span> <span class="comment">// 指向队头结点</span></span><br><span class="line">&#125;*Queue;</span><br><span class="line"></span><br><span class="line">Queue <span class="title function_">createQueue</span><span class="params">()</span>;    <span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addQueue</span><span class="params">(Queue Q, ElemType e)</span>; <span class="comment">// 入队</span></span><br><span class="line">ElemType <span class="title function_">deleteQueue</span><span class="params">(Queue Q)</span>;  <span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue Q)</span>;   <span class="comment">// 判空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Q = createQueue();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;入队 5\n&quot;</span>);</span><br><span class="line">    addQueue(Q,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;入队 4\n&quot;</span>);</span><br><span class="line">    addQueue(Q,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;入队 3\n&quot;</span>);</span><br><span class="line">    addQueue(Q,<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队 %d\n&quot;</span>, deleteQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队 %d\n&quot;</span>, deleteQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队 %d\n&quot;</span>, deleteQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, deleteQueue(Q));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue <span class="title function_">createQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">    Q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q-&gt;front == <span class="literal">NULL</span> ); <span class="comment">// 头结点为空时队空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addQueue</span><span class="params">(Queue Q, ElemType e)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    </span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == Q-&gt;front )&#123;</span><br><span class="line">        <span class="comment">// 不带头节点插入第一个元素时，需做特殊处理</span></span><br><span class="line">        Q-&gt;rear = Q-&gt;front = p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非第一个元素</span></span><br><span class="line">        Q-&gt;rear-&gt;Next = p;  <span class="comment">// 新节点插入到 rear 之后</span></span><br><span class="line">        Q-&gt;rear = p;        <span class="comment">// 修改尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">deleteQueue</span><span class="params">(Queue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( isEmpty(Q) )&#123;      <span class="comment">// 即 Q.front == NULL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列空 &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span> =</span> Q-&gt;front;  <span class="comment">// 用指针 p 记录队头</span></span><br><span class="line">    ElemType x = p-&gt;data;       <span class="comment">// 用 x 返回队头元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不带头节点最后一个节点出队时，需做特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> ( Q-&gt;rear == p )&#123;</span><br><span class="line">        Q-&gt;rear = Q-&gt;front = <span class="literal">NULL</span>;  <span class="comment">// 修改 rear 指针为空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;front = p-&gt;Next; <span class="comment">// 队头指向下一个队头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-3-C-——王道"><a href="#5-2-3-C-——王道" class="headerlink" title="5.2.3 C++——王道"></a>5.2.3 C++——王道</h3><blockquote><ul><li><em><a href="https://blog.csdn.net/qq_55593227/article/details/123598044">数据结构学习笔记（王道）</a></em></li><li><em><a href="https://www.iloveflag.com/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0">数据结构-王道考研复习笔记 · iloveflag’s Blog</a></em></li><li><em><a href="https://github.com/CodePanda66/CSPostgraduate-408/blob/master/DataStructure/Src/DS_2_StackAndQueue/DS_2_3_SqQueue0.cpp">CSPostgraduate-408&#x2F;DataStructure&#x2F;Src&#x2F;DS_2_StackAndQueue&#x2F;DS_2_3_SqQueue0.cpp</a></em></li></ul></blockquote><p><strong>带头结点。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-08 21:55:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列（带头结点版本）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**定义模块**/</span></span><br><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *Next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear; <span class="comment">// 头指针和尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>;   <span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(LinkQueue &amp;Q, <span class="type">int</span> x)</span></span>;  <span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(LinkQueue &amp;Q, <span class="type">int</span> &amp;x)</span></span>; <span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getHead</span><span class="params">(LinkQueue Q, <span class="type">int</span> &amp;x)</span></span>;  <span class="comment">// 获取头元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQueue Q)</span></span>;      <span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>;  <span class="comment">// 清空</span></span><br><span class="line"><span class="comment">/**定义模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**实现模块**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> ( Q.front == <span class="literal">nullptr</span> )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front-&gt;Next = <span class="literal">nullptr</span>;    <span class="comment">// 初始化时，front、rear 都指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(LinkQueue &amp;Q, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判满？链式存储一般不需要判满，除非内存不足</span></span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> ( s == <span class="literal">nullptr</span> )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;Next = <span class="literal">nullptr</span>;</span><br><span class="line">    Q.rear-&gt;Next = s;   <span class="comment">// 新节点插入到 rear 之后</span></span><br><span class="line">    Q.rear = s;     <span class="comment">// 更新尾指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(LinkQueue &amp;Q, <span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LinkNode *p = Q.front-&gt;Next;    <span class="comment">// 指针p 记录队头元素</span></span><br><span class="line">    x = p-&gt;data;    <span class="comment">// x 返回队头元素</span></span><br><span class="line">    Q.front-&gt;Next = p-&gt;Next;    <span class="comment">// 修改头节点的Next指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一个节点出队时</span></span><br><span class="line">    <span class="keyword">if</span> ( Q.rear == p )&#123;</span><br><span class="line">        Q.rear = Q.front;   <span class="comment">// 修改rear指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getHead</span><span class="params">(LinkQueue Q, <span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.front-&gt;Next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">deQueue</span>(Q, x) )&#123;</span><br><span class="line">        <span class="comment">// 依次出队，释放所有节点内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(Q.front);  <span class="comment">// 释放头结点内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**实现模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br><span class="line"><span class="comment">// 打印函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printQueue</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始打印\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    LinkNode *temp = Q.front-&gt;Next; <span class="comment">// 使用临时指针 temp，避免改变原视队列的状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( temp != Q.rear )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n打印完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testLinkQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始测试！\n&quot;</span>);</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">initQueue</span>(Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">1</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功 1\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">2</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功 2\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">3</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功 3\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printQueue</span>(Q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">deQueue</span>(Q, x) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队成功，弹出的元素是 %d\n&quot;</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">getHead</span>(Q, x) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取队头成功，队头元素是 %d\n&quot;</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取队头元素失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队非空\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">clearQueue</span>(Q);  <span class="comment">// 清理队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;测试结束！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testLinkQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈——之二</title>
      <link href="/posts/14941/"/>
      <url>/posts/14941/</url>
      
        <content type="html"><![CDATA[<p><em>前情提要：<a href="https://akari2333.github.io/posts/34532/">栈——线性结构的应用之一 | Akari的小站</a></em></p><hr><p><strong>堆栈：</strong></p><p>堆栈（Stack）：具有一定操作约束的线性表</p><blockquote><ul><li>只在一端（栈顶，Top）做插入、删除</li><li>插入数据：入栈（Push）</li><li>删除数据：出栈（Pop）</li><li>后入先出：Last In First Out（LIFO）</li></ul></blockquote><h1 id="一、栈的链式存储实现"><a href="#一、栈的链式存储实现" class="headerlink" title="一、栈的链式存储实现"></a>一、栈的链式存储实现</h1><p>​栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:</span></span><br><span class="line"><span class="comment"> * @version:</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-29 21:53:10</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 包含 malloc</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125;SNODE, * PSNODE;   <span class="comment">// 定义栈节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    PSNODE pTop;    <span class="comment">// 栈顶</span></span><br><span class="line">    PSNODE pBottom; <span class="comment">// 栈底</span></span><br><span class="line">&#125;STACK, * PSTACK;   <span class="comment">// 定义保存栈节点地址的栈指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(PSTACK)</span>;          <span class="comment">// 栈初始化，造出空栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(PSTACK, <span class="type">int</span>)</span>;     <span class="comment">// 压栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(PSTACK)</span>;      <span class="comment">// 遍历栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(PSTACK, <span class="type">int</span> *)</span>;    <span class="comment">// 出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(PSTACK)</span> ;      <span class="comment">// 栈是否空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(PSTACK)</span>;         <span class="comment">// 清除栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  <span class="comment">// 栈的链式存储结构</span></span><br><span class="line">&#123;</span><br><span class="line">    STACK S;</span><br><span class="line">    </span><br><span class="line">    Init(&amp;S);   <span class="comment">// 目的是造成一个空栈</span></span><br><span class="line">    Push(&amp;S, <span class="number">1</span>);</span><br><span class="line">    Push(&amp;S, <span class="number">2</span>);</span><br><span class="line">    Push(&amp;S, <span class="number">3</span>);</span><br><span class="line">    Push(&amp;S, <span class="number">4</span>);</span><br><span class="line">    Push(&amp;S, <span class="number">5</span>);</span><br><span class="line">    Traverse(&amp;S);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> ( Pop(&amp;S, &amp;val) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈成功！出栈的元素是：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Traverse(&amp;S);</span><br><span class="line">    </span><br><span class="line">    Clear(&amp;S);</span><br><span class="line">    Traverse(&amp;S);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(PSTACK pS)</span>&#123;</span><br><span class="line">    pS-&gt;pTop = (PSNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNODE));   <span class="comment">// 新建栈节点：头栈节点</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == pS-&gt;pTop )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pS-&gt;pBottom = pS-&gt;pTop;     <span class="comment">// 栈顶和栈底都指向指针域为空的头栈节点</span></span><br><span class="line">    pS-&gt;pTop-&gt;pNext = <span class="literal">NULL</span>;     <span class="comment">// 等价于：pS-&gt;pBottom-&gt;pNext = NULL; 头栈节点的指针域为 NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(PSTACK pS, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    PSNODE pNew = (PSNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNODE));</span><br><span class="line">    pNew-&gt;data = val;   <span class="comment">// 给栈节点中的数据赋值</span></span><br><span class="line">    pNew-&gt;pNext = pS-&gt;pTop; <span class="comment">// pS-&gt;Top 不能改成pS-&gt;pBpttom</span></span><br><span class="line">                            <span class="comment">// 栈节点的指针域保存下一个节点的地址</span></span><br><span class="line">    pS-&gt;pTop = pNew;    <span class="comment">// 更新栈顶：新的栈节点变成新的栈顶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(PSTACK pS)</span>&#123;</span><br><span class="line">    PSNODE p = pS-&gt;pTop;    <span class="comment">// 临时节点指向栈顶</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( p != pS-&gt;pBottom )&#123;     <span class="comment">// 是否遍历到栈底</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(PSTACK pS)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( pS-&gt;pTop == pS-&gt;pBottom )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  把pS所指向的栈顶出栈一次</span></span><br><span class="line"><span class="comment">  并把出栈的元素存入 pVal 形参所指向的变量中</span></span><br><span class="line"><span class="comment">  出栈失败返回 false，否则返回 true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(PSTACK pS, <span class="type">int</span> * pVal)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( IsEmpty(pS) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PSNODE r = pS-&gt;pTop;    <span class="comment">// 临时节点指向栈顶</span></span><br><span class="line">    *pVal = r-&gt;data;        <span class="comment">// 保存数据</span></span><br><span class="line">    pS-&gt;pTop = r-&gt;pNext;    <span class="comment">// 更新栈顶</span></span><br><span class="line">                            <span class="comment">// 等价于：pS-&gt;pTop = pS-&gt;Top-&gt;pNext;</span></span><br><span class="line">    <span class="built_in">free</span>(r);</span><br><span class="line">    r = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(PSTACK pS)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( IsEmpty(pS) )&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PSNODE r = pS-&gt;pTop;    <span class="comment">// r 指向栈顶</span></span><br><span class="line">    PSNODE q = <span class="literal">NULL</span>;        <span class="comment">// q 临时保存栈节点的地址</span></span><br><span class="line">    <span class="keyword">while</span> ( r != pS-&gt;pBottom )&#123; <span class="comment">// 是否遍历到栈底</span></span><br><span class="line">        q = r-&gt;pNext;   <span class="comment">// 栈节点的指针域（下一节点地址）临时保存在 q 中</span></span><br><span class="line">        <span class="built_in">free</span>(r);</span><br><span class="line">        r = q;          <span class="comment">// q 中的下一节点地址赋给 r ，准备循环释放下一节点内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    pS-&gt;pTop = pS-&gt;pBottom; <span class="comment">// 栈顶和栈底都指向指针域为空的头栈节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、栈的顺序存储实现"><a href="#二、栈的顺序存储实现" class="headerlink" title="二、栈的顺序存储实现"></a>二、栈的顺序存储实现</h1><p>栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:</span></span><br><span class="line"><span class="comment"> * @version:</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-01 20:59:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 20      <span class="comment">// 存储空间初始分配量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">// 存储堆栈元素</span></span><br><span class="line">    <span class="type">int</span> Top;    <span class="comment">// 记录栈顶元素下标 / 用于栈顶指针</span></span><br><span class="line">&#125;STACK;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(STACK *)</span>;         <span class="comment">// 栈初始化，造出空栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(STACK *, <span class="type">int</span>)</span>;    <span class="comment">// 压栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(STACK *)</span>;     <span class="comment">// 遍历栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(STACK *, <span class="type">int</span> *)</span>;   <span class="comment">// 出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(STACK *)</span> ; <span class="comment">// 栈是否空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(STACK *)</span>;       <span class="comment">// 栈是否满</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(STACK *)</span>;        <span class="comment">// 清除栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    STACK s;</span><br><span class="line">    </span><br><span class="line">    Init(&amp;s);</span><br><span class="line">    Push(&amp;s, <span class="number">1</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">2</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">3</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">4</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">5</span>);</span><br><span class="line">    Traverse(&amp;s);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> ( Pop(&amp;s, &amp;val) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈成功！出栈的元素是：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Traverse(&amp;s);</span><br><span class="line">    </span><br><span class="line">    Clear(&amp;s);</span><br><span class="line">    Traverse(&amp;s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(STACK *s)</span>&#123;</span><br><span class="line">    s-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(STACK *s, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( IsFull(s) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;Top++;</span><br><span class="line">        s-&gt;data[s-&gt;Top] = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(STACK *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( IsEmpty(s) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt;= s-&gt;Top; i++ )&#123;    <span class="comment">// Top 为栈顶元素，即数组下标所以是 &lt;=</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(STACK *s, <span class="type">int</span> *pVal)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( IsEmpty(s) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *pVal = s-&gt;data[s-&gt;Top];</span><br><span class="line">        s-&gt;Top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(STACK *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">-1</span> == s-&gt;Top )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(STACK *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( MaxSize - <span class="number">1</span> == s-&gt;Top )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(STACK *s)</span>&#123;</span><br><span class="line">    s-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、函数的形参STACK-s"><a href="#1、函数的形参STACK-s" class="headerlink" title="1、函数的形参STACK *s"></a>1、函数的形参<code>STACK *s</code></h2><ul><li>每个函数中形参都是STACK *s，有必要都用指针吗？因为这是以数组实现的栈</li></ul><blockquote><p>函数参数使用 STACK *s，即指向 STACK 结构体的指针。这是因为在 C 语言中，函数参数传递通常是通过值传递的——如果传递一个结构体，那么会复制整个结构体的内容，这可能引起性能上的开销。</p><p>虽然<strong>静态栈</strong>是基于数组实现的，而数组本身已经是一个指针，但传递 STACK *s 还是有好处的，因为可能需要在函数中修改 Top 指针，而不是只修改数组的内容。</p></blockquote><h2 id="2、指针的优劣"><a href="#2、指针的优劣" class="headerlink" title="2、指针的优劣"></a>2、指针的优劣</h2><ul><li><strong>指针的好处：</strong></li></ul><blockquote><ol><li>内存效率：<br>通过传递指针，避免了在函数调用时复制整个结构体的开销，尤其是当结构体很大时。</li><li>原地修改：<br>通过指针，可以在函数内部修改原始结构体，而不是修改传递给函数的副本。这对于栈这种需要修改状态的数据结构来说是很重要的。</li><li>一致性：<br>当使用指针传递结构体时，对结构体的修改会直接反映到调用者的结构体上，这有助于保持一致性。</li></ol></blockquote><ul><li><strong>指针的劣势：</strong></li></ul><blockquote><ol><li>复杂性： 指针的使用可能增加代码的复杂性，需要更小心地处理指针的引用、解引用等操作，以防止出现错误。</li><li>潜在的错误： 不正确使用指针可能导致内存错误，如空指针引用、越界等问题。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表——之二</title>
      <link href="/posts/12893/"/>
      <url>/posts/12893/</url>
      
        <content type="html"><![CDATA[<img src="https://picdm.sunbangyan.cn/2023/12/29/fc42dc46102c820f8214dc69e6800ba6.jpeg" alt="帽皇！！！" style="zoom:80%"/><blockquote><p><em><strong>世界属于帽皇！！！！！</strong></em> 😎😎😋😋😊😍🥰😘🥵🥵</p><p><em><strong>我很难想象精神状态正常的推子观众会做出“不爱有马加奈”这种选择。萝莉前辈丰富的可爱表情和小女友一般的心理活动可以说是所有角色中最有感觉的，没有之一。</strong></em> 🥵🥵<br><em><strong>看推子不爱帽皇，就像四大名著不看红楼梦，说明这个人文学造诣和自我修养不足，他整个人的层次就卡在这里了，只能度过一个相对失败的人生。</strong></em> 😎😎</p><p><em><strong>世界属于帽皇！！！！！</strong></em> 😎😎😋😋😊😍🥰😘🥵🥵</p></blockquote><hr><p>参考：<a href="https://blog.csdn.net/liyuanyue2017/article/details/83244310">线性表_数据结构(二)线性表</a> <del>从GitHub上找的</del><br>version：1.0——<a href="https://akari2333.github.io/posts/45748/">单链表 | Akari的小站</a></p><hr><p>这次的相比第一次修改了不少，主要是把 删除和插入 中的那一步操作抽象出来了，变成 <code>FindOrder</code>了。</p><p>完整程序如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief:</span></span><br><span class="line"><span class="comment"> * @version:</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-27 19:25:57</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数据结构（二） 线性表_数据结构(二)线性表-CSDN博客</span></span><br><span class="line"><span class="comment">  https://blog.csdn.net/liyuanyue2017/article/details/83244310</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE, * PNODE;</span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">List_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Traverse</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_Insert</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_Delete</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">List_Length</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line">PNODE <span class="title function_">List_FindValue</span><span class="params">(PNODE pHead, <span class="type">int</span> val)</span>;<span class="comment">// 找到了就返回那个节点的地址，想干什么就干什么</span></span><br><span class="line">PNODE <span class="title function_">List_FindOrder</span><span class="params">(PNODE pHead, <span class="type">int</span> pos)</span>;<span class="comment">// 其实也可以当成 bool 看待，依然可以用在 if 判断里</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Sort</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pVal;</span><br><span class="line">    PNODE pHead = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    pHead = List_Init();</span><br><span class="line">    List_Traverse(pHead);</span><br><span class="line">    </span><br><span class="line">    List_Insert(pHead, <span class="number">1</span>, <span class="number">34</span>);</span><br><span class="line">    List_Insert(pHead, <span class="number">2</span>, <span class="number">14</span>);</span><br><span class="line">    List_Insert(pHead, <span class="number">1</span>, <span class="number">94</span>);</span><br><span class="line">    List_Insert(pHead, <span class="number">3</span>, <span class="number">-4</span>);</span><br><span class="line">    List_Insert(pHead, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    List_Traverse(pHead);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前链表的长度是：%d\n\n&quot;</span>, List_Length(pHead));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( List_Delete(pHead, <span class="number">3</span>, &amp;pVal) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功！删除的元素是：%d\n\n&quot;</span>, pVal);</span><br><span class="line">    &#125;</span><br><span class="line">    List_Traverse(pHead);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前链表的长度是：%d\n\n&quot;</span>, List_Length(pHead));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( List_FindValue(pHead, <span class="number">33</span>) )&#123;   <span class="comment">// 可以当成 bool 来进行判断</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;是\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;否\n\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    List_Sort(pHead);</span><br><span class="line">    List_Traverse(pHead);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">List_Init</span><span class="params">()</span>&#123;</span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( pHead == <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE pTail = pHead;</span><br><span class="line">    pTail-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入要创建的链表长度：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n ; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第 %d 个节点的值：&quot;</span>, i +<span class="number">1</span> );</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">        </span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        pNew-&gt;data = val;</span><br><span class="line">        pTail-&gt;pNext = pNew;</span><br><span class="line">        pTail = pNew;</span><br><span class="line">        pTail-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Traverse</span><span class="params">(PNODE pHead)</span>&#123;</span><br><span class="line">    PNODE q;</span><br><span class="line">    <span class="type">int</span> len, j;</span><br><span class="line">    </span><br><span class="line">    len = List_Length(pHead);</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>, q = pHead-&gt;pNext; j &lt; len; j++, q = q-&gt;pNext )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">List_Length</span><span class="params">(PNODE pHead)</span>&#123;</span><br><span class="line">    PNODE pNew = pHead-&gt;pNext;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( pNew != <span class="literal">NULL</span> )&#123;</span><br><span class="line">        length++;</span><br><span class="line">        pNew = pNew-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_Insert</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    PNODE q;    <span class="comment">// 先不分配，因为可能pos不合法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( pos == <span class="number">1</span> )&#123;</span><br><span class="line">        q = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        q-&gt;data = val;</span><br><span class="line">        q-&gt;pNext = pHead-&gt;pNext;</span><br><span class="line">        pHead-&gt;pNext = q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    q = List_FindOrder(pHead, pos - <span class="number">1</span>); <span class="comment">// 找第i-1个，方便后续删除</span></span><br><span class="line">    <span class="keyword">if</span> ( !q )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;结点不存在，插入失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        pNew-&gt;data = val;</span><br><span class="line">        </span><br><span class="line">        pNew-&gt;pNext = q-&gt;pNext;</span><br><span class="line">        q-&gt;pNext = pNew;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">List_Delete</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span>&#123;</span><br><span class="line">    PNODE p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( pos == <span class="number">1</span> )&#123;</span><br><span class="line">        p = pHead-&gt;pNext;</span><br><span class="line">        *pVal = p-&gt;data;    <span class="comment">// 保存被删除的数据</span></span><br><span class="line">        pHead-&gt;pNext = p-&gt;pNext;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p = List_FindOrder(pHead, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !p || !p-&gt;pNext )&#123;    <span class="comment">// 第 i-1 个或第 i 个结点不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;结点不存在，删除失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        PNODE q = p-&gt;pNext;</span><br><span class="line">        *pVal = q-&gt;data;    <span class="comment">// 先保存</span></span><br><span class="line">        p-&gt;pNext = q-&gt;pNext;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">List_FindOrder</span><span class="params">(PNODE pHead, <span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( i &lt; pos &amp;&amp;  <span class="literal">NULL</span> != p )&#123;</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( i == pos )</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">List_FindValue</span><span class="params">(PNODE pHead, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( <span class="literal">NULL</span> !=  p &amp;&amp; p-&gt;data != val )&#123;<span class="comment">// p不能为空</span></span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了，返回 p</span></span><br><span class="line">    <span class="comment">// 未找到，返回 NULL，此时 p 等于 NULL</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Sort</span><span class="params">(PNODE pHead)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, len = List_Length(pHead);</span><br><span class="line">    PNODE p, q;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>, p = pHead-&gt;pNext; i &lt; len - <span class="number">1</span>; i++, p = p-&gt;pNext )</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>, q = pHead-&gt;pNext; j &lt; len - <span class="number">1</span> - i; j++, q = q-&gt;pNext )</span><br><span class="line">            <span class="keyword">if</span> ( q-&gt;data &gt; q-&gt;pNext-&gt;data )&#123;</span><br><span class="line">                <span class="type">int</span> t = q-&gt;data;</span><br><span class="line">                q-&gt;data = q-&gt;pNext-&gt;data;</span><br><span class="line">                q-&gt;pNext-&gt;data = t;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在这片绝望的大地上，踏上希望的旅途评测《星之终途》</title>
      <link href="/posts/19788/"/>
      <url>/posts/19788/</url>
      
        <content type="html"><![CDATA[<p><em>原文出处：（已征得转载同意）：<a href="https://mp.weixin.qq.com/s/r_2fT-q4CML_hao7rPbTFA">在这片绝望的大地上，踏上希望的旅途评测《星之终途》</a>——久岛鸥的旅行箱 Galgame批评 2023-12-21 11:30 发表于天津</em></p><hr><blockquote><p>众所周知，著名的音乐 (大雾) 厂商 key社，他们不仅会制作长线多结局的galgame,还会制作短小精悍的视觉小说。而这些短篇视觉小说的主题，可以说大部分都是在探讨末世中的人机关系比如说著名的《星之梦》 (2004年) 、以及不那么著名的《harmonia》 (2016年)。</p><p>而时隔多年，key社可算是重拾了自己的传统艺能，再次制作了一款以末世中的人机关系为主题的短篇视觉小说——它就是于2022年发售，并于近期刚刚登录steam的《星之终途》。</p></blockquote><img src="https://picst.sunbangyan.cn/2023/12/22/1b4005f82a4080912c76dac34e097f89.jpeg" alt="1" /><blockquote><p>顺便一提，key社在2020年之后制作的三部短篇视觉小说系列，大姐《loopers》和三妹《星之终途》都已经登录steam了。现在压力来到了二姐《月球之子》这边了啊哈哈哈。</p></blockquote><img src="https://picdm.sunbangyan.cn/2023/12/22/ffd546beb19756ef55658a9aa36631d6.jpeg" alt="2" /><blockquote><p>那么按照惯例，笔者会从<strong>剧情 立绘 音乐 cv</strong>这四点来进行评分。至于它的内核——即这部作品要传达什么东西，由于每个人的理解不同，过于主观，无法简简单单的以分数定夺，故不作考虑。</p></blockquote><h1 id="剧情-9-10"><a href="#剧情-9-10" class="headerlink" title="剧情  9&#x2F;10"></a>剧情  9&#x2F;10</h1><blockquote><p>相比于2021年出生的两位姐姐，《星之终途》的剧情方面无遗是更上一层楼。虽说该作的剧本量确实不大一笔者的通关时间是5小时左右，但在剧本深度这块确实有点东西的。</p><p>但前排提示，如果说《loopers》是开放式结局、《月球之子》是happy end的话，那《星之终途》的结局，就多少沾点悲剧色彩了——真要说的话，算是一个笑中带泪的结局吧</p></blockquote><img src="https://picss.sunbangyan.cn/2023/12/22/4dbb76d41878c2b548eabef88a00e453.jpeg" alt="3" /><blockquote><p>剧情简介的话，主要如下:在遥远的未来，地球已经不再是人类的天下了。将人类取而代之的，则是在世界各地徘徊、技术达到奇点的机械群——简称奇点机器。</p><p>奇点机器不会主动去攻击人类，但也丝毫不在乎自己的行动是否会造成人类的伤亡。再加上科学技术的逐渐失传以及领地的逐渐丧失，国家已经分崩离析。于是乎人类社会直接退化到了聚落形态，只能靠着之前的遗产苟延残喘。</p><p>但就是在这样绝望的末世中，却有着一小部分人在各个聚落间东奔西走。他们靠着自己的经验与装备，用自己的双脚打通了交通线，让聚落之间可以交换情报以及物资一顺便让自己也赚上一笔可观的报酬。</p><p>他们被称为，货运人。</p><p>而我们的男主裘德，便是这个特殊群体中的其中一员。</p></blockquote><img src="https://picdl.sunbangyan.cn/2023/12/22/e23415f6078a0afcfecf92e5241a5fde.jpeg" alt="4" /><blockquote><p>说实话，和其他作品的男主相比，裘德可以说是相当靠谱了。他本身技术水平过硬、经验丰富;对待敌人杀伐果断，毫不仁慈;至于工作，他也尽心尽力的对待。</p><p>某一日，在无意之中，裘德发现了高空中有一架无人机正在自动巡航。抱着试一试的心态，他顺利的黑入了这台无人机，并将其降落到了自己的面前。在经过一番检查过后,裹德惊讶的发现，这台无人机的科技含量极高，是遗产级别的产物。正当裘德考虑着能把无人机卖出多少价钱的时候，一通私人通讯突然接入到了他的终端之中。</p><p>通讯另一头的老人自称公爵。公爵说这台巡航着的无人机是他给出的测试，只有把无人机成功黑掉的人，才有资格接受他给出的委托一一委托内容则是护送一台仿生机器人到他这里。公爵表示若是这项委托可以成功完成，对于人类这个种族来说都意义重大。不仅如此，裹德将得到的报酬也是不可估量的</p></blockquote><img src="https://picdm.sunbangyan.cn/2023/12/22/24b7e26567fe7d2b98c469f117a16e6c.jpeg" alt="5" /><blockquote><p>在深思熟虑之后，裘德接受了这项委托 (公爵给的实在是太多了.jpg)。在无人区探索一番之后，裘德顺利的找到了这台仿生机器人，并惊讶的发现这台仿生人实在是太像名人类的少女了一一不管是外在形象还是内在表达。</p><p>在仿生人的强烈要求下，裘德给予了她”菲莉娅”这个人类的名字。并与菲莉娅一起踏上了这场漫长的旅途…</p><p>前文中也提到了，该作属于是短篇视觉小说。受于篇幅所限，许多东西都没有展开来讲这实在是太可惜了。不然以该作的剧本水平，笔者或许会给到10分。</p></blockquote><img src="https://picdl.sunbangyan.cn/2023/12/22/990901e356c2129d52c34f99912a44d4.jpeg" alt="6" /><blockquote><p>综上所述，剧情这块是9分。</p></blockquote><h1 id="立绘-8-10"><a href="#立绘-8-10" class="headerlink" title="立绘  8&#x2F;10"></a>立绘  8&#x2F;10</h1><blockquote><p>在立绘这方面的话，这部作品的表现还算不错。</p><p>先来谈谈该作的画师。该作的原画由swav老师负责。这位老师的话，目前来看还处于新人阶段一一《星之终途》是他第一部负责原画的作品。不过虽说是新人，这位老师的画风让人看着还是相当舒服的，也没有出现作画崩坏的情况。用拱火点的说法吧，明日方舟也是以末日为背景的游戏。若是将swav老师的作画放到那边，笔者感觉都没有什么违和感。</p></blockquote><img src="https://picss.sunbangyan.cn/2023/12/22/e5c8d803be315cd284c0bde05068c2b8.jpeg" alt="7" /><blockquote><p>再就是live2d与h scene方面。很抱歉，和key社之前的作品一样，该作也没有使用live2d这项技术(甚至在人物对话时连表情差分都没有);而至于h scene的话，key社上一次做18x的内容还是在2010年的库特wafter里…..后面就一直在做全年龄了。</p><p>最后便是人物立绘与c数量。人物立绘的话，毕竟是去年的作品，该作是支持1920*1080分辨率的，看着相当清晰，而在cg数量方面，受限于剧本所限 (毕竟5小时就能通关)，该作的cg数就不能算多了，只有20多张。</p></blockquote><img src="https://picss.sunbangyan.cn/2023/12/22/eee5c696bde52239f13731f36e45026a.jpeg" alt="8" /><blockquote><p>综上所述，立绘这块可以给到8分。</p></blockquote><h1 id="音乐-7-10"><a href="#音乐-7-10" class="headerlink" title="音乐  7&#x2F;10"></a>音乐  7&#x2F;10</h1><blockquote><p>而在音乐这个方面，该作就只能说是有些拖后腿了。</p><p>先打开专辑，一看创作者。嗯? 怎么大部分bgm都不是由key sounds label创作的了? 整个ost有30首bgm，key创作的曲子只有3首，其他的都是由ice这位老师创作…..这位老师的话，笔者还是第一次接触。一查资料，发现他基本上没怎么做过音乐啊…..</p></blockquote><img src="https://picss.sunbangyan.cn/2023/12/22/20740efb42f5ac2b89c98349096071e4.jpeg" alt="9" /><blockquote><p>正因如此，该作的大部分bgm可以说是一点key味都没有。能让玩家在游玩之后还能记住的曲子更是寥寥无几。</p><p>再就是音乐数量方面。这个倒是还行一一前文中也说了，ost里有30首bgm。这个数量的bgm配合上这个体量的剧本，那是妥妥的够用了。</p><p>最后就是音乐质量上。虽说该作的bgm基本上没有什么key味，但由于剧本的背景在末世，bgm的压抑感倒是给的蛮强的，这倒是契合本作的主题了。但问题是大部分bgm都是压抑的，日常轻松的bgm真的没有几首…..</p></blockquote><img src="https://picdl.sunbangyan.cn/2023/12/22/5c01e2646c4250c019a4981738216f6f.jpeg" alt="10" /><p class='p gray center small'>你这不够高性能啊.jpg</p><blockquote><p>综上所述，音乐这块是7分。</p></blockquote><h1 id="CV-9-10"><a href="#CV-9-10" class="headerlink" title="CV  9&#x2F;10"></a>CV  9&#x2F;10</h1><blockquote><p>最后就是大家最熟悉的cv环节了。该作的cv阵容要笔者来形容的话，那就是麻雀虽小五脏俱全。由于剧本体量不大、角色不多，导致cv的数量也不会很多，但奈何个个都是实力派。</p><p>智勇双全 男主裘德的cv是木村良平。这位可以说是相当眼熟了，在动画方面，代表角色有《革命机》 艾鲁艾尔弗、《机动奥特曼》 早田进次郎、《天使的心跳》 日向秀树等;而在游戏方面，代表角色有《loopers》 西门贵明、《火焰纹章结合》 阿尔弗雷德、《异度神剑3》 泰恩等。</p></blockquote><img src="https://picst.sunbangyan.cn/2023/12/22/365948284b599311d792ce55fc2d1154.jpeg" alt="11" /><blockquote><p>天真烂漫 女主菲莉亚的cv是<strong>指出球亚</strong>。这位就是新人cv了。代表角色有<strong>《天使降临到我身边》 白联花</strong>、<strong>《恋爱小行星》 猪舞</strong>(前面这俩也都是萝莉来着)、<strong>《lovelive》系列 艾玛·维尔德</strong>等。</p></blockquote><img src="https://picdm.sunbangyan.cn/2023/12/22/eb3c0d1d37b9d678fa3daf33120f71cd.jpeg" alt="12" /><blockquote><p>隐藏女配角 斯堂拉的cv则是<strong>花守由美里</strong>。代表角色有<strong>《摇曳露营》 各务原抚子</strong>、<strong>《heaven burns red》白河结奈</strong>、《<strong>anne happy》花小泉杏</strong>等。不过这位角色在该游戏的戏份较少来着。</p></blockquote><img src="https://picdl.sunbangyan.cn/2023/12/22/882f91b80af282390d9f2435a2c76f06.jpeg" alt="13" /><blockquote><p>这几位的名字还是很响亮的。只可惜人数太少了。</p><p>能全程陪伴着玩家们的，也只有男主裘德和女主菲莉亚而已。</p></blockquote><img src="https://picst.sunbangyan.cn/2023/12/22/493a9283a466467db0c2efc110e52896.jpeg" alt="14" /><p class='p gray center small'>慈祥的老父亲</p><blockquote><p>综上所述，cv这块是9分。</p></blockquote><p>故总分数为33&#x2F;40。放在短篇视觉小说里算是优秀的存在，只可惜被音乐拖后腿了呀。</p><p>最后，key社有考虑过把《星之梦》、《harmonia》和《星之终途》这三作放到同一个世界观下吗? 大背景都是差不多的，笔者也很想看到各位主角们碰撞出火花呀。</p><img src="https://picst.sunbangyan.cn/2023/12/22/932eaac6eb9d7c3cc60c762489ca4101.jpeg" alt="15" /><p class='p right small'>审核：金鱼</p><p class='p right small'>排版：亚澄小天使</p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Galgame的艺术——废萌与剧情作的优美崇高之争</title>
      <link href="/posts/32623/"/>
      <url>/posts/32623/</url>
      
        <content type="html"><![CDATA[<p>原文出处：（已征得转载同意）：<a href="https://mp.weixin.qq.com/s/j3ux6rSv6eDBbyTLfSJMhw">Galgame的艺术——废萌与剧情作的优美崇高之争</a>——只知道睡觉的觉皇 Galgame批评 2023-12-18 11:00 发表于河南</p><hr><p class='p green center logo large'>Galgame的艺术</p><p class='p blue center h2'>废萌与剧情作的优美崇高之争</p><p>自美少女游戏诞生之初到今天，已然跨过了四十余载。时至今日，美少女游戏已然形成了一套独有且封闭的生态圈。在美少女游戏发展的历程中，各种类型的作品层出不穷，比较经典的分类方法会按照剧情作与废萌&#x2F;萌拔的方向加以区分。</p><img src="https://picss.sunbangyan.cn/2023/12/22/0a051fe9406ba664bf1735ac58e2a598.jpeg" alt="1" /><p>在对作品类型加以区分之后，如同所有文化圈层一般，在美少女游戏玩家之中不可避免地产生了鄙视链的现象。诸如部分剧情作玩家认为废萌作品的内容过于浅显，而部分废萌玩家则会提及“废萌才是二次元的终点”这样的观点。甚至在单一分类的内部也会有争辩的声音。所以，废萌真的是玩家们阅尽千帆之后的终点吗？剧情作在内容深度上的优势又是否能使其成为美少女游戏这一品类中“上位艺术”的存在呢？在这篇文章中，我将通过“优美”与“崇高”的美学角度，对这类问题表达我自己的看法。</p><p>首先，我们需要从美学的角度，建立对优美与崇高本身的认识。即何为优美，何为崇高。优美一词比较好理解，我们平时绝大多数所称之为美的事物，例如公园的花草、街上的俊男靓女，都可以被归为优美的范畴。那些让我们感到熟悉与亲切的，符合和谐统一的形式美规则的事物所表现的美，即为优美。崇高则是展现出超越常人的高度，打破了和谐统一的规则，展现出一种痛苦的愉悦性。这样的解释略显抽象，这里我用一些大家熟知的艺术作品来做阐释。</p><p>例如下图中展现出的《戴珍珠耳环的少女》，凸显的便是一种古典主义的优美，展现了世俗生活中的美丽。而另一幅《拉奥孔》描绘的则是恐怖与混乱无序的世界，蕴藏了人类悲剧的宿命感，展现了一种可怖的崇高。</p><img src="https://picss.sunbangyan.cn/2023/12/22/4115288cc0f438f56bd98d31588c6cec.jpeg" alt="2" /><p>再比如，当我们聆听约翰施特劳斯的《蓝色多瑙河》时，体会到的便是一种自然与甜蜜的优美。而当我们欣赏《命运交响曲》时，自然能感受其想表达的深邃与宏大的崇高。</p><p>在对优美与崇高的定义进行简单解释后，我想各位也能大致了解其内涵所在。这里我们再回到前文的叙述中来，谈谈美少女游戏中的优美与崇高。</p><p>可以确定的是，几乎所有作品中的女性角色，都是处于优美的范畴之中的，美少女游戏中所展现的美丽的女性形象，完美符合英国哲学家伯克所认为的优美的感性形象特征：柔和的、细润的、曲线条的、光洁的、秀丽的、雅致的。也有一些美少女游戏中的女性形象是否符合优美的特征，仍然值得我们进一步思考，例如《沙耶之歌》中的少女沙耶。但可以肯定是，其身为人形的姿态仍然是优美的。</p><img src="https://picdl.sunbangyan.cn/2023/12/22/d83304427398c39317c83b0de3aa5fc8.jpeg" alt="3" /><p>这里我们可以得出一个结论，即绝大多数废萌作品和部分剧情作品中所展现的美，都仅限于优美的审美意象范畴。不过，从审美角度出发，在展现优美的诸多作品之中，毫无疑问它们是有分高下的。正如王德峰教授所说，有些作品也是优美的，但它们在审美意向中的价值并不高。因为其展现的是一种奶油蛋糕般甜到让人发腻的优美。放在ACG文化之中，这也就是我们俗称的“工业糖精”。而最高的优美来自对缺陷的发现，能使优美包含伤痛的因素。</p><img src="https://picst.sunbangyan.cn/2023/12/22/64a5b2bc1ae2a1b2dd14cc5556471399.jpeg" alt="4" /><p>例如《白色相簿2》，其作品内核表达的审美意向，便是一种痛苦的优美，通过三人情感交织的三角恋关系，向玩家展现了一种痛苦的愉悦性。当然，也有一些废萌作品中蕴含了伤痛的优美，例如《金辉恋曲四重奏》中的理亚线，将刀子暗藏于美好的表象之下，不经意间给予玩家伤痛的体验。</p><img src="https://picst.sunbangyan.cn/2023/12/22/1bc061a55e0350e15f4f83f7dacadbc8.jpeg" alt="5" /><p>对于优美，黑格尔认为，当理念与感性现实相互渗透成为和谐的统一体，即诞生了优美。当理念大于或压倒，甚至冲破形式的桎梏，即成就了崇高。</p><p>为什么说在崇高之中，理念大于甚至压倒形象？举个例子，当我们提及邱少云、黄继光、雷锋这些英雄人物时，我们脑海中浮现得往往是他们舍身奉献的光辉品质，而不是人物的外形相貌，这便是人物精神层面的崇高压倒形象的外在表现。</p><p>崇高在美少女游戏中的表现则主要在于对周遭环境的描写与塑造，使得角色本身的优美与外在环境的崇高交相辉映，而角色主体所经历的遭遇又彰显了一种崇高感。这样的表达略显抽象，这里我再用一张大家熟知的作品举例。</p><img src="https://picdl.sunbangyan.cn/2023/12/22/11c6b8aa7fb2b101b44f3145efd43881.jpeg" alt="6" /><p>这张名为马拉之死的画作，描绘了法国大革命时期遇害的雅各宾派领袖马拉背刺的情景。马拉本人肌肉明朗的手臂、平和安详的表情是优美的。另一方面，作品中大面积的留白，灰暗的色调、地上的匕首与鲜血则塑造了一种压抑的崇高。作品想要传达的，关于革命者对压迫反抗的理念，已然挣脱了画布的枷锁，跃然于纸面之上。</p><p>说回美少女游戏中的崇高，在腾讯游戏（Key）的早期的作品《星之梦》中，展现了一个因战争而荒废的世界。尽管作品只展现了战争视角下破败鬼城的小小一隅，却足以从中洞悉一个庞大的世界。这种虚无的残酷世界，便是在战争背景下的游戏所给予玩家的一种广袤的崇高。在这样一个举目破败的虚无之中，仍然有星野梦美这样优美的形象存在。随着剧情的发展，这一小小角色身上的崇高感也得以彰显。凉元悠一在本作中想要表达的反战思想、对浩瀚而崇高的星辉斑斓的追寻、以及对人类和机器人之间的伦理思考，都试图去冲破单纯的游戏载体，成为一种理念的存在。</p><img src="https://picss.sunbangyan.cn/2023/12/22/a0cf7e562428c266f4236d76de221159.jpeg" alt="7" /><p>在另一部作品《伊甸》中，作品尝试塑造了一个崇高的末世氛围。空无一人自然、无垠的天空都充斥着一股肃穆的自然之美。这样的环境给人的冲击力是极强的，更是与优美的主角诗音形成了鲜明的对比，人类的渺小与自然的宏大让玩家产生了一种悲哀和无力。但是，诗音用自己的力量为人类在末世之中开辟了一条生存之路。尽管诗音本人的存在于世界之中是渺小的，但她表现出的精神仍然让玩家不由升起一种崇高感。</p><img src="https://picdl.sunbangyan.cn/2023/12/22/cca3467866b9ab0ae01872fcbf4a55de.jpeg" alt="8" /><p>遗憾的是，有相当一部分作品想要塑造一种环境上的崇高，却屡被角色身上的优美压倒而显得逼仄，玩家记住的更多是角色的形象本身，致使崇高的内容变得残缺化了。这并不是说崇高呈现的弱表现力就不好，而是对环境塑造和角色情感的描绘缺乏深度，难以表现出与外在优美相衬的崇高感。</p><p>那么，崇高与优美之间有优劣之分吗？康德认为，优美与崇高之间是相辅相成的。崇高如果没有优美来补充，就不可能持久；它会使人感到可敬而不可亲。优美如果离开崇高则无由提高，因而陷入低级趣味的危险。</p><p>在完成了对优美与崇高的基本了解后，我们终于可以回答开篇提到的问题了。废萌是阅尽千帆之后的终点吗？剧情作是美少女游戏品类中上位的存在吗？对于美少女游戏来说，纯粹的废萌作品让人内心恬静、知足快乐，也易使人心灰意懒、养成懦夫庸人。而浸润于崇高，能让人惊醒振作、领悟内核，也容易堕入心浮气躁与虚无之中。由于玩家喜好的不同，可能有人更偏向废萌的安逸，寻觅心灵停泊的港湾。也可能有人更乐于体验剧情作的起伏，体验作品带来的情感激荡。一千个读者自然有一千个哈姆雷特。因为审美的不同去鄙视、攻击他人的行为则是极为可笑的。</p><p>但不可否认的是，同一类型的作品之间，还是有优劣之分的。尽管观众审美的主观因素会影响作品的评价，但一些情节逻辑的设计是否妥当、主次内容的安排是否合理的情况，确实是评价作品优劣的客观要素。</p><img src="https://picdm.sunbangyan.cn/2023/12/22/2b1dbdd3a40b8e0397848fcc12229b8e.jpeg" alt="9" /><p>一些审美价值相对较低的作品，反而会欲望化、感官化我们的审美，致使玩家陷入一种审美贫困的泥沼，这也是值得我们警惕的。如果沦落至感官经验主义的位面，只以感官享乐为价值观，则会在个人形象意识的刺激中丧失自我，逐渐演化为唯我主义意识，反倒失去自己心中的那份“崇高”。</p><p>不过凡事都具备两面性，在后现代主义的时代，我们正经历着崇高性的高度分裂化。技术性崇高让我们领略了曾经未知的宇宙、深海，人造物崇高创造的赛博都市甚至淡化了自然的那份恢弘，战争与恐怖主义崇高又让我们心惊胆战。我们不能盲目相信崇高所推崇的理性，而犬儒式沉溺于优美的享受也不是我们逃避问题的方式。如果要我给出自己的个人建议，那不妨去拓宽自己的见识吧，去试试此前没有尝试或很少尝试的作品。永远保留着对世界的好奇和对美的追寻，以及那份对游戏的热爱，这或许是身为玩家的我们在这个快节奏时代中应该持有的立场。</p><img src="https://picdl.sunbangyan.cn/2023/12/22/e6ff63768e1b925c625ed135eb0d6854.jpeg" alt="10" /><p>在这里，我也想提醒各位玩家朋友们，请不要因为游戏混淆了虚拟与现实的界线，游戏中的优美与崇高令我们沉醉，但作品中的很多行为在现实中是荒谬的。请不要因为对现实的沮丧和惶恐而选择游戏作为追寻爱与感情的逃避之所。游戏中绚烂美好的故事与穿透人心的情感是我们想象世界的窗口，也是我们汲取力量的源泉。不要让自己堕落于深井之中，想想游戏中那些直面苦难的角色，你一样可以成为自己生活中的英雄。倘若你察觉自己的心理健康出现了异常状况，请及时和身边人与医生沟通。尽管我们能从Gal的世界里收获快乐，但不要忘记我们仍然真实地存在于这个世界上。如果你一定需要一个情感寄托的话，那么，请允许我将《Ever17》中的这句话送给你：</p><p class='p blue center h1'>只要你相信她们在那里，</p><p class='p blue center h1'>她们或许真的会在那里。</p><img src="https://picdm.sunbangyan.cn/2023/12/22/efe43574486d02c3c8a877508ea53746.jpeg" alt="11" /><hr><p>参考文献：</p><p>[1]陈榕.西方文论关键词:崇高[J].外国文学,2016(06):93-111</p><p>[2]朱光潜.西方美学史(上)[M]. 北京:中华书局,2013:248-263</p><p>[3]何兆武.从思辨到分析:历史理的重建[M]. 北京:北京大学出版社,2020</p><p class='p right small'>作者：只知道睡觉的觉皇</p><p class='p right small'>审核：蚂蚁</p><p class='p right small'>排版：孤雪心殇</p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语法基础课 &amp;&amp; Week1</title>
      <link href="/posts/24210/"/>
      <url>/posts/24210/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><blockquote><p><strong>Week1 变量、表达式与顺序语句</strong></p></blockquote><hr><hr><h1 id="1-AcWing-604-圆的面积"><a href="#1-AcWing-604-圆的面积" class="headerlink" title="1. AcWing 604. 圆的面积"></a>1. <a href="https://www.acwing.com/problem/content/606/">AcWing 604. 圆的面积</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>计算圆的面积的公式定义为 A&#x3D;πR^2。<br>请利用这个公式计算所给圆的面积。<br>π 的取值为 3.14159。</p><p><strong>输入格式</strong><br>输入包含一个浮点数，为圆的半径 R。</p><p><strong>输出格式</strong><br>输出格式为 A&#x3D;X，其中 X 为圆的面积，用浮点数表示，保留四位小数。</p><p><strong>数据范围</strong><br>0&lt;R&lt;10000.00</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.00</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A=12.5664</span><br></pre></td></tr></table></figure><h2 id="二、代码示例"><a href="#二、代码示例" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>传统的 C 写法，不过在 C++ 中该怎么写？</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> R;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;R);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A=%.4lf\n&quot;</span>, <span class="number">3.14159</span>*R*R);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>在 C++ 中使用 <code>fixed&lt;&lt;setprecision( )</code> 来控制小数位，需要引入头文件 <code>&lt;iomanip&gt;</code>。<br>用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">fixed</span>() &lt;&lt; <span class="built_in">setprecision</span>( 保留的位数 ) &lt;&lt; 变量 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-06 20:30:36</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span>   <span class="comment">//运用fixed&lt;&lt;setprecision()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> R, A;</span><br><span class="line">    cin&gt;&gt;R;</span><br><span class="line">    A = PI * R * R;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A=&quot;</span>&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">4</span>)&lt;&lt;A&lt;&lt;endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      需要运用头文件&lt;iomanip&gt;</span></span><br><span class="line"><span class="comment">      “fixed&lt;&lt;setprecision(4)”，括号中的数字表示为输出保留小数点后几位，</span></span><br><span class="line"><span class="comment">      具体格式为：cout&lt;&lt;fixed&lt;&lt;setprecision(保留位数)&lt;&lt;变量&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="2-AcWing-605-简单乘积"><a href="#2-AcWing-605-简单乘积" class="headerlink" title="2. AcWing 605. 简单乘积"></a>2. <a href="https://www.acwing.com/problem/content/607/">AcWing 605. 简单乘积</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-1"><a href="#一、题目描述-1" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>读取两个整数值。<br>在此之后，计算它们的乘积并将结果存储在名为 PROD 的变量中。<br>输出结果如下例所示。</p><p><strong>输入格式</strong><br>共两行，每行包含一个整数。</p><p><strong>输出格式</strong><br>输出格式为 PROD &#x3D; X，其中 X 为乘积结果。</p><p><strong>数据范围</strong><br>输入的两个整数的绝对值均不超过 10000。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROD = 27</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-1"><a href="#二、代码示例-1" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><p>简单题，没什么好说的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-06 20:31:10</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, PROD;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    PROD = a*b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;PROD = &quot;</span> &lt;&lt; PROD &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="3-AcWing-606-平均数1"><a href="#3-AcWing-606-平均数1" class="headerlink" title="3. AcWing 606. 平均数1"></a>3. <a href="https://www.acwing.com/problem/content/description/608/">AcWing 606. 平均数1</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-2"><a href="#一、题目描述-2" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>读取两个浮点数 A 和 B 的值，对应于两个学生的成绩。<br>请你计算学生的平均分，其中 A 的成绩的权重为 3.5，B 的成绩的权重为 7.5。<br>成绩的取值范围在 0 到 10 之间，且均保留一位小数。</p><p><strong>输入格式</strong><br>输入占两行，每行包含一个浮点数，第一行表示 A，第二行表示 B。</p><p><strong>输出格式</strong><br>输出格式为 MEDIA &#x3D; X，其中 X 为平均分，结果保留五位小数。</p><p><strong>数据范围</strong><br>0≤A,B≤10.0</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.0</span><br><span class="line">7.1</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEDIA = 6.43182</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-2"><a href="#二、代码示例-2" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><p>唯一需要注意的是权重的计算方法······<br><strong>权重的计算：(A*3.5 + B*7.5) &#x2F; (3.5 + 7.5)</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-06 20:36:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> A, B, MEDIA = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    MEDIA = (A*<span class="number">3.5</span> + B*<span class="number">7.5</span>) / <span class="number">11</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MEDIA = &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; MEDIA;</span><br><span class="line">    <span class="comment">// 权重的计算：(A*3.5 + B*7.5) / (3.5 + 7.5)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="4-AcWing-607-平均数2"><a href="#4-AcWing-607-平均数2" class="headerlink" title="4. AcWing 607. 平均数2"></a>4. <a href="https://www.acwing.com/problem/content/609/">AcWing 607. 平均数2</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-3"><a href="#一、题目描述-3" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>读取三个浮点数 A，B 和 C 的值，对应于三个学生的成绩。<br>请你计算学生的平均分，其中 A 的成绩的权重为 2，B 的成绩的权重为 3，C 的成绩的权值为 5。<br>成绩的取值范围在 0 到 10 之间，且均保留一位小数。</p><p><strong>输入格式</strong><br>输入共三行，每行包含一个浮点数，第一行表示 A，第二行表示 B，第三行表示 C。</p><p><strong>输出格式</strong><br>输出格式为 MEDIA &#x3D; X，其中 X 为平均分，结果保留一位小数。</p><p><strong>数据范围</strong><br>0≤A,B,C≤10.0,</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.0</span><br><span class="line">6.0</span><br><span class="line">7.0</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEDIA = 6.3</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-3"><a href="#二、代码示例-3" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-06 20:48:53</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> A, B, C, MEDIA;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;</span><br><span class="line">    MEDIA = ( A*<span class="number">2</span> + B*<span class="number">3</span> + C*<span class="number">5</span> ) / <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MEDIA = &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; MEDIA &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="5-AcWing-608-差"><a href="#5-AcWing-608-差" class="headerlink" title="5. AcWing 608. 差"></a>5. <a href="https://www.acwing.com/problem/content/610/">AcWing 608. 差</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-4"><a href="#一、题目描述-4" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>读取四个整数 A,B,C,D，并计算 (A×B−C×D) 的值。</p><p><strong>输入格式</strong><br>输入共四行，第一行包含整数 A，第二行包含整数 B，第三行包含整数 C，第四行包含整数 D。</p><p><strong>输出格式</strong><br>输出格式为 DIFERENCA &#x3D; X，其中 X 为 (A×B−C×D) 的结果。</p><p><strong>数据范围</strong><br>−10000≤A,B,C,D≤10000</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIFERENCA = -26</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-4"><a href="#二、代码示例-4" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-06 20:54:04</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  A, B, C, D, DIFERENCA = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;</span><br><span class="line">    DIFERENCA = ( A*B - C*D );</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DIFERENCA = &quot;</span> &lt;&lt; DIFERENCA &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="6-AcWing-609-工资"><a href="#6-AcWing-609-工资" class="headerlink" title="6. AcWing 609. 工资"></a>6. <a href="https://www.acwing.com/problem/content/611/">AcWing 609. 工资</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-5"><a href="#一、题目描述-5" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请编写一个程序，可以读取一名员工的员工编号，本月工作总时长（小时）以及时薪，并输出他的工资条，工资条中包括员工编号和员工月收入。</p><p><strong>输入格式</strong><br>输入包含两个整数和一个浮点数，分别代表员工编号，工作时长以及时薪。<br>每个数占一行。</p><p><strong>输出格式</strong><br>输出共两行，第一行格式为 NUMBER &#x3D; X，其中 X 为员工编号。<br>第二行格式为 SALARY &#x3D; U$ Y，其中 Y 为该员工月收入，保留两位小数。</p><p><strong>数据范围</strong><br>1≤员工编号≤100,<br>1≤总工作时长≤200,<br>1≤时薪≤50</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25</span><br><span class="line">100</span><br><span class="line">5.50</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NUMBER = 25</span><br><span class="line">SALARY = U$ 550.00</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-5"><a href="#二、代码示例-5" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-06 20:59:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> NUMBER, HOUR;</span><br><span class="line">    <span class="type">double</span> SALARY;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; NUMBER &gt;&gt; HOUR &gt;&gt; SALARY;</span><br><span class="line">    SALARY = HOUR*SALARY;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NUMBER = &quot;</span> &lt;&lt; NUMBER &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SALARY = U$ &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; SALARY &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="7-AcWing-610-工资和奖金"><a href="#7-AcWing-610-工资和奖金" class="headerlink" title="7. AcWing 610. 工资和奖金"></a>7. <a href="https://www.acwing.com/problem/content/612/">AcWing 610. 工资和奖金</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-6"><a href="#一、题目描述-6" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请你编写一个程序，给定你一个销售人员的名字，底薪以及月销售额。<br>请你计算他的月收入是多少。<br>已知月收入等于底薪加 15% 的月销售额。<br>所有数据保留两位小数。</p><p><strong>输入格式</strong><br>输入第一行包含一个由大写字母构成的长度不超过 10 的字符串，表示销售人员的名字。<br>第二行包含一个浮点数，表示该人员的底薪。<br>第三行包含一个浮点数，表示该人员的月销售额。</p><p><strong>输出格式</strong><br>输出格式为 TOTAL &#x3D; R$ X，X 为该人员月收入。</p><p><strong>数据范围</strong><br>0≤底薪，月销售额≤10000.00</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JOAO</span><br><span class="line">500.00</span><br><span class="line">1000.00</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TOTAL = R$ 650.00</span><br></pre></td></tr></table></figure><h2 id="二、错误代码"><a href="#二、错误代码" class="headerlink" title="二、错误代码"></a>二、错误代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-06 21:03:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string NAME[<span class="number">10</span>];</span><br><span class="line">    <span class="type">double</span> a, b, TOTAL = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; NAME[<span class="number">10</span>] &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    TOTAL = a + b*<span class="number">0.15</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TOTAL = R$ &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; TOTAL &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误提示：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Segmentation Fault   </span><br></pre></td></tr></table></figure><p>在第9行，使用 cin 读取了 NAME[10]，但是数组只有 10 个元素，从 0 到 9，所以应该用 NAME[9] 而不是 NAME[10]。</p><p>另外，在输入a和b之前，没有检查是否成功读取到了字符串，如果用户没有输入任何内容就直接按回车键，可能会导致 cin 流进入异常状态，需要使用 cin.clear() 和 cin.ignore() 来清除错误状态并跳过当前行的剩余字符。</p><h2 id="三、代码示例"><a href="#三、代码示例" class="headerlink" title="三、代码示例"></a>三、代码示例</h2><h3 id="（1）在-错误代码-的基础上修改"><a href="#（1）在-错误代码-的基础上修改" class="headerlink" title="（1）在 错误代码 的基础上修改"></a>（1）在 <code>错误代码</code> 的基础上修改</h3><p>虽然 <strong>Accepted</strong> 了，<strong>但是这种写法也是错的！！！</strong>，详情见总结。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string NAME[<span class="number">10</span>];</span><br><span class="line">    <span class="type">double</span> a, b, TOTAL = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; NAME[<span class="number">9</span>]; <span class="comment">// 修改为NAME[9]</span></span><br><span class="line">    <span class="keyword">if</span> (!cin) &#123;     <span class="comment">// 检查是否成功读取到字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error: failed to read name.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (!cin) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error: failed to read values for a and b.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TOTAL = a + b*<span class="number">0.15</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TOTAL = R$ &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; TOTAL &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Segmentation fault</strong>（段错误）通常是因为 <strong>程序试图访问不属于自己的内存区域，或者试图执行非法操作导致的。</strong> C++中，可能的原因包括但不限于：</p><blockquote><ul><li>访问数组越界</li><li>使用未初始化的指针</li><li>动态分配内存失败</li></ul></blockquote><p>这样可以避免出现Segmentation Fault的问题，并且增加了对输入错误的处理。</p><h3 id="（2）把-10-给去掉"><a href="#（2）把-10-给去掉" class="headerlink" title="（2）把 [10] 给去掉"></a>（2）把 <strong>[10]</strong> 给去掉</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string NAME;</span><br><span class="line">    <span class="type">double</span> a, b, TOTAL = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; NAME &gt;&gt; a &gt;&gt; b;      <span class="comment">// cin 输入字符串方便</span></span><br><span class="line">    </span><br><span class="line">    TOTAL = a + b*<span class="number">0.15</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TOTAL = R$ &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; TOTAL &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）使用字符数组-char-a-10"><a href="#（3）使用字符数组-char-a-10" class="headerlink" title="（3）使用字符数组 char a[10]"></a>（3）使用字符数组 <code>char a[10]</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">double</span> b, c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %lf %lf&quot;</span>, a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TOTAL = R$ %.2lf&quot;</span>, b + c * <span class="number">0.15</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="（1）关于使用-NAME-10-会Segmentation-fault（段错误）"><a href="#（1）关于使用-NAME-10-会Segmentation-fault（段错误）" class="headerlink" title="（1）关于使用 NAME[10] 会Segmentation fault（段错误）"></a>（1）关于使用 <code>NAME[10]</code> 会Segmentation fault（段错误）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string NAME[<span class="number">10</span>];</span><br><span class="line"><span class="type">double</span> a, b, TOTAL = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; NAME[<span class="number">10</span>] &gt;&gt; a &gt;&gt; b;</span><br></pre></td></tr></table></figure><p>先来复习一下段错误：</p><blockquote><p><strong>Segmentation fault</strong>（段错误）通常是因为 <strong>程序试图访问不属于自己的内存区域，或者试图执行非法操作导致的。</strong> C++中，可能的原因包括但不限于：</p><blockquote><ul><li>访问数组越界</li><li>使用未初始化的指针</li><li>动态分配内存失败</li></ul></blockquote></blockquote><p><code>string NAME[10];</code> 声明了一个包含 10 个字符串的数组，而 <code>cin &gt;&gt; NAME[10] &gt;&gt; a &gt;&gt; b;</code> 尝试读取输入到 NAME[10]，这是数组的第11个元素（在C++中，数组是从零开始索引的），这是错误的！</p><h3 id="（2）关于第一种修改也是错误的原因"><a href="#（2）关于第一种修改也是错误的原因" class="headerlink" title="（2）关于第一种修改也是错误的原因"></a>（2）关于第一种修改也是错误的原因</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string NAME[<span class="number">10</span>];</span><br><span class="line"><span class="type">double</span> a, b, TOTAL = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; NAME[<span class="number">9</span>] &gt;&gt; a &gt;&gt; b;</span><br></pre></td></tr></table></figure><h4 id="1-关于-Accepted-的原因"><a href="#1-关于-Accepted-的原因" class="headerlink" title="1. 关于 Accepted 的原因"></a>1. 关于 <strong>Accepted</strong> 的原因</h4><blockquote><p><code>string NAME[10]</code> 声明了一个包含 10 个字符串的的数组（不是字符数组），每一个都可以存储字符串；而<code>cin &gt;&gt; NAME[9]</code> 是把输入的字符串存到数组的第 10 个元素中，即 <code>NAME[9]</code> —— 是有效的。</p></blockquote><h4 id="2-关于这种写法为什么是错的原因"><a href="#2-关于这种写法为什么是错的原因" class="headerlink" title="2. 关于这种写法为什么是错的原因"></a>2. 关于这种写法为什么是错的原因</h4><blockquote><p>这种做法可能会导致代码的可读性降低，因为此题中 NAME 是一个单一的<strong>字符串</strong>而不是一个<strong>字符串数组</strong>。通常情况下，如果只需要一个字符串，直接声明一个 string 类型的变量会更清晰。</p></blockquote><h3 id="（3）C-中-string-的一些用法"><a href="#（3）C-中-string-的一些用法" class="headerlink" title="（3）C++中 string 的一些用法"></a>（3）C++中 string 的一些用法</h3><blockquote><ol><li>在C++中，使用 <code>string</code> 类型时，不需要指定大小——因为 <code>string</code> 类会根据实际存储的字符动态调整大小。这是 <code>string</code> 类的一个优势，因为它能够自动处理字符串的大小变化，无需手动管理内存。</li><li>当在C++中声明 string name[10]; 时，声明的是一个包含 10 个 <code>string</code> 对象的数组，而不是字符数组。<strong>数组中的每个元素（<code>name[0]</code> 到 <code>name[9]</code>）都是一个独立的 <code>string</code> 对象，可以容纳一系列字符。</strong></li><li>在C++中，<code>string</code> 是标准库提供的一个类，表示一系列字符，与传统的字符数组不同。<code>string</code> 类提供了更多的功能，通常比传统的字符数组更方便和安全。<br>因此，通常的做法是直接声明一个 <code>string</code> 变量，而不是一个固定大小的字符串数组。</li></ol></blockquote><h3 id="（4）C-中关于数组和单一变量的声明的区别"><a href="#（4）C-中关于数组和单一变量的声明的区别" class="headerlink" title="（4）C++中关于数组和单一变量的声明的区别"></a>（4）C++中关于数组和单一变量的声明的区别</h3><ol><li><code>string name[10];</code> ：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string name[<span class="number">10</span>];  <span class="comment">// 定义一个包含10个字符串的数组</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>这是一个包含 10 个字符串的数组的声明。数组的每个元素都可以存储一个独立的字符串。</li><li>数组的索引是从0到9，因此有效的访问范围是 name[0] 到 name[9]。</li><li>适用于需要存储多个字符串的情况，每个字符串对应一个数组元素。</li></ul></blockquote><ol start="2"><li><code>string name;</code> ：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string name;  <span class="comment">// 定义一个单一字符串变量</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>一个单一的字符串变量的声明。只能存储一个字符串。</li><li>适用于只需要存储一个字符串的情况。</li></ul></blockquote><ul><li>相同点：</li></ul><blockquote><p>两者都是用来存储字符串的。<br>在编写代码时，可以使用相似的语法来操作，例如使用 cin 读取输入，或者使用 cout 打印输出。</p></blockquote><ul><li>区别：</li></ul><blockquote><p><code>string name[10];</code> 是一个包含多个字符串的数组，每个元素都是一个独立的字符串。<br><code>string name;</code> 是一个单一的字符串变量，只能存储一个字符串。</p></blockquote><p>根据需求，选择数组或者单一变量取决于是需要处理多个字符串还是单一字符串。</p><h3 id="（5）常用头文件"><a href="#（5）常用头文件" class="headerlink" title="（5）常用头文件"></a>（5）常用头文件</h3><p>头文件：</p><ul><li><code>#include &lt;iostream&gt;</code> 包括cin &#x2F; cout &#x2F; scanf &#x2F; printf</li><li><code>#inlcude &lt;cstdio&gt;</code> 包括scanf &#x2F; printf<br>  其中，cstdio编译速度比iostream快</li><li><code>#include &lt;cmath&gt;</code> 包括常用数学公式，如<blockquote><ul><li>double sqrt(double x);</li><li>double pow(double x, double y);</li><li>long int abs(long int x);</li><li>double fabs(double x);</li></ul></blockquote></li><li>万能头文件 <code>#include &lt;bits/stdc++.h&gt;</code></li></ul><hr><hr><h1 id="8-AcWing-611-简单计算"><a href="#8-AcWing-611-简单计算" class="headerlink" title="8. AcWing 611. 简单计算"></a>8. <a href="https://www.acwing.com/problem/content/613/">AcWing 611. 简单计算</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-7"><a href="#一、题目描述-7" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定你两个产品的产品编号，产品数量以及产品单价。<br>请你计算买下两种产品一共需要花费多少钱。</p><p><strong>输入格式</strong><br>输入共两行。<br>每行包含两个整数以及一个浮点数，表示其中一件产品的产品编号，产品数量以及产品单价。</p><p><strong>输出格式</strong><br>输出格式为 VALOR A PAGAR: R$ X，其中 X 为产品总价值，保留两位小数。</p><p><strong>数据范围</strong><br>1≤产品编号,产品数量≤10000,<br>1.00≤产品单价≤10000.00</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12 1 5.30</span><br><span class="line">16 2 5.10</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VALOR A PAGAR: R$ 15.50</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-6"><a href="#二、代码示例-6" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-07 13:41:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1, b1, a2, b2;</span><br><span class="line">    <span class="type">double</span> c1, c2;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; c1;</span><br><span class="line">    cin &gt;&gt; a2 &gt;&gt; b2 &gt;&gt; c2;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> sum = b1*c1 + b2*c2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;VALOR A PAGAR: R$ %.2lf\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="9-AcWing-612-球的体积"><a href="#9-AcWing-612-球的体积" class="headerlink" title="9. AcWing 612. 球的体积"></a>9. <a href="https://www.acwing.com/problem/content/614/">AcWing 612. 球的体积</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-8"><a href="#一、题目描述-8" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定你一个球体的半径 R，请你计算球体的体积。<br>计算球体的公式为 V&#x3D;(4&#x2F;3)∗π∗R^3。<br>π 取 3.14159。</p><p>注意：有些语言中 (4&#x2F;3) 无法得到 1.3333…，建议在公式中使用 (4&#x2F;3.0)。</p><p><strong>输入格式</strong><br>输入一个整数 R。</p><p><strong>输出格式</strong><br>输出格式为 VOLUME &#x3D; X，其中 X 为球体的体积，结果保留三位小数。</p><p><strong>数据范围</strong><br>1≤R≤2000</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VOLUME = 113.097</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-7"><a href="#二、代码示例-7" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><p><strong>需要注意一点：(4 &#x2F; 3) 得不到1.333333···，要使用 (4 &#x2F; 3.0)</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-07 13:48:30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> v = <span class="number">4</span> / <span class="number">3.0</span> * PI * r * r * r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;VOLUME = %.3lf\n&quot;</span>, v);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="10-AcWing-613-面积"><a href="#10-AcWing-613-面积" class="headerlink" title="10. AcWing 613. 面积"></a>10. <a href="https://www.acwing.com/problem/content/description/615/">AcWing 613. 面积</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-9"><a href="#一、题目描述-9" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定三个浮点数 A，B 和 C。<br>然后，计算如下图形的面积：</p><p>底边为 A，高为 C 的三角形。<br>半径 C 的圆。（π&#x3D;3.14159）<br>底边为 A 和 B，高为 C 的梯形。<br>边长为 B 的正方形。<br>边长为 A 和 B 的长方形。</p><p><strong>输入格式</strong><br>输入共一行，包含三个保留一位小数的浮点数 A，B，C。</p><p><strong>输出格式</strong><br>输出共五行，形式如下所示：</p><p>第一行，格式为 TRIANGULO: X，其中 X 为所求三角形面积。<br>第二行，格式为 CIRCULO: X，其中 X 为所求圆形面积。<br>第三行，格式为 TRAPEZIO: X，其中 X 为所求梯形面积。<br>第四行，格式为 QUADRADO: X，其中 X 为所求正方形面积。<br>第五行，格式为 RETANGULO: X，其中 X 为所求长方形面积。</p><p>所有答案保留三位小数。</p><p><strong>数据范围：</strong></p><p>0≤A,B,C≤10000.0</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.0 4.0 5.2</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRIANGULO: 7.800</span><br><span class="line">CIRCULO: 84.949</span><br><span class="line">TRAPEZIO: 18.200</span><br><span class="line">QUADRADO: 16.000</span><br><span class="line">RETANGULO: 12.000</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-8"><a href="#二、代码示例-8" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-09 20:57:32</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a, b, c;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> ans1 = a * c *<span class="number">0.5</span>;</span><br><span class="line">    <span class="type">double</span> ans2 = PI * c * c;</span><br><span class="line">    <span class="type">double</span> ans3 = (a + b) * c * <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">double</span> ans4 = b * b;</span><br><span class="line">    <span class="type">double</span> ans5 = a *b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TRIANGULO: %.3lf\n&quot;</span>, ans1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CIRCULO: %.3lf\n&quot;</span>, ans2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TRAPEZIO: %.3lf\n&quot;</span>, ans3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;QUADRADO: %.3lf\n&quot;</span>, ans4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RETANGULO: %.3lf\n&quot;</span>, ans5);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="11-AcWing-614-最大值"><a href="#11-AcWing-614-最大值" class="headerlink" title="11. AcWing 614. 最大值"></a>11. <a href="https://www.acwing.com/problem/content/616/">AcWing 614. 最大值</a></h1><blockquote><p><strong>【中等】顺序结构</strong></p></blockquote><h2 id="一、题目描述-10"><a href="#一、题目描述-10" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定三个整数，请你找出它们中的最大值。<br>下列公式可能对你有所帮助：<br>max(a,b) &#x3D; ( a + b + abs( a − b ) ) &#x2F; 2</p><p><strong>输入格式</strong><br>输入占一行，包含三个整数。</p><p><strong>输出格式</strong><br>输出格式为 X eh o maior，其中 X 为三个数中的最大值。</p><p><strong>数据范围</strong><br>1≤给定整数≤109</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 14 106</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">106 eh o maior</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-9"><a href="#二、代码示例-9" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><p><strong>求两个数的最大值：max(a,b)&#x3D;(a+b+abs(a−b))&#x2F;2</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-09 21:09:45</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// max(a,b)=(a+b+abs(a−b))/2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="type">int</span> max = (a + b + <span class="built_in">abs</span>(a - b)) / <span class="number">2</span>;</span><br><span class="line">    max = (max + c + <span class="built_in">abs</span>(max - c)) / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; max &lt;&lt; <span class="string">&quot; eh o maior&quot;</span> &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="12-AcWing-615-油耗"><a href="#12-AcWing-615-油耗" class="headerlink" title="12. AcWing 615. 油耗"></a>12. <a href="https://www.acwing.com/problem/content/description/617/">AcWing 615. 油耗</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-11"><a href="#一、题目描述-11" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个汽车行驶的总路程（km）和消耗的油量（l），请你求出汽车每消耗 1 升汽油可行驶多少公里路程。</p><p><strong>输入格式</strong><br>输入共两行，第一行包含整数 X，表示行驶总路程。<br>第二行包含保留一位小数的浮点数 Y，表示消耗的油量。</p><p><strong>输出格式</strong><br>输出格式为 M km&#x2F;l，其中 M 为计算结果，保留三位小数。</p><p><strong>数据范围</strong><br>1≤X,Y≤109</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">500</span><br><span class="line">35.0</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14.286 km/l</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-10"><a href="#二、代码示例-10" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-09 21:15:11</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="type">double</span> m = x / y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf km/l\n&quot;</span>, m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="13-AcWing-616-两点间的距离"><a href="#13-AcWing-616-两点间的距离" class="headerlink" title="13. AcWing 616. 两点间的距离"></a>13. <a href="https://www.acwing.com/problem/content/description/618/">AcWing 616. 两点间的距离</a></h1><blockquote><p><strong>【简单】顺序结构</strong></p></blockquote><h2 id="一、题目描述-12"><a href="#一、题目描述-12" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个点 P1 和 P2，其中 P1 的坐标为 (x1,y1)，P2 的坐标为 (x2,y2)，请你计算两点间的距离是多少。<br><img src="https://picss.sunbangyan.cn/2023/12/11/f50363a4cef73470ba9a18e6bb05915c.jpeg" alt="100" style="zoom:100%"/></p><p><strong>输入格式</strong><br>输入共两行，每行包含两个双精度浮点数 xi,yi，表示其中一个点的坐标。<br>输入数值均保留一位小数。</p><p><strong>输出格式</strong><br>输出你的结果，保留四位小数。</p><p><strong>数据范围</strong><br>−109≤xi,yi≤109</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.0 7.0</span><br><span class="line">5.0 9.0</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.4721</span><br></pre></td></tr></table></figure><h2 id="二、代码示例-11"><a href="#二、代码示例-11" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-12-09 21:18:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x1, y1, x2, y2;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">sqrt</span>( ( (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) ) );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>, d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="14-617-距离"><a href="#14-617-距离" class="headerlink" title="14. 617. 距离"></a>14. <a href="https://www.acwing.com/problem/content/619/">617. 距离</a></h1><blockquote><p><strong>【中等】顺序结构</strong></p></blockquote><h2 id="一、题目描述-13"><a href="#一、题目描述-13" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>两辆汽车在同一地点，同时，沿同一方向前进。<br>一辆车的速度为 60 km&#x2F;h，另一辆车的速度为 90 km&#x2F;h。<br>显然，快车与慢车的距离会不断拉开，每过一个小时（60 分钟），两车的距离就拉开 30 公里。<br>现在，告诉你两车之间的距离为 L 公里，请你求出两车已经行驶了多长时间？</p><p><strong>输入格式</strong><br>输入包含一个整数 L，表示两车之间的距离。</p><p><strong>输出格式</strong><br>输出格式为 X minutos，其中 X 为已经行驶的时间，单位为分钟。</p><p><strong>数据范围</strong><br>1≤L≤109</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60 minutos</span><br></pre></td></tr></table></figure><h2 id="二、错误代码-1"><a href="#二、错误代码-1" class="headerlink" title="二、错误代码"></a>二、错误代码</h2><p><strong>题目并没有直接说 x 的变量类型</strong></p><h3 id="（1）int-x-l-30-60"><a href="#（1）int-x-l-30-60" class="headerlink" title="（1）int x = (l / 30) * 60;"></a>（1）<code>int x = (l / 30) * 60;</code></h3><p>下面这种和第（2）种一样，因为向下取整 + 整个表达式 都是整数，所以int 和 double 一样</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; l;</span><br><span class="line">    <span class="type">int</span> x = (l / <span class="number">30</span>) * <span class="number">60</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; minutos&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码提交状态： <strong>Wrong Answer</strong><br>代码运行状态： <strong>错误数据如下所示</strong></p><p><strong>输入</strong></p><blockquote><p>489</p></blockquote><p><strong>输出</strong></p><blockquote><p>960 minutos</p></blockquote><p><strong>标准答案</strong></p><blockquote><p>978 minutos</p></blockquote><p><strong>运行时间</strong>：2ms</p></blockquote><h3 id="（2）double-x-l-30-60"><a href="#（2）double-x-l-30-60" class="headerlink" title="（2）double x = (l / 30) * 60;"></a>（2）<code>double x = (l / 30) * 60;</code></h3><p>同第（1）种错误</p><blockquote><p>代码提交状态： <strong>Wrong Answer</strong><br>代码运行状态： <strong>错误数据如下所示</strong></p><p><strong>输入</strong></p><blockquote><p>489</p></blockquote><p><strong>输出</strong></p><blockquote><p>960 minutos</p></blockquote><p><strong>标准答案</strong></p><blockquote><p>978 minutos</p></blockquote><p><strong>运行时间</strong>：2ms</p></blockquote><h3 id="（3）double-x-l-30-0-60"><a href="#（3）double-x-l-30-0-60" class="headerlink" title="（3）double x = (l / 30.0) * 60;"></a>（3）<code>double x = (l / 30.0) * 60;</code></h3><p>可以看出，题目输出是整数，即没有小数，所以小数位设置为 0 即可。</p><blockquote><p>代码提交状态： <strong>Wrong Answer</strong><br>代码运行状态： <strong>错误数据如下所示</strong></p><p><strong>输入</strong></p><blockquote><p>596933032</p></blockquote><p><strong>输出</strong></p><blockquote><p>1.19387e+09 minutos</p></blockquote><p><strong>标准答案</strong></p><blockquote><p>1193866064 minutos</p></blockquote><p><strong>运行时间</strong>：2ms</p></blockquote><h2 id="三、代码示例-1"><a href="#三、代码示例-1" class="headerlink" title="三、代码示例"></a>三、代码示例</h2><h3 id="1-把小数位改为0"><a href="#1-把小数位改为0" class="headerlink" title="1. 把小数位改为0"></a>1. 把小数位改为0</h3><blockquote><p>C++ 中控制小数位还可以：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">setf</span>(ios_base::fixed);</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这样子只需要改一个数字就好，不过感觉还是 <code>printf</code> 方便?&gt;······</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; l;</span><br><span class="line">    <span class="type">double</span> x = (l / <span class="number">30.0</span>) * <span class="number">60</span>;</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::fixed);</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; minutos&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用位运算-n-1"><a href="#2-使用位运算-n-1" class="headerlink" title="2. 使用位运算 n &lt;&lt; 1"></a>2. 使用位运算 <code>n &lt;&lt; 1</code></h3><p><em><strong>位运算效率超高的~</strong></em></p><blockquote><ul><li>仔细观察题目数据：30 km → 60 minutes</li><li>也就是说：<strong>乘2</strong> 就完事了！</li></ul></blockquote><p>所以使用位运算是比较好的一种方法。</p><blockquote><p>左移运算（&lt;&lt;）是一种位运算，用于将一个二进制数的所有位向左移动指定的位数。在左移运算中，右侧用零填充。</p><p>对于一个二进制数 x，左移运算 x &lt;&lt; n 表示将 x 的所有位向左移动 n 位。每一位都向左移动，而右侧用 0 填充。左移操作实际上相当于将原数乘以 2 的 n 次方。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d minutos&quot;</span>, n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-直接-n-0-5"><a href="#3-直接-n-0-5" class="headerlink" title="3. 直接 n / 0.5"></a>3. 直接 <code>n / 0.5</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//快车与慢车拉开的距离 0.5公里/min</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::fixed);</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;n/<span class="number">0.5</span>&lt;&lt;<span class="string">&quot; minutos&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><h2 id="1-仔细观察数据"><a href="#1-仔细观察数据" class="headerlink" title="1. 仔细观察数据"></a>1. 仔细观察数据</h2><p>就跟数学题一样，仔细观察数据之间的关系。</p><hr><h2 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2. 位运算"></a>2. 位运算</h2><p>位运算是一种在计算机中操作二进制位的技术。它使用位（0和1）来执行各种操作，如移位、与、或、异或等。位运算通常用于处理底层的数据存储和操作，例如在嵌入式系统、图形处理、密码学等领域。</p><ul><li><p>常见的位运算操作：</p><blockquote><ol><li><p><strong>与运算（&amp;）</strong>：<br>  对应位都为1时，结果为1；否则，结果为0。<br>例如：1010 &amp; 1100 &#x3D; 1000</p></li><li><p><strong>或运算（|）</strong>：<br>  对应位有一个为1时，结果为1；否则，结果为0。<br>例如：1010 | 1100 &#x3D; 1110</p></li><li><p><strong>异或运算（^）</strong>：<br>  对应位相异时，结果为1；否则，结果为0。<br>例如：1010 ^ 1100 &#x3D; 0110</p></li><li><p><strong>取反运算（~）</strong>：<br>  对每个位取反，即0变为1，1变为0。<br>例如：~1010 &#x3D; 0101</p></li><li><p><strong>左移运算（&lt;&lt;）</strong>：<br>  将二进制数左移指定位数，右侧补0。<br>例如：1010 &lt;&lt; 2 &#x3D; 1000</p></li><li><p><strong>右移运算（&gt;&gt;）</strong>：<br>  将二进制数右移指定位数，左侧根据符号位补0或补1。<br>例如：1010 &gt;&gt; 2 &#x3D; 0010</p></li></ol><blockquote><ul><li><p><strong>位运算可以在某些情况下提高代码的效率，尤其是对于一些需要高性能的场景。在使用位运算时，需要了解二进制数的表示和运算规则，并谨慎处理符号位（对于有符号整数）。</strong></p></li><li><p><strong>这些位运算符可以用于整数类型（如int、long等）的操作。要特别注意在使用右移运算符时，对于有符号整数，可能会根据实现方式产生符号位的填充，这可能导致不同的结果。因此，在使用右移运算时，要确保理解底层实现和符号位的影响。</strong></p></li></ul></blockquote></blockquote></li><li><p>位运算的优势</p></li></ul><blockquote><ol><li><p><strong>效率：</strong> 位运算是在硬件层面上进行的操作，通常比算术运算更快。对于一些对性能要求较高的应用，如嵌入式系统、图形处理、密码学等领域，使用位运算可以提高代码的执行效率。</p></li><li><p><strong>节省空间：</strong> 位运算可以用较少的位数表示信息，从而减小数据占用的空间。这在存储大量二进制数据时尤为重要。例如，使用位掩码可以将多个布尔值压缩到一个整数中，从而减少内存占用。</p></li><li><p><strong>逻辑清晰：</strong> 在一些算法和数据结构中，使用位运算可以使代码更加简洁和直观。例如，使用位运算来检查某个数是否是2的幂次方，可以用一行代码完成，而不需要使用乘法或除法等运算。</p></li><li><p><strong>位掩码和标志位：</strong> 位运算常用于创建位掩码（bitmask）和处理标志位（flags）。通过位掩码，可以使用一个整数来表示多个布尔状态，从而减小存储和传输开销。</p></li><li><p><strong>加密和哈希算法：</strong> 位运算在密码学和哈希算法中经常用到，因为它们能够以比较底层的方式处理二进制数据，提供高效的加密和哈希操作。</p></li></ol><blockquote><p><strong>尽管位运算在某些场景下具有优势，但在编写代码时，也要注意代码的可读性和可维护性。过度使用位运算可能会导致代码难以理解，从而降低代码的质量。因此，在选择是否使用位运算时，需要权衡代码的性能需求和代码的清晰度。</strong></p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing C++基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity传送带的简单实现</title>
      <link href="/posts/11281/"/>
      <url>/posts/11281/</url>
      
        <content type="html"><![CDATA[<p>[toc]<br>考核项目——初学者的笔记。<br><strong>参考</strong>： <em><a href="https://b23.tv/HVJfREO">【unity简单实现传送带效果（代码在简介）-哔哩哔哩】</a></em></p><hr><p>目前是4个长方体 cube 作为传送带，再加上物体实现的，有一个固定视角摄像机，还有一个移动视角的摄像机。</p><h1 id="一、传送带脚本"><a href="#一、传送带脚本" class="headerlink" title="一、传送带脚本"></a>一、传送带脚本</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConveyorBelt</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed = <span class="number">0</span>; <span class="comment">// 传送带的移动速度</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 ver; <span class="comment">//向量 代表方向</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()    <span class="comment">// 在脚本启动时调用方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//MoveSpeed = 5; // 写死了就没办法控制速度了</span></span><br><span class="line">        ver = -transform.right;  <span class="comment">//这个就是获取自身的方向   这个红色控制的X轴  就是（1，0，0） 这个是往左动的所以要加个符号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当其他物体进入触发器并保持在触发器中时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过向量 ver 和 MoveSpeed 来移动物体的位置</span></span><br><span class="line">        <span class="comment">// Time.deltaTime 用于平稳处理移动，确保在不同设备上表现一致</span></span><br><span class="line">        other.transform.position += ver*MoveSpeed*Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、相关问题、注意事项"><a href="#二、相关问题、注意事项" class="headerlink" title="二、相关问题、注意事项"></a>二、相关问题、注意事项</h1><h2 id="1、为什么需要脚本？"><a href="#1、为什么需要脚本？" class="headerlink" title="1、为什么需要脚本？"></a>1、为什么需要脚本？</h2><blockquote><p>这个脚本的作用是模拟传送带的效果。在游戏开发中，我们可能希望有一些机制或物体，如传送带、流动的河流等，能够以某个方向移动其他物体，而不是简单地通过改变它们的位置。</p><p>这个脚本的主要作用是在物体进入触发器时，通过修改它们的位置，使它们沿着传送带的方向移动。这种方法相对简单且易于调整，而不涉及复杂的物理引擎力或速度计算。</p></blockquote><h2 id="2、使用脚本的好处"><a href="#2、使用脚本的好处" class="headerlink" title="2、使用脚本的好处"></a>2、使用脚本的好处</h2><blockquote><ol><li><strong>简化物体移动</strong>： 脚本提供了一种相对简单的方法，无需使用复杂的物理引擎设置。我们只需要只需设置传送带的速度，就能够实现物体在其上移动。</li><li><strong>可定制性</strong>： 通过在 Unity 编辑器中调整 <strong>MoveSpeed</strong> 变量，可以轻松调整传送带的速度。这种可调整性使得在不同情境下使用这个脚本变得方便。</li><li><strong>适用性</strong>： 对于一些简单的场景和需求，这个脚本提供了一种有效的方法来实现传送带效果，而无需使用更复杂的物理引擎设置。</li></ol><p>需要注意的是，这只是实现传送带效果的一种方法。如果游戏要求更为真实的物理效果，或者需要更复杂的互动，可能需要考虑使用 Unity 的物理引擎和更复杂的脚本逻辑。</p></blockquote><h2 id="3、代码的主要思路"><a href="#3、代码的主要思路" class="headerlink" title="3、代码的主要思路"></a>3、代码的主要思路</h2><p>这个脚本的主要目的是创建一个模拟传送带效果的功能。</p><blockquote><ol><li><strong>初始化</strong></li></ol><blockquote><ul><li><strong>public float MoveSpeed &#x3D; 0</strong> ：这个变量用于设置传送带的移动速度。</li><li><strong>private Vector3 ver</strong> ：这个向量代表传送带的方向。</li></ul></blockquote><ol start="2"><li><strong>Start 方法</strong></li></ol><blockquote><ul><li><strong>ver &#x3D; -transform.right</strong> ：在脚本启动时，通过将 <strong>ver</strong> 设置为 <strong>-transform.right</strong>，初始化传送带的方向为向左。</li></ul></blockquote><ol start="3"><li><strong>OnTriggerStay 方法</strong></li></ol><blockquote><ul><li><strong>private void OnTriggerStay(Collider other)</strong> : 当其他物体进入触发器并停留在触发器中时，此方法被调用。</li><li><strong>other.transform.position +&#x3D; ver * MoveSpeed * Time.deltaTime;<strong>：通过向量 <strong>ver</strong> 和移动速度 <strong>MoveSpeed</strong> 来移动进入触发器的物体。</strong>Time.deltaTime</strong> 用于确保在不同设备上表现一致，以实现平滑移动。</li></ul></blockquote><p>简而言之，这个脚本假定传送带是一个沿着X轴负方向移动的物体。当其他物体进入传送带的触发器时，它们将被沿着传送带的方向移动，模拟了传送带的效果。</p></blockquote><h2 id="4、Unity-触发器"><a href="#4、Unity-触发器" class="headerlink" title="4、Unity 触发器"></a>4、Unity 触发器</h2><blockquote><p>理解 Unity 中的触发器是学习过程中的一部分。在 Unity 中，触发器是一种用于检测物体之间交互的组件。它通常用于检测物体是否进入或离开某个区域，或者两个物体之间是否发生碰撞。</p><p>在代码中，使用了 <strong>OnTriggerStay</strong> 方法，这是 Unity 中特有的一种方法，用于检测物体在触发器内停留的情况。这个触发器通常由 <strong>Collider</strong> 组件配合使用，可以是一个 Cube、Sphere 或其他形状，它包围在一个物体周围，并且可以设置成触发器模式。</p><p>在代码中，这个触发器（传送带的触发器）的作用是检测进入它范围的其他物体。当其他物体进入传送带的触发器时，<strong>OnTriggerStay</strong> 方法就会被调用。在这个方法里，可以执行一些逻辑，比如修改物体的位置，模拟传送带的效果。</p><p><strong>为什么要使用触发器？</strong></p><ol><li><p><strong>检测碰撞和交互</strong>： 触发器用于检测物体之间的碰撞或交互。通过在触发器中添加脚本，你可以在物体之间的碰撞或交互发生时执行特定的代码逻辑。</p></li><li><p><strong>触发事件</strong>： 当物体进入、停留或离开触发器时，你可以触发特定的事件，执行相应的操作。</p></li><li><p><strong>灵活性</strong>： 触发器提供了一种灵活的方式来设计游戏中的交互和行为。你可以在 Unity 编辑器中直观地设置触发器，而无需编写大量的代码。</p></li></ol></blockquote><p>对于这个传送带脚本，通过使用触发器，可以在物体进入触发器时触发传送带的效果，而无需使用物理引擎的力或速度来实现。这使得传送带的实现更加灵活和容易调整。</p><h2 id="5-传送带的方向控制"><a href="#5-传送带的方向控制" class="headerlink" title="5. 传送带的方向控制"></a>5. 传送带的方向控制</h2><ol><li>写死方向，设置为 <strong>private</strong><br>下面的 <code>MoveSpeed</code> 如果在start里写死的话，再加上 private，是不能在unity编辑器里更改的。</li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Vector3 ver; <span class="comment">// 向量 代表方向</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()    <span class="comment">// 在脚本启动时调用方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//MoveSpeed = 5; // 写死了就没办法控制速度了</span></span><br><span class="line">    ver = -transform.right;  <span class="comment">//这个就是获取自身的方向   这个红色控制的X轴  就是（1，0，0） 这个是往左动的所以要加个符号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 unity 编辑器里具体调整每个传送带方向，设置为 <strong>public</strong></li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConveyorBelt</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed = <span class="number">4</span>; <span class="comment">// 传送带的移动速度</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 ver; <span class="comment">//向量 代表方向</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当其他物体进入触发器并保持在触发器中时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过向量 ver 和 MoveSpeed 来移动物体的位置</span></span><br><span class="line">        <span class="comment">// Time.deltaTime 用于平稳处理移动，确保在不同设备上表现一致</span></span><br><span class="line">        other.transform.position += ver * MoveSpeed * Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br> <code>public Vector3 ver = transform.right; //向量 代表方向</code> 和 <code>public Vector3 ver = Vector3.right; //向量 代表方向</code> 是错误的：</p><p>这表明正在类的字段初始化过程中，尝试使用了非静态的 <code>Component.transform</code>。在C#中，字段初始化阶段要求所有引用都是静态的或常量。</p><p>解决这个问题的一种方式是将 <code>ver</code> 字段的初始化移到 <code>Start</code> 方法中。在 <code>Start</code> 方法中，可以访问 <code>transform</code>。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConveyorBelt</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed = <span class="number">4</span>; <span class="comment">// 传送带的移动速度</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 ver; <span class="comment">// 向量 代表方向</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()    <span class="comment">// 在脚本启动时调用方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在 Start 方法中初始化 ver</span></span><br><span class="line">        ver = -transform.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当其他物体进入触发器并保持在触发器中时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过向量 ver 和 MoveSpeed 来移动物体的位置</span></span><br><span class="line">        <span class="comment">// Time.deltaTime 用于平稳处理移动，确保在不同设备上表现一致</span></span><br><span class="line">        other.transform.position += ver * MoveSpeed * Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将初始化移到 Start 方法中，可以确保在 transform 可以正确使用的时候进行初始化，从而避免了字段初始化的限制。</p><h2 id="6-public-Vector3-ver-Vector3-right-和-public-Vector3-ver-transform-right-的区别"><a href="#6-public-Vector3-ver-Vector3-right-和-public-Vector3-ver-transform-right-的区别" class="headerlink" title="6. public Vector3 ver = Vector3.right; 和 public Vector3 ver = -transform.right; 的区别"></a>6. <code>public Vector3 ver = Vector3.right;</code> 和 <code>public Vector3 ver = -transform.right;</code> 的区别</h2><p>这两行代码分别初始化了 <strong>ver</strong> 变量为不同的向量，有着不同的含义：</p><ol><li><code>public Vector3 ver = Vector3.right;</code>：</li></ol><ul><li>这行代码将 ver 初始化为<strong>世界坐标系</strong>中的正 X 轴的单位向量。</li><li>无论物体自身的朝向如何，ver 始终指向<strong>全局坐标系</strong>中的正 X 轴方向。</li></ul><ol start="2"><li><code>public Vector3 ver = -transform.right;</code>：</li></ol><ul><li>这行代码将 ver 初始化为物体<strong>自身坐标系</strong>中的负 X 轴的单位向量。</li><li>根据物体的朝向，ver 会指向物体左方向，因为负 X 轴是右手坐标系中的左方向。</li></ul><p>所以，主要的区别在于这两个向量所处的坐标系。如果希望传送带的方向是世界坐标系中的某个方向，使用 <code>Vector3.right</code> 就足够了。如果想要根据物体的朝向来确定传送带的方向，可以使用 <code>-transform.right</code>。</p><p>在具体应用中，选择哪个取决于需求。如果传送带的方向不受物体朝向的影响，使用 <code>Vector3.right</code> 可能更直观。如果希望传送带的方向与物体的朝向有关，使用 <code>-transform.right</code> 可能更适合。</p><h2 id="7-C-字段"><a href="#7-C-字段" class="headerlink" title="7. C#字段"></a>7. C#字段</h2><p>在C#中，字段（field）是类的成员变量，它们用于存储类或结构体的数据。字段是类的一部分，用于表示对象的状态。字段可以是各种基本数据类型（如整数、浮点数等）或引用类型（如类的实例）。</p><p>在C#中，类的字段有一些初始化的规则：</p><ol><li><strong>静态字段的初始化</strong>： 静态字段是属于类本身而不是类的实例的。静态字段可以在声明时进行初始化，也可以在静态构造函数中初始化。静态字段的初始化是在类加载的过程中进行的。</li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> staticField = <span class="number">10</span>; <span class="comment">// 静态字段的初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>实例字段的初始化</strong>： 实例字段是属于类的实例的。在类的构造函数中对实例字段进行初始化。这是在每次创建类的实例时进行的。</li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> instanceField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Example</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        instanceField = <span class="number">20</span>; <span class="comment">// 实例字段的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>字段初始化阶段要求的静态或常量引用</strong>： 当在字段声明时直接赋值，这个赋值在初始化阶段进行。在这个阶段，C#规定初始化的值必须是静态的（在编译时就能确定的）或常量的。这是为了确保在编译时就能够确定类的初始状态。</li></ol><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的常量引用是允许的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> ConstantValue = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的静态字段引用是允许的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> StaticFieldValue = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的实例字段引用是不允许的（会导致 CS0236 错误）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> instanceField = StaticFieldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，这些规则有助于确保在程序的执行过程中，类和对象的状态始终处于合理的初始状态。如果允许在字段初始化阶段使用非静态的引用，那么可能会导致不确定的行为，因为这些引用的值可能在运行时才能确定。</p><h2 id="8-传送带上物体移动的方式"><a href="#8-传送带上物体移动的方式" class="headerlink" title="8. 传送带上物体移动的方式"></a>8. 传送带上物体移动的方式</h2><p>如果有多个传送带，每个传送带上都有多个物体需要移动，可以考虑以下几种方式：</p><ol><li><strong>使用多个脚本</strong>：</li></ol><p>为每个传送带创建一个独立的脚本，脚本中处理该传送带上的物体移动逻辑。这样，可以为每个传送带独立设置移动速度和方向。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConveyorBeltScript1.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConveyorBeltScript1</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        other.transform.position += -transform.right * MoveSpeed * Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConveyorBeltScript2.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConveyorBeltScript2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        other.transform.position += transform.forward * MoveSpeed * Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 另外两个传送带的脚本类似 ...</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用参数化的脚本</strong>：</li></ol><p>将脚本参数化，以便一个脚本可以适用于多个传送带。这样只需要一个脚本，但可以在每个传送带上调整参数。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConveyorBeltScript.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConveyorBeltScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> Vector3 MoveDirection = -Vector3.right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        other.transform.position += MoveDirection * MoveSpeed * Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将这个脚本附加到每个传送带上，并在每个传送带上调整 <code>MoveSpeed</code> 和 <code>MoveDirection</code>。</p><ol start="3"><li>传送带作为子物体：</li></ol><p>如果多个传送带共享相似的行为，可以将传送带作为一个空的父物体，然后将每个传送带的物体作为子物体。在这种情况下，移动传送带会影响所有子物体。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConveyorBeltScript.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConveyorBeltScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        other.transform.position += -transform.right * MoveSpeed * Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个传送带的物体都成为传送带的子物体。这样，当移动传送带时，所有的子物体都会跟着移动。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续存储数组的算法演示 之二</title>
      <link href="/posts/21169/"/>
      <url>/posts/21169/</url>
      
        <content type="html"><![CDATA[<p>[toc]<br>上集回顾：<a href="https://akari2333.github.io/posts/35130/">连续存储数组的算法演示 | Akari的小站</a><br>完善了一下思路，总结了一下知识点。</p><hr><p><em>数组的增删改查——也就是顺序表。</em></p><h1 id="一、线性结构"><a href="#一、线性结构" class="headerlink" title="一、线性结构"></a>一、线性结构</h1><p>把所有的结点用一根直线穿起来，节点类似于数组中的元素，或者说是<br>逻辑上具有单个独立意义的个体。</p><h2 id="1-1-连续存储【数组】"><a href="#1-1-连续存储【数组】" class="headerlink" title="1.1 连续存储【数组】"></a>1.1 连续存储【数组】</h2><h3 id="1-1-1-什么叫做数组"><a href="#1-1-1-什么叫做数组" class="headerlink" title="1.1.1 什么叫做数组"></a>1.1.1 什么叫做数组</h3><p>元素类型相同，大小相等（数组传参，只要传进去首地址和长度就行）</p><h3 id="1-1-2-数组的优缺点"><a href="#1-1-2-数组的优缺点" class="headerlink" title="1.1.2 数组的优缺点"></a>1.1.2 数组的优缺点</h3><p><strong>优点：</strong></p><ul><li>存取速度快</li></ul><p><strong>缺点：</strong></p><blockquote><ul><li>事先必须知道数组的长度</li><li>插入删除元素很慢</li><li>空间通常是有限制的</li><li>需要大块连续的内存块</li><li>插入删除元素的效率很低</li></ul></blockquote><h2 id="1-2-离散存储【链表】"><a href="#1-2-离散存储【链表】" class="headerlink" title="1.2 离散存储【链表】"></a>1.2 离散存储【链表】</h2><p><strong>优点：</strong></p><blockquote><ul><li>空间没有限制</li><li>插入删除元素很快</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>存取速度很慢</li></ul></blockquote><p><strong>栈和队列是一种特殊的线性结构，是连续存储或离散存储的一种应用</strong></p><h1 id="二、线性表的顺序存储的表示"><a href="#二、线性表的顺序存储的表示" class="headerlink" title="二、线性表的顺序存储的表示"></a>二、线性表的顺序存储的表示</h1><h2 id="2-1-郝斌老师"><a href="#2-1-郝斌老师" class="headerlink" title="2.1 郝斌老师"></a>2.1 郝斌老师</h2><p>仅仅只使用 <strong>a[10]</strong> 是不够的，此算法要求更多。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> * pBase;    <span class="comment">// 存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">// 数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 当前数组有效元素的个数，即当前元素个数。</span></span><br><span class="line">&#125;Array;     <span class="comment">// 结构体别名 &amp;&amp; 分号不能省</span></span><br></pre></td></tr></table></figure><h2 id="2-2-传统写法"><a href="#2-2-传统写法" class="headerlink" title="2.2 传统写法"></a>2.2 传统写法</h2><blockquote><p><strong>线性表（List）:零个或多个数据元素的有限序列。</strong><br><strong>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</strong></p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#defne MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqlList;</span><br></pre></td></tr></table></figure><p>这里我们就发现描述顺序存储结构需要三个属性:</p><blockquote><ul><li>存储空间的起始位置:数组data，它的存储位置就是存储空间的存储位置。</li><li>线性表的最大存储容量: 数组长度 MAXSIZE。</li><li>线性表的当前长度: length。</li></ul></blockquote><p><strong>这两种方法只是表示方法不一样，本质是一致的。</strong></p><h1 id="三、数据长度与线性表长度的区别"><a href="#三、数据长度与线性表长度的区别" class="headerlink" title="三、数据长度与线性表长度的区别"></a>三、数据长度与线性表长度的区别</h1><p>这里有两个概念“数组的长度”和“线性表的长度”需要区分一下。</p><blockquote><ul><li>数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。那么数组的大小一定不可以变吗？有书中谈到可以动态分配的一维数组。是的，一般高级语言，比如C、C＋＋都可以用编程手段实现动态分配数组，不过这会带来性能上的损耗。</li><li>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>在任意时刻，线性表的长度应该小于等于数组的长度。</li></ul></blockquote><h1 id="四、连续存储数组的算法演示"><a href="#四、连续存储数组的算法演示" class="headerlink" title="四、连续存储数组的算法演示"></a>四、连续存储数组的算法演示</h1><blockquote><p>完整程序如下：</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span>     <span class="comment">//包含了malloc函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">//包含了exit函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> * pBase;    <span class="comment">// 存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">// 数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 当前数组有效元素的个数，即当前元素个数。</span></span><br><span class="line">&#125;Array;     <span class="comment">// 结构体别名 &amp;&amp; 分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Inverse</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Insert</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> val )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Delete</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> * pVal )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">array_Find</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_SortSelete</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_SortBubble</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_SortQuick</span> <span class="params">( Array * pArr , <span class="type">int</span> low, <span class="type">int</span> high)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span> <span class="params">( Array * pArr, <span class="type">int</span> low, <span class="type">int</span> high )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array arr;  <span class="comment">// 定义了一个结构体变量，名字是 arr</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化的数组长度：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;length);</span><br><span class="line">    array_Init(&amp;arr, length);   <span class="comment">// 初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：追加</span></span><br><span class="line">    array_Append(&amp;arr, <span class="number">1</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">34</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">-5</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">12</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">4</span>);</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：翻转、倒置</span></span><br><span class="line">    array_Inverse(&amp;arr);</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：插入</span></span><br><span class="line">    <span class="keyword">if</span> ( array_Insert(&amp;arr, <span class="number">3</span>, <span class="number">0</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功！插入的元素是：%d\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：删除</span></span><br><span class="line">    <span class="type">int</span> pVal;</span><br><span class="line">    <span class="keyword">if</span> ( array_Delete(&amp;arr, <span class="number">3</span>, &amp;pVal) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功！删除的元素是：%d\n&quot;</span>, pVal);</span><br><span class="line">    &#125;</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：查找</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入要查找的元素：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, array_Find(&amp;arr, val));  <span class="comment">// 如果是二分，必须先排序，否则会出错！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试：排序</span></span><br><span class="line"><span class="comment">//  array_SortSelete(&amp;arr);</span></span><br><span class="line"><span class="comment">//  array_SortBubble(&amp;arr);</span></span><br><span class="line">    array_SortQuick(&amp;arr, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span>&#123;</span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == pArr-&gt;pBase )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pArr-&gt;length = length;</span><br><span class="line">        pArr-&gt;count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> == pArr-&gt;count )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( pArr-&gt;count == pArr-&gt;length )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组为空！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;count; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pArr-&gt;pBase[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsFull( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pArr-&gt;pBase[pArr-&gt;count] = val;</span><br><span class="line">    (pArr-&gt;count)++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折半思想</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Inverse</span> <span class="params">( Array * pArr )</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;count / <span class="number">2</span>; i++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[pArr-&gt;count - <span class="number">1</span> - i];</span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;count - <span class="number">1</span> - i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Insert</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> val )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array_IsFull( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( pos &lt; <span class="number">1</span> || pos &gt; pArr-&gt;count + <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = pArr-&gt;count - <span class="number">1</span>; i &gt;= pos - <span class="number">1</span>; i-- )&#123;</span><br><span class="line">        pArr-&gt;pBase[i + <span class="number">1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;pBase[pos - <span class="number">1</span>] = val;</span><br><span class="line">    pArr-&gt;count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Delete</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> * pVal )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( pos &lt; <span class="number">1</span> || pos &gt; pArr-&gt;count )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *pVal = pArr-&gt;pBase[pos - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = pos; i &lt; pArr-&gt;count; i++ )&#123;</span><br><span class="line">        pArr-&gt;pBase[i - <span class="number">1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;count--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1、循环遍历</span></span><br><span class="line"><span class="comment">int array_Find ( Array * pArr, int val )&#123;</span></span><br><span class="line"><span class="comment">    if ( array_IsEmpty( pArr ) )&#123;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pos = -1;</span></span><br><span class="line"><span class="comment">    for ( int i = 0; i &lt; pArr-&gt;count - 1; i++ )&#123;</span></span><br><span class="line"><span class="comment">        if ( val == pArr-&gt;pBase[i] )&#123;</span></span><br><span class="line"><span class="comment">            pos = i;</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return pos;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、二分查找：左闭右闭 （必须是有序数组！）</span></span><br><span class="line"><span class="comment">int array_Find ( Array * pArr , int val )&#123;</span></span><br><span class="line"><span class="comment">    if ( array_IsEmpty( pArr ) )&#123;</span></span><br><span class="line"><span class="comment">        return -1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int left = 0, right = pArr-&gt;count - 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    while ( left &lt;= right )&#123;</span></span><br><span class="line"><span class="comment">        int middle = ( right - left ) / 2 + left;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if ( val &lt; pArr-&gt;pBase[middle] )&#123;</span></span><br><span class="line"><span class="comment">            right = middle - 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        else if ( val &gt; pArr-&gt;pBase[middle] )&#123;</span></span><br><span class="line"><span class="comment">            left = middle + 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            return middle;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return -1;</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、二分查找：左闭右开 （必须是有序数组！）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_Find</span> <span class="params">( Array * pArr , <span class="type">int</span> val )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = pArr-&gt;count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt; right )&#123;</span><br><span class="line">        <span class="type">int</span> middle = ( right - left ) / <span class="number">2</span> + left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( val &lt; pArr-&gt;pBase[middle] )&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( val &gt; pArr-&gt;pBase[middle] )&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_SortSelete</span> <span class="params">( Array * pArr )</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;count - <span class="number">1</span>; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> j = i + <span class="number">1</span>; j &lt; pArr-&gt;count; j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( pArr-&gt;pBase[i] &gt; pArr-&gt;pBase[j] )&#123;</span><br><span class="line">                <span class="type">int</span> t = pArr-&gt;pBase[i];</span><br><span class="line">                pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">                pArr-&gt;pBase[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_SortBubble</span> <span class="params">( Array * pArr )</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;count - <span class="number">1</span>; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; pArr-&gt;count - <span class="number">1</span> - i; j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( pArr-&gt;pBase[j] &gt; pArr-&gt;pBase[j + <span class="number">1</span>] )&#123;</span><br><span class="line">                <span class="type">int</span> t = pArr-&gt;pBase[j];</span><br><span class="line">                pArr-&gt;pBase[j] = pArr-&gt;pBase[j + <span class="number">1</span>];</span><br><span class="line">                pArr-&gt;pBase[j + <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排母函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_SortQuick</span><span class="params">( Array * pArr , <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( low &lt; high )&#123;</span><br><span class="line">        pos = FindPos( pArr, low, high );</span><br><span class="line">        array_SortQuick( pArr, low, pos - <span class="number">1</span> );</span><br><span class="line">        array_SortQuick( pArr, pos + <span class="number">1</span>, high );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( low &gt;= high )&#123;     <span class="comment">// 直接返回，避免无限递归。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准分割函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span> <span class="params">( Array * pArr, <span class="type">int</span> low, <span class="type">int</span> high )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = pArr-&gt;pBase[low];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; pArr-&gt;pBase[high] &gt;= val )&#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        pArr-&gt;pBase[low] = pArr-&gt;pBase[high];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; pArr-&gt;pBase[low] &lt;= val )&#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        pArr-&gt;pBase[high] = pArr-&gt;pBase[low];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;pBase[low] = val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><ol><li>数组的结构体代码：</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> * pBase;    <span class="comment">// 存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">// 数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 当前数组有效元素的个数，即当前元素个数。</span></span><br><span class="line">&#125;Array;     <span class="comment">// 结构体别名 &amp;&amp; 分号不能省</span></span><br></pre></td></tr></table></figure><blockquote><p>定义了一个数据类型，该数据类型的名字叫做 <strong>struct Arr</strong>，该数据类型含有 3 个成员，分别为 <strong>pBase</strong>，<strong>len</strong>，<strong>cnt</strong>。</p></blockquote><ol start="2"><li>main 函数中定义</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> * pBase;    <span class="comment">// 存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">// 数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 当前数组有效元素的个数，即当前元素个数。</span></span><br><span class="line">&#125;Array;     <span class="comment">// 结构体别名 &amp;&amp; 分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array arr;  <span class="comment">// 定义了一个结构体变量，名字是 arr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：此处仅仅是定义了 arr，还没有初始化。</p><ol start="3"><li>那么此程序涉及到的函数有：</li></ol><p>目前我们还不知道函数的形参、返回类型，均先默认 <code>void</code> 类型。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span> <span class="params">( )</span>;    <span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( )</span>;    <span class="comment">// 遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Append</span> <span class="params">( )</span>;      <span class="comment">// 追加</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_IsEmpty</span> <span class="params">( )</span>;     <span class="comment">// 判断数组是否为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_IsFull</span> <span class="params">( )</span>;      <span class="comment">// 判断数组是否已满</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Insert</span> <span class="params">( )</span>;      <span class="comment">// 插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Delete</span> <span class="params">( )</span>;      <span class="comment">// 删除元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Inverse</span> <span class="params">( )</span>;     <span class="comment">// 翻转、倒置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Find</span> <span class="params">( )</span>;    <span class="comment">// 查找</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Sort</span> <span class="params">( )</span>;    <span class="comment">// 排序</span></span><br></pre></td></tr></table></figure><h2 id="4-0-函数的传参问题"><a href="#4-0-函数的传参问题" class="headerlink" title="4.0 函数的传参问题"></a>4.0 函数的传参问题</h2><blockquote><ul><li>假设以上函数中形参都是普通变量，那么在调用此函数并执行完毕后，形参的内存会被释放，而且传递进来的实参和形参是两块不一样的内存，无法达到更改实参变量值的目的。</li><li>所以以上的函数内的形参都是以指针的方式进行定义，传递的实参为是要被修改的变量的指针(地址)，可以通过指针修改变量的值，而且在被调函数执行完毕后，被调函数的内存被释放，但是通过指针操作而被修改的变量的值不会被改变，从而达到修改变量值的目的。</li></ul></blockquote><p>从而达在被调函数如 <code>void array_Init ();</code> 中修改主调函数 <code>main()</code> 函数中 <code>struct Arr arr;</code> 变量的值</p><h2 id="4-1-初始化数组-array-Init"><a href="#4-1-初始化数组-array-Init" class="headerlink" title="4.1 初始化数组 array_Init()"></a>4.1 初始化数组 array_Init()</h2><h3 id="4-1-1-算法步骤"><a href="#4-1-1-算法步骤" class="headerlink" title="4.1.1 算法步骤"></a>4.1.1 算法步骤</h3><blockquote><ol><li>函数返回值类型：此函数的目的是初始化数组，不需要返回值 void</li><li>输入想要初始化的数组长度 length，然后动态内存分配长度为 length 的数组，并把分配的内存地址传给数组的首地址</li><li>如果动态内存分配失败则退出。</li><li>否则将数组的长度 &#x3D; length，数组的当前元素个数 &#x3D; 0;</li></ol></blockquote><h3 id="4-1-2-代码实现"><a href="#4-1-2-代码实现" class="headerlink" title="4.1.2 代码实现"></a>4.1.2 代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span> <span class="comment">// 初始化为总长度为 length 的数组</span></span><br><span class="line">&#123;</span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);  <span class="comment">// 动态内存分配，首元素地址保存在 pBase</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == pArr-&gt;pBase )&#123;  <span class="comment">// 分配是否成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);   <span class="comment">// 终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pArr-&gt;length = length;  <span class="comment">// 数组中能存储的最大元素个数</span></span><br><span class="line">        pArr-&gt;count = <span class="number">0</span>;    <span class="comment">// 数组有效元素个数为 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;     <span class="comment">// 表示此函数终止了，增强可读性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-测试"><a href="#4-1-3-测试" class="headerlink" title="4.1.3 测试"></a>4.1.3 测试</h3><p><strong>输入样例：</strong></p><blockquote><p>6</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>初始化的数组长度：6</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span>     <span class="comment">//包含了malloc函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">//包含了exit函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span>;    <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array arr;  <span class="comment">// 定义结构体变量，名字是 arr</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化的数组长度：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;length);</span><br><span class="line">    array_Init(&amp;arr, length);   <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span></span><br><span class="line">&#123;</span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == pArr-&gt;pBase )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pArr-&gt;length = length;</span><br><span class="line">        pArr-&gt;count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-判断是否为空-array-IsEmpty"><a href="#4-2-判断是否为空-array-IsEmpty" class="headerlink" title="4.2 判断是否为空 array_IsEmpty()"></a>4.2 判断是否为空 array_IsEmpty()</h2><h3 id="4-2-1-算法步骤"><a href="#4-2-1-算法步骤" class="headerlink" title="4.2.1 算法步骤"></a>4.2.1 算法步骤</h3><blockquote><ol><li>判断，函数返回值类型为 bool；</li><li>如果当前元素个数 &#x3D; 0，即 count &#x3D; 0，返回 true</li><li>否则，返回 false</li></ol></blockquote><h3 id="4-2-2-代码实现"><a href="#4-2-2-代码实现" class="headerlink" title="4.2.2 代码实现"></a>4.2.2 代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> == pArr-&gt;count )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-判断是否为满-array-IsFull"><a href="#4-3-判断是否为满-array-IsFull" class="headerlink" title="4.3 判断是否为满 array_IsFull()"></a>4.3 判断是否为满 array_IsFull()</h2><h3 id="4-3-1-算法步骤"><a href="#4-3-1-算法步骤" class="headerlink" title="4.3.1 算法步骤"></a>4.3.1 算法步骤</h3><blockquote><ol><li>判断，函数返回值类型为 bool；</li><li>如果当前元素个数 &#x3D; 数组最大元素个数，即 count &#x3D; length，返回 true</li><li>否则，返回 false</li></ol></blockquote><h3 id="4-3-2-代码实现"><a href="#4-3-2-代码实现" class="headerlink" title="4.3.2 代码实现"></a>4.3.2 代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pArr-&gt;count == pArr-&gt;length )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-遍历-array-Traverse"><a href="#4-4-遍历-array-Traverse" class="headerlink" title="4.4 遍历 array_Traverse()"></a>4.4 遍历 array_Traverse()</h2><h3 id="4-4-1-算法步骤"><a href="#4-4-1-算法步骤" class="headerlink" title="4.4.1 算法步骤"></a>4.4.1 算法步骤</h3><p>好了，数组初始化，判断是否空、满都已完成，接下来自然而然就是遍历了，只有<strong>遍历输出</strong>才能测试后续的函数是否成功呀！</p><blockquote><ol><li>遍历，可能成功，可能失败。bool<br>因为如果数组为空，遍历失败。</li><li>数组不为空时才遍历</li></ol></blockquote><h3 id="4-4-2-代码实现"><a href="#4-4-2-代码实现" class="headerlink" title="4.4.2 代码实现"></a>4.4.2 代码实现</h3><p><strong>注意：这里的 <code>else</code>不能少，不然判断为空之后，还会继续执行 for 循环！</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组为空！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;   <span class="comment">// 这里的 else 不能少</span></span><br><span class="line">    <span class="comment">// 数组的遍历——数组怎么遍历的，这里就怎么遍历</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;count; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pArr-&gt;pBase[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-追加元素-array-Append"><a href="#4-5-追加元素-array-Append" class="headerlink" title="4.5 追加元素 array_Append()"></a>4.5 追加元素 array_Append()</h2><p>初始化已经完毕了，但是数组里没有元素、是空的，所以要追加元素。</p><h3 id="4-5-1-算法步骤"><a href="#4-5-1-算法步骤" class="headerlink" title="4.5.1 算法步骤"></a>4.5.1 算法步骤</h3><blockquote><ol><li>追加，可能成功，可能失败。bool<br>因为如果数组已满，也就是 count &#x3D;&#x3D; length 时，追加失败。</li><li>满时返回false</li><li>不满时追加</li><li>追加数据 val</li><li>当前元素个数 +1</li></ol></blockquote><h3 id="4-5-2-代码实现"><a href="#4-5-2-代码实现" class="headerlink" title="4.5.2 代码实现"></a>4.5.2 代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span> <span class="comment">// 追加元素 val</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 满时返回 false</span></span><br><span class="line">    <span class="keyword">if</span>( array_IsFull( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不满时追加</span></span><br><span class="line">    pArr-&gt;pBase[pArr-&gt;count] = val; <span class="comment">// 追加数据 val</span></span><br><span class="line">    (pArr-&gt;count)++;    <span class="comment">// 当前元素个数自增</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到：</p><blockquote><p>pArr-&gt;pBase[pArr-&gt;count] &#x3D; val; &#x2F;&#x2F; 追加数据 val<br>(pArr-&gt;count)++;    &#x2F;&#x2F; 当前元素个数自增</p></blockquote><p>这里就把 <code>pArr-&gt;pBase</code> 当成数组首地址就可，类似于 <code>a[10]</code> 的 <code>a</code>。</p><h3 id="4-5-3-测试"><a href="#4-5-3-测试" class="headerlink" title="4.5.3 测试"></a>4.5.3 测试</h3><p><strong>输入样例：</strong></p><blockquote><p>6</p><p>1 34 -5 12 4</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>初始化的数组长度：6<br>成功追加元素： 1<br>成功追加元素： 34<br>成功追加元素： -5<br>成功追加元素： 12<br>成功追加元素： 4<br>1 34 -5 12 4</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span>     <span class="comment">//包含了malloc函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">//包含了exit函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> * pBase;    <span class="comment">// 存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">// 数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 当前数组有效元素的个数，即当前元素个数。</span></span><br><span class="line">&#125;Array;     <span class="comment">// 结构体别名 &amp;&amp; 分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array arr;  <span class="comment">// 定义了一个结构体变量，名字是 arr</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化的数组长度：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;length);</span><br><span class="line">    array_Init(&amp;arr, length);   <span class="comment">// 初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：追加</span></span><br><span class="line">    <span class="keyword">if</span>( array_Append(&amp;arr, <span class="number">1</span>) ) <span class="built_in">printf</span>(<span class="string">&quot;成功追加元素： %d\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;追加失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>( array_Append(&amp;arr, <span class="number">34</span>) ) <span class="built_in">printf</span>(<span class="string">&quot;成功追加元素： %d\n&quot;</span>, <span class="number">34</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;追加失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>( array_Append(&amp;arr, <span class="number">-5</span>) ) <span class="built_in">printf</span>(<span class="string">&quot;成功追加元素： %d\n&quot;</span>, <span class="number">-5</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;追加失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>( array_Append(&amp;arr, <span class="number">12</span>) ) <span class="built_in">printf</span>(<span class="string">&quot;成功追加元素： %d\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;追加失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>( array_Append(&amp;arr, <span class="number">4</span>) ) <span class="built_in">printf</span>(<span class="string">&quot;成功追加元素： %d\n&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;追加失败！\n&quot;</span>);</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span></span><br><span class="line">&#123;</span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == pArr-&gt;pBase )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pArr-&gt;length = length;</span><br><span class="line">        pArr-&gt;count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> == pArr-&gt;count )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pArr-&gt;count == pArr-&gt;length )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组为空！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;count; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pArr-&gt;pBase[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsFull( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pArr-&gt;pBase[pArr-&gt;count] = val;</span><br><span class="line">    (pArr-&gt;count)++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-翻转、倒置-array-Inverse"><a href="#4-6-翻转、倒置-array-Inverse" class="headerlink" title="4.6 翻转、倒置 array_Inverse()"></a>4.6 翻转、倒置 array_Inverse()</h2><p>正着可以输出，那反过来也可以！</p><h3 id="4-6-1-算法步骤"><a href="#4-6-1-算法步骤" class="headerlink" title="4.6.1 算法步骤"></a>4.6.1 算法步骤</h3><blockquote><ol><li>定义元素下标最大值 j 和最小值 i 中数据进行互换，之后元素最小下标 i++ 自增和元素最大下标 j– 自减进行数据互换，剩下的元素依次进行类推，直到最中间元素的数据互换完，</li><li>至于元素个数为奇数、偶数会不会有影响：数组总共奇数个元素，则中间元素不存在互换问题；偶数个元素则两两成对无中间元素</li></ol></blockquote><h3 id="4-6-2-代码实现"><a href="#4-6-2-代码实现" class="headerlink" title="4.6.2 代码实现"></a>4.6.2 代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Array_Inverse</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">//元素刚开始下标 0</span></span><br><span class="line">    j = pArr-&gt;count - <span class="number">1</span>;    <span class="comment">//元素最大下标要减 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( i &lt; j ) <span class="comment">// 两数互换，两杯水互换,引入第三个杯子 t</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">        pArr-&gt;pBase[j] = t;</span><br><span class="line">        </span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>也可以用 for 循环，但是没有 while 直观，而且 for 容易出错。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Array_Inverse</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = pArr-&gt;count - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;j; i++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">        pArr-&gt;pBase[j] = t;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i++;    // for 循环里面已经 i++了，这里多余。</span></span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But！上面这种方法太麻烦了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 折半思想</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Inverse</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;count / <span class="number">2</span>; i++ )&#123; <span class="comment">// 折半</span></span><br><span class="line">        <span class="type">int</span> t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[pArr-&gt;count - <span class="number">1</span> - i];</span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;count - <span class="number">1</span> - i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同样不存在奇偶不一致会导致出问题的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的第一种方法并不是最优解，因为它需要使用额外的空间来存储输入的数组，即使是在原地翻转数组的情况下，交换的操作次数也更多。<br>而这种方法更简洁的方法在不使用额外空间的情况下原地翻转数组，而且只需要一次遍历，每次将首尾元素进行交换，从而实现原地翻转数组。</p><h3 id="4-6-3-测试"><a href="#4-6-3-测试" class="headerlink" title="4.6.3 测试"></a>4.6.3 测试</h3><p><strong>输入样例：</strong></p><blockquote><p>6</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>初始化的数组长度：6<br>1 34 -5 12 4<br>4 12 -5 34 1</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span>     <span class="comment">//包含了malloc函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">//包含了exit函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> * pBase;    <span class="comment">// 存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">// 数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 当前数组有效元素的个数，即当前元素个数。</span></span><br><span class="line">&#125;Array;     <span class="comment">// 结构体别名 &amp;&amp; 分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Inverse</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array arr;  <span class="comment">// 定义了一个结构体变量，名字是 arr</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化的数组长度：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;length);</span><br><span class="line">    array_Init(&amp;arr, length);   <span class="comment">// 初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：追加</span></span><br><span class="line">    array_Append(&amp;arr, <span class="number">1</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">34</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">-5</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">12</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">4</span>);</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：翻转、倒置</span></span><br><span class="line">    array_Inverse(&amp;arr);</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span></span><br><span class="line">&#123;</span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == pArr-&gt;pBase )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pArr-&gt;length = length;</span><br><span class="line">        pArr-&gt;count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> == pArr-&gt;count )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pArr-&gt;count == pArr-&gt;length )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组为空！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;count; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pArr-&gt;pBase[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsFull( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pArr-&gt;pBase[pArr-&gt;count] = val;</span><br><span class="line">    (pArr-&gt;count)++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Inverse</span> <span class="params">( Array * pArr )</span><span class="comment">// 折半思想</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;count / <span class="number">2</span>; i++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[pArr-&gt;count - <span class="number">1</span> - i];</span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;count - <span class="number">1</span> - i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-插入-array-Insert"><a href="#4-7-插入-array-Insert" class="headerlink" title="4.7 插入 array_Insert()"></a>4.7 插入 array_Insert()</h2><p><del>直到现在我都觉得 插入和删除 真的不简单啊，每次都得想半天······</del></p><h3 id="4-7-1-算法步骤"><a href="#4-7-1-算法步骤" class="headerlink" title="4.7.1 算法步骤"></a>4.7.1 算法步骤</h3><blockquote><ol><li>插入，可能失败，可能成功，所以是 bool</li><li>在 pos 位置处插入 val，且 pos 的位置从 1 开始</li><li>如果数组已满，插入失败，返回 false</li><li>如果插入的位置 pos &lt; 1 || pos &gt; 当前元素个数+1，插入失败，返回 false</li><li>pos 后的元素后移，再插入val。</li></ol></blockquote><p><strong>下标不一致的问题：</strong><br>这是插入操作的关键步骤，因为 pos 从 1 开始，而数组下标从 0 开始，那么怎么处理才能使 pos 后的元素后移，这样刚好可以使下一步插入 val 呢？</p><blockquote><p><strong>画图</strong>，不懂就画图：</p></blockquote><p>原数组为：</p><blockquote><p>1 34 -5 12 4</p></blockquote><p>现在我要在第 3 个位置插入 0，则插入之后的数组为</p><blockquote><p>1 34 0 -5 12 4</p></blockquote><img src="https://picdm.sunbangyan.cn/2023/12/20/0be08d3da5280c4f716a374f44ec34eb.jpeg" alt="插入演示" /><p>那么要使从 pos 后的元素均后移，这里是<strong>从下标从 1 开始的视角</strong>看待的，也就是我们人类的视角。<br>那么<strong>从数组下标的角度</strong>来看的话：即 pos - 1 及其之后的元素均后移。<br>之后 pos - 1 的处的元素就空出来了，也就是说这一步要达到的效果就是：<strong>通过某种手段，将 pos 后的元素后移，使得 pos 处的元素空出来，之后直接插入即可。</strong></p><h3 id="4-7-2-代码实现"><a href="#4-7-2-代码实现" class="headerlink" title="4.7.2 代码实现"></a>4.7.2 代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">array_Insert</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> val )</span> <span class="comment">//pos的值从 1 开始，即插入后的次序（以正常视角）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array_IsFull( pArr ) )&#123;    <span class="comment">// 已满，不能插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( pos &lt; <span class="number">1</span> || pos &gt; pArr-&gt;count + <span class="number">1</span> )&#123;    <span class="comment">// pos 的值不合法时不能插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前元素个数-1 = 最后一个元素下标</span></span><br><span class="line">    <span class="comment">// 终止条件：当 i = pos - 1 时终止，即此时的位置留给 val</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = pArr-&gt;count - <span class="number">1</span>; i &gt;= pos - <span class="number">1</span>; i-- )&#123; <span class="comment">//pos 后的元素先右移，再插入 val</span></span><br><span class="line">        pArr-&gt;pBase[i + <span class="number">1</span>] = pArr-&gt;pBase[i];    <span class="comment">// i 赋给 i+1，元素右移</span></span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;pBase[pos - <span class="number">1</span>] = val; <span class="comment">// 插入数据 val</span></span><br><span class="line">    pArr-&gt;count++;  <span class="comment">// 有效元素个数自增</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-3-测试"><a href="#4-7-3-测试" class="headerlink" title="4.7.3 测试"></a>4.7.3 测试</h3><p>原数组为：</p><blockquote><p>1 34 -5 12 4</p></blockquote><p>在第 3 个位置插入 0，则插入之后的数组为</p><blockquote><p>1 34 0 -5 12 4</p></blockquote><p><strong>输入样例：</strong></p><blockquote><p>6</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>初始化的数组长度：6<br>1 34 -5 12 4<br>插入成功！插入的元素是：0<br>1 34 0 -5 12 4</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span>     <span class="comment">//包含了malloc函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">//包含了exit函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> * pBase;    <span class="comment">// 存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">// 数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 当前数组有效元素的个数，即当前元素个数。</span></span><br><span class="line">&#125;Array;     <span class="comment">// 结构体别名 &amp;&amp; 分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Inverse</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Insert</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> val )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array arr;  <span class="comment">// 定义了一个结构体变量，名字是 arr</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化的数组长度：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;length);</span><br><span class="line">    array_Init(&amp;arr, length);   <span class="comment">// 初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：追加</span></span><br><span class="line">    array_Append(&amp;arr, <span class="number">1</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">34</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">-5</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">12</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">4</span>);</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  // 测试：翻转、倒置</span></span><br><span class="line"><span class="comment">//  array_Inverse(&amp;arr);</span></span><br><span class="line"><span class="comment">//  array_Traverse(&amp;arr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：插入</span></span><br><span class="line">    <span class="keyword">if</span> ( array_Insert(&amp;arr, <span class="number">3</span>, <span class="number">0</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功！插入的元素是：%d\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span></span><br><span class="line">&#123;</span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == pArr-&gt;pBase )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pArr-&gt;length = length;</span><br><span class="line">        pArr-&gt;count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> == pArr-&gt;count )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pArr-&gt;count == pArr-&gt;length )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组为空！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;count; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pArr-&gt;pBase[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsFull( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pArr-&gt;pBase[pArr-&gt;count] = val;</span><br><span class="line">    (pArr-&gt;count)++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Inverse</span> <span class="params">( Array * pArr )</span><span class="comment">// 折半思想</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;count / <span class="number">2</span>; i++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[pArr-&gt;count - <span class="number">1</span> - i];</span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;count - <span class="number">1</span> - i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Insert</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> val )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array_IsFull( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( pos &lt; <span class="number">1</span> || pos &gt; pArr-&gt;count + <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = pArr-&gt;count - <span class="number">1</span>; i &gt;= pos - <span class="number">1</span>; i-- )&#123;</span><br><span class="line">        pArr-&gt;pBase[i + <span class="number">1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;pBase[pos - <span class="number">1</span>] = val;</span><br><span class="line">    pArr-&gt;count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-8-删除-array-Delete"><a href="#4-8-删除-array-Delete" class="headerlink" title="4.8 删除 array_Delete()"></a>4.8 删除 array_Delete()</h2><p>跟插入差不多其实。</p><h3 id="4-8-1-算法步骤"><a href="#4-8-1-算法步骤" class="headerlink" title="4.8.1 算法步骤"></a>4.8.1 算法步骤</h3><blockquote><ol><li>删除，可能成功，可能失败。bool</li><li>如果 pos &lt; 1 || pos &gt; count 插入失败</li><li>返回要删除 pos 位置的数据</li><li>删除完毕后，pos 后的元素前移</li></ol></blockquote><h3 id="4-8-2-注意事项"><a href="#4-8-2-注意事项" class="headerlink" title="4.8.2 注意事项"></a>4.8.2 注意事项</h3><blockquote><ol><li>在删除之前，应该先返回要删除的值，以便于清除删除了哪个数据。</li><li>下标不一致的问题：删除操作的话，直接把从 pos 位置后的元素前移就可以了，相当于直接覆盖了。pos 也是从 1 开始，所以 for 循环内是 count，而不是 count - 1。</li></ol></blockquote><p><strong>画图</strong>，不懂就画图：</p><img src="https://picst.sunbangyan.cn/2023/12/21/a692f0e7c3a129fe90d62e64775a99ed.jpeg" alt="删除演示" /><p>原数组为：</p><blockquote><p>1 34 0 -5 12 4</p></blockquote><p>删除第 3 个位置的 0，则删除之后的数组为：</p><blockquote><p>1 34 -5 12 4</p></blockquote><h3 id="4-8-3-代码实现"><a href="#4-8-3-代码实现" class="headerlink" title="4.8.3 代码实现"></a>4.8.3 代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Delete_arr</span><span class="params">(<span class="keyword">struct</span> Arr * pArr, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Is_empty(pArr))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; pArr-&gt;cnt)&#123; <span class="comment">// 只能删除已有的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *pVal = pArr-&gt;pBase[pos<span class="number">-1</span>]; <span class="comment">// 返回要删除 pos 位置的数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = pos; i &lt; pArr-&gt;cnt; i++)&#123; <span class="comment">// 删除完毕后，pos 位置后的元素再左移</span></span><br><span class="line">        pArr-&gt;pBase[i<span class="number">-1</span>] = pArr-&gt;pBase[i];  <span class="comment">// 元素左移</span></span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;cnt--;    <span class="comment">// 有效元素个数自减</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-4-测试"><a href="#4-8-4-测试" class="headerlink" title="4.8.4 测试"></a>4.8.4 测试</h3><p>原数组为：</p><blockquote><p>1 34 0 -5 12 4</p></blockquote><p>删除第 3 个位置的 0，则删除之后的数组为：</p><blockquote><p>1 34 -5 12 4</p></blockquote><p><strong>输入样例：</strong></p><blockquote><p>6</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>初始化的数组长度：6<br>1 34 -5 12 4<br>插入成功！插入的元素是：0<br>1 34 0 -5 12 4<br>删除成功！删除的元素是：0<br>1 34 -5 12 4</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span>     <span class="comment">//包含了malloc函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">//包含了exit函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> * pBase;    <span class="comment">// 存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> length;     <span class="comment">// 数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 当前数组有效元素的个数，即当前元素个数。</span></span><br><span class="line">&#125;Array;     <span class="comment">// 结构体别名 &amp;&amp; 分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Inverse</span> <span class="params">( Array * pArr )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Insert</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> val )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Delete</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> * pVal )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array arr;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化的数组长度：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;length);</span><br><span class="line">    array_Init(&amp;arr, length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：追加</span></span><br><span class="line">    array_Append(&amp;arr, <span class="number">1</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">34</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">-5</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">12</span>);</span><br><span class="line">    array_Append(&amp;arr, <span class="number">4</span>);</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  // 测试：翻转、倒置</span></span><br><span class="line"><span class="comment">//  array_Inverse(&amp;arr);</span></span><br><span class="line"><span class="comment">//  array_Traverse(&amp;arr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：插入</span></span><br><span class="line">    <span class="keyword">if</span> ( array_Insert(&amp;arr, <span class="number">3</span>, <span class="number">0</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入成功！插入的元素是：%d\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试：删除</span></span><br><span class="line">    <span class="type">int</span> pVal;</span><br><span class="line">    <span class="keyword">if</span> ( array_Delete(&amp;arr, <span class="number">3</span>, &amp;pVal) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功！删除的元素是：%d\n&quot;</span>, pVal);</span><br><span class="line">    &#125;</span><br><span class="line">    array_Traverse(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Init</span><span class="params">( Array * pArr, <span class="type">int</span> length )</span></span><br><span class="line">&#123;</span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> == pArr-&gt;pBase )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pArr-&gt;length = length;</span><br><span class="line">        pArr-&gt;count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsEmpty</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> == pArr-&gt;count )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_IsFull</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pArr-&gt;count == pArr-&gt;length )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Traverse</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组为空！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;count; i++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pArr-&gt;pBase[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Append</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( array_IsFull( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pArr-&gt;pBase[pArr-&gt;count] = val;</span><br><span class="line">    (pArr-&gt;count)++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_Inverse</span> <span class="params">( Array * pArr )</span><span class="comment">// 折半思想</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;count / <span class="number">2</span>; i++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[pArr-&gt;count - <span class="number">1</span> - i];</span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;count - <span class="number">1</span> - i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Insert</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> val )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array_IsFull( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( pos &lt; <span class="number">1</span> || pos &gt; pArr-&gt;count + <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = pArr-&gt;count - <span class="number">1</span>; i &gt;= pos - <span class="number">1</span>; i-- )&#123;</span><br><span class="line">        pArr-&gt;pBase[i + <span class="number">1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;pBase[pos - <span class="number">1</span>] = val;</span><br><span class="line">    pArr-&gt;count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">array_Delete</span><span class="params">( Array * pArr, <span class="type">int</span> pos, <span class="type">int</span> * pVal )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( pos &lt; <span class="number">1</span> || pos &gt; pArr-&gt;count )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *pVal = pArr-&gt;pBase[pos - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = pos; i &lt; pArr-&gt;count; i++ )&#123;</span><br><span class="line">        pArr-&gt;pBase[i - <span class="number">1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;count--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-9-查找-array-Find"><a href="#4-9-查找-array-Find" class="headerlink" title="4.9 查找 array_Find()"></a>4.9 查找 array_Find()</h2><p>即查找某个元素，如果存在返回下标，不存在返回 -1。</p><h3 id="1、循环遍历"><a href="#1、循环遍历" class="headerlink" title="1、循环遍历"></a>1、循环遍历</h3><p><strong>前提条件：无重复元素。</strong><br>遍历数组，如果在数组中找到与待查找元素 val 相等的元素，返回下标即可。</p><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_Find</span> <span class="params">( Array * pArr, <span class="type">int</span> val )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array_IsEmpty( pArr ) )&#123;   <span class="comment">// 数组是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;count - <span class="number">1</span>; i++ )&#123;    <span class="comment">// 遍历查找</span></span><br><span class="line">        <span class="keyword">if</span> ( val == pArr-&gt;pBase[i] )&#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 终止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入样例：</strong></p><blockquote><p>初始化的数组长度：6<br>1 34 -5 12 4<br>输入要查找的元素：<br>12</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>3</p></blockquote><h3 id="2、二分查找"><a href="#2、二分查找" class="headerlink" title="2、二分查找"></a>2、二分查找</h3><blockquote><p>具体的关于二分的知识可以去看之前写的二分查找的帖子：<a href="https://akari2333.github.io/posts/42877/">二分查找 | Akari的小站</a><br><em>参考：<a href="https://zhuanlan.zhihu.com/p/348582409">二分查找算法，数组有序不是必要条件！ - 知乎</a></em></p></blockquote><ol><li>关于二分查找的要求：</li></ol><blockquote><p><strong>1. 必须有序：</strong></p><p>二分查找算法的前提是要在有序数组中进行查找。在无序数组中使用二分查找是不可行的，因为二分查找的基本思想是通过比较中间元素与目标值的大小关系，缩小查找范围。</p><p>如果数组是无序的，无法通过比较中间元素的大小关系来确定目标值在数组的哪一部分，因此无法有效地缩小查找范围。在这种情况下，通常会选择其他查找算法，比如线性查找，它可以在无序数组中进行查找。</p><p>总结起来，二分查找适用于有序数组，而线性查找等算法适用于无序数组。</p><p><strong>2. 可以无序，但是有条件：</strong></p><p>先来一段维基百科概念。“<strong>二分查找算法</strong>，也称<strong>折半搜索算法</strong>，是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。”</p><p>简单来说，就是在序列中找到一个分割点，使得我们需要找的答案一定在某一边的子序列而不在另一边的子序列，之后继续在找到子序列中给出分割点，无限二分下去直到找到目标，这使得原本需要一次遍历的查找时间复杂度降为了*O(log N)*。<br>若要将二分查找推广应用，这里有很重要的一点是：<strong>使用二分查找不一定要求数组是有序的</strong>。只需要能够找到一个分割点，将序列分为两个类别即可，通常来说这个分割点用中点。上述最基础的二分法是分为哪两个类别呢？小于中间值的为一类，大于中间值的为另一类。如果在无序的数组中，可以将数组按不同的方法分类。</p><p><strong>因此，记住一点，使用二分法不一定要求有序，只要求可以确定答案一定会出现在其中一边即可。但是一般条件比较苛刻！</strong></p></blockquote><ol start="2"><li>代码实现：</li></ol><p><strong>1、二分查找：左闭右闭：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_Find</span> <span class="params">( Array * pArr , <span class="type">int</span> val )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = pArr-&gt;count - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt;= right )&#123;</span><br><span class="line">        <span class="type">int</span> middle = ( right - left ) / <span class="number">2</span> + left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( val &lt; pArr-&gt;pBase[middle] )&#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( val &gt; pArr-&gt;pBase[middle] )&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、二分查找：左闭右开：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_Find</span> <span class="params">( Array * pArr , <span class="type">int</span> val )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array_IsEmpty( pArr ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = pArr-&gt;count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt; right )&#123;</span><br><span class="line">        <span class="type">int</span> middle = ( right - left ) / <span class="number">2</span> + left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( val &lt; pArr-&gt;pBase[middle] )&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( val &gt; pArr-&gt;pBase[middle] )&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-10-排序"><a href="#4-10-排序" class="headerlink" title="4.10 排序"></a>4.10 排序</h2><p>因为目前学了选择、冒泡、快排，所以就想着都实现一下。<br>附上之前写的帖子：<del>(大佬轻喷······)</del></p><ul><li><a href="https://akari2333.github.io/posts/61129/">十大排序—选择排序 | Akari的小站</a></li><li><a href="https://akari2333.github.io/posts/38023/">十大排序——快速排序 | Akari的小站</a></li></ul><p><del>嘶~ 突然想起来，冒泡的帖子我一直拖拖拖······到现在也没写······（才···才不是因为懒呢！）</del></p><h3 id="4-10-1-选择排序"><a href="#4-10-1-选择排序" class="headerlink" title="4.10.1 选择排序"></a>4.10.1 选择排序</h3><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_SortSelete</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;count - <span class="number">1</span>; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> j = i + <span class="number">1</span>; j &lt; pArr-&gt;count; j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( pArr-&gt;pBase[i] &gt; pArr-&gt;pBase[j] )&#123;</span><br><span class="line">                <span class="type">int</span> t = pArr-&gt;pBase[i];</span><br><span class="line">                pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">                pArr-&gt;pBase[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-2-冒泡排序"><a href="#4-10-2-冒泡排序" class="headerlink" title="4.10.2 冒泡排序"></a>4.10.2 冒泡排序</h3><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_SortBubble</span> <span class="params">( Array * pArr )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;count - <span class="number">1</span>; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; pArr-&gt;count - <span class="number">1</span> - i; j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( pArr-&gt;pBase[j] &gt; pArr-&gt;pBase[j + <span class="number">1</span>] )&#123;</span><br><span class="line">                <span class="type">int</span> t = pArr-&gt;pBase[j];</span><br><span class="line">                pArr-&gt;pBase[j] = pArr-&gt;pBase[j + <span class="number">1</span>];</span><br><span class="line">                pArr-&gt;pBase[j + <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-3-快速排序"><a href="#4-10-3-快速排序" class="headerlink" title="4.10.3 快速排序"></a>4.10.3 快速排序</h3><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快排母函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_SortQuick</span><span class="params">( Array * pArr , <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( low &lt; high )&#123;</span><br><span class="line">        pos = FindPos( pArr, low, high );</span><br><span class="line">        array_SortQuick( pArr, low, pos - <span class="number">1</span> );</span><br><span class="line">        array_SortQuick( pArr, pos + <span class="number">1</span>, high );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( low &gt;= high )&#123;     <span class="comment">// 直接返回，避免无限递归</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准分割函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span> <span class="params">( Array * pArr, <span class="type">int</span> low, <span class="type">int</span> high )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = pArr-&gt;pBase[low];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( low &lt; high )&#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; pArr-&gt;pBase[high] &gt;= val )&#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        pArr-&gt;pBase[low] = pArr-&gt;pBase[high];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; pArr-&gt;pBase[low] &lt;= val )&#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        pArr-&gt;pBase[high] = pArr-&gt;pBase[low];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;pBase[low] = val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AcWing】C语言入门讲义</title>
      <link href="/posts/13071/"/>
      <url>/posts/13071/</url>
      
        <content type="html"><![CDATA[<p><strong>ACWing</strong> 学习笔记。<br><a href="https://www.acwing.com/blog/content/38415/">C语言入门讲义 - AcWing</a></p><hr><h1 id="三、变量类型"><a href="#三、变量类型" class="headerlink" title="三、变量类型"></a>三、变量类型</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;  <span class="comment">//定义了一个int型的a变量 这里a的大小不能超过 2147483647,你们只需要记住int最大能存 10^9 的数就行; </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b;    <span class="comment">//定义了一个long long型的b变量 当你需要定义超过 10^9 次方数的时候 就需要用 long long 型的变量;</span></span><br><span class="line"><span class="type">char</span> c;     <span class="comment">//定义了一个字符c;</span></span><br><span class="line"><span class="type">float</span> d;    <span class="comment">//定义了一个浮点数(小数)d，例如33.2;</span></span><br><span class="line"><span class="type">double</span> e;   <span class="comment">//定义了一个双浮点数e, 例如33.2;</span></span><br></pre></td></tr></table></figure><p>另外还有 无符号类型 <code>unsigned</code> 表示的范围再大一点。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>下表列出了关于标准整数类型的存储大小和值范围的细节：<br><img src="https://picdm.sunbangyan.cn/2023/12/05/6f0eaf9a3a1c5f3eaf3caf38e3b345fd.jpeg" alt="1" /></p><blockquote><p>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。<br>以下列出了32位系统与64位系统的存储大小的差别（windows 相同）：<br><img src="https://picst.sunbangyan.cn/2023/12/05/f4b62497fec5050c91217d37c275c4df.jpeg" alt="2" /></p></blockquote><p>为了得到某个类型或某个变量在特定平台上的准确大小，可以使用 <strong>sizeof</strong> 运算符。表达式 <strong>sizeof(type)</strong> 得到对象或类型的存储字节大小。如获取 int 类型的大小：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;int 存储大小 : %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%lu 为 32 位无符号整数。输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int 存储大小 : 4</span><br></pre></td></tr></table></figure><h1 id="十、数组"><a href="#十、数组" class="headerlink" title="十、数组"></a>十、数组</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>学习字符串 需要一个新的头文件 <code># include&lt;string.h&gt;</code> 里面包括 <code>strlen()</code> 等….</p></li><li><p>‘a’ ‘c’ 表示字符</p></li><li><p>“helloworld” 表示 字符串</p></li><li><p><strong>表示字符串</strong> 需要用 <code>char数组</code></p></li><li><p><strong>输入字符串</strong> 用 <code>%s</code> 且 <code>scanf</code> 不需要 <code>&amp;</code> 符号</p></li><li><p><code>scanf(&quot;%s&quot;,c);     //输入字符串会默认空格或者回车为输入结束</code></p></li><li><p>注意：有时候需要使用 <strong>getchar()</strong> 吸收 <strong>空格、回车</strong></p></li></ul><h2 id="多个字符串"><a href="#多个字符串" class="headerlink" title="多个字符串"></a>多个字符串</h2><p>当有多个字符串时，考虑用 <strong>二位字符数组</strong>，因为我们知道一个 一维char数组 可以表示 一个字符串，所有我们用 二维char数组，那么 <strong>char[][]</strong> 第一个 [] 代表有多少个字符串 第二个 [] 代表字符串大小</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">20</span>][<span class="number">40</span>]      </span><br><span class="line"><span class="comment">//第一个[20]表示有20个字符串，第二个[40]表示每个字符串的大小为40</span></span><br></pre></td></tr></table></figure><h1 id="十一、排序"><a href="#十一、排序" class="headerlink" title="十一、排序"></a>十一、排序</h1><p>排序 基本对数组进行操作<br>从小到大排序<br>从大到小排序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序 模板</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">25</span>,<span class="number">35</span>,<span class="number">68</span>,<span class="number">79</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">98</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">62</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i,j,t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)      <span class="comment">//需要排的轮数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)<span class="comment">//当前轮数需要比较相邻的次数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>]) <span class="comment">//如果当前大于后面 要交换一下</span></span><br><span class="line">            &#123;               <span class="comment">//a[j]&gt;a[j+1] 为从小到大排序</span></span><br><span class="line">                            <span class="comment">//a[j]&lt;a[j+1] 为从大到小排序</span></span><br><span class="line">                t=a[j];</span><br><span class="line">                a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown中图片的相关操作</title>
      <link href="/posts/6566/"/>
      <url>/posts/6566/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、图片的位置"><a href="#一、图片的位置" class="headerlink" title="一、图片的位置"></a>一、图片的位置</h1><h2 id="1-1-左"><a href="#1-1-左" class="headerlink" title="1.1 左"></a>1.1 左</h2><p>代码一：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">left</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>代码二：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片说明</span>](<span class="link">图片链接#pic_left</span>)</span><br></pre></td></tr></table></figure><div align=left><img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%"/></div><h2 id="1-2-中"><a href="#1-2-中" class="headerlink" title="1.2 中"></a>1.2 中</h2><p>代码一：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>代码二：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片说明</span>](<span class="link">图片链接#pic_center</span>)</span><br></pre></td></tr></table></figure><div align=center><img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%"/></div><h2 id="1-3-右"><a href="#1-3-右" class="headerlink" title="1.3 右"></a>1.3 右</h2><p>代码一：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">right</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>代码二：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片说明</span>](<span class="link">图片链接#pic_right</span>)</span><br></pre></td></tr></table></figure><div align=right><img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%"/></div><h1 id="二、图片的缩放"><a href="#二、图片的缩放" class="headerlink" title="二、图片的缩放"></a>二、图片的缩放</h1><p>代码一</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片说明&quot;</span> <span class="attr">width</span>=<span class="string">400</span> <span class="attr">height</span>=<span class="string">300/</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>代码二</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%"/><h1 id="三、图片在文本的旁边"><a href="#三、图片在文本的旁边" class="headerlink" title="三、图片在文本的旁边"></a>三、图片在文本的旁边</h1><h2 id="3-1-图片在文本的左边"><a href="#3-1-图片在文本的左边" class="headerlink" title="3.1 图片在文本的左边"></a>3.1 图片在文本的左边</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;float: left; margin-right: 10px;&quot;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><div style="float: left; margin-right: 10px;">  <img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%" /></div><p>鬼头明里<br>鬼头明里<br>鬼头明里<br>鬼头明里<br>鬼头明里<br>鬼头明里</p><div style="clear: both;"></div><h2 id="3-2-图片在文本的右边"><a href="#3-2-图片在文本的右边" class="headerlink" title="3.2 图片在文本的右边"></a>3.2 图片在文本的右边</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;float: right; margin-right: 10px;&quot;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><div style="float: right; margin-left: 10px;">  <img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%" /></div><p>鬼头明里<br>鬼头明里<br>鬼头明里<br>鬼头明里<br>鬼头明里<br>鬼头明里</p><div style="clear: both;"></div><h2 id="3-3-注意的问题"><a href="#3-3-注意的问题" class="headerlink" title="3.3 注意的问题"></a>3.3 注意的问题</h2><p>在Markdown中，浮动元素可能受到前面元素的影响，尤其是如果前一个元素是浮动元素。为了解决这个问题，可以在第二个图片的<code>&lt;div&gt;</code>元素之前加一个清除浮动的元素。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="四、并排显示"><a href="#四、并排显示" class="headerlink" title="四、并排显示"></a>四、并排显示</h1><h2 id="4-1-两张居左并排"><a href="#4-1-两张居左并排" class="headerlink" title="4.1 两张居左并排"></a>4.1 两张居左并排</h2><p>代码一</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display: flex; justify-content: flex-start;&quot;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片1链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片1说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片2链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片2说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>代码二</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">figure</span> <span class="attr">style</span>=<span class="string">&quot;text-align: left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;img src=&quot;图片链接&quot; alt=&quot;图片说明&quot; style=&quot;zoom:30%&quot;/&gt;</span></span><br><span class="line"><span class="code">    &lt;img src=&quot;图片链接&quot; alt=&quot;图片说明&quot; style=&quot;zoom:30%&quot;/&gt;</span></span><br><span class="line"><span class="code">&lt;/figure&gt;</span></span><br></pre></td></tr></table></figure><figure style="text-align: left">    <img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%"/>    <img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%"/></figure><h2 id="4-2-两张居中并排"><a href="#4-2-两张居中并排" class="headerlink" title="4.2 两张居中并排"></a>4.2 两张居中并排</h2><p>代码一</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display: flex; justify-content: center;&quot;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片1链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片1说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片2链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片2说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>代码二</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">figure</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;img src=&quot;图片链接&quot; alt=&quot;图片说明&quot; style=&quot;zoom:30%&quot;/&gt;</span></span><br><span class="line"><span class="code">    &lt;img src=&quot;图片链接&quot; alt=&quot;图片说明&quot; style=&quot;zoom:30%&quot;/&gt;</span></span><br><span class="line"><span class="code">&lt;/figure&gt;</span></span><br></pre></td></tr></table></figure><figure style="text-align: center">    <img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%"/>    <img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%"/></figure><h2 id="4-3-两张居右并排"><a href="#4-3-两张居右并排" class="headerlink" title="4.3 两张居右并排"></a>4.3 两张居右并排</h2><p>代码一</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display: flex; justify-content: flex-end;&quot;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片1链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片1说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片2链接&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片2说明&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:30%&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>代码二</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">figure</span> <span class="attr">style</span>=<span class="string">&quot;text-align: right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;img src=&quot;图片链接&quot; alt=&quot;图片说明&quot; style=&quot;zoom:30%&quot;/&gt;</span></span><br><span class="line"><span class="code">    &lt;img src=&quot;图片链接&quot; alt=&quot;图片说明&quot; style=&quot;zoom:30%&quot;/&gt;</span></span><br><span class="line"><span class="code">&lt;/figure&gt;</span></span><br></pre></td></tr></table></figure><figure style="text-align: right">    <img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%"/>    <img src="https://picst.sunbangyan.cn/2023/12/02/b35de510a8cee42847a9ae839bb87dc0.jpeg" alt="1280px-Tsukasa_by_Akari" style="zoom:30%"/></figure>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话数据结构》笔记</title>
      <link href="/posts/19952/"/>
      <url>/posts/19952/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><ol><li>目前先这样记着吧，以后再搞“笔记本”的功能······</li><li>目前大概想法是结合<strong>郝斌老师</strong>的笔记、GPT</li></ol><hr><h1 id="第1章-数据结构绪论"><a href="#第1章-数据结构绪论" class="headerlink" title="第1章 数据结构绪论"></a>第1章 数据结构绪论</h1><p>数据结构：是相互之间存在一种或多种特定关系的数据结构元素的集合</p><h2 id="1-3-数据结构起源"><a href="#1-3-数据结构起源" class="headerlink" title="1.3 数据结构起源"></a>1.3 数据结构起源</h2><p>&emsp;&emsp;早期人们都把计算机理解为数值计算工具,就是感觉计算机当然是用来计算的,所以计算机解决问题,应该是先从具体问题中抽象出一个适当的数据模型,设计出一个解决此数据模型的算法,然后再编写程序，得到一个实际的软件。<br>&emsp;&emsp;可现实中更多的不是解决数值计算的问题，而是需要一些更科学有效的手段（比如表、树、和图等数据结构）的帮助，才能更好地处理问题。所以：</p><blockquote><p>&emsp;&emsp;<strong>数据结构是一门研究非数值计算的程序设计中的操作对象，以及它们之间的关系和操作系统等相关问题的学科。</strong></p></blockquote><p>&emsp;&emsp;之后，人门越来越重视“数据结构”，认为<strong>程序设计的实质是对确定的问题选择一种好的结构，加上一种好的算法。</strong>可见，数据结构在程序设计当中占据了重要的地位。</p><h2 id="1-4-基本概念和术语"><a href="#1-4-基本概念和术语" class="headerlink" title="1.4 基本概念和术语"></a>1.4 基本概念和术语</h2><p>&emsp;&emsp;说到数据结构是什么，我们先得来谈谈什么叫<strong>数据</strong>。</p><h3 id="1-4-1-数据"><a href="#1-4-1-数据" class="headerlink" title="1.4.1 数据"></a>1.4.1 数据</h3><p>&emsp;&emsp;<strong>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别到，并输入给计算机处理的符号集合。</strong> 数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。<br>&emsp;&emsp;也就是说，我们这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p><blockquote><ul><li>可以输入到计算机中</li><li>能被计算机程序处理。</li></ul></blockquote><p>&emsp;&emsp;对于整型、实型等数值类型，可以就行数值计算。<br>&emsp;&emsp;对于字符数据结构，就需要进行非数值的处理。而声音、图像、视频等其实是通过编码的手段变成字符数据来处理的。</p><h3 id="1-4-2-数据元素"><a href="#1-4-2-数据元素" class="headerlink" title="1.4.2 数据元素"></a>1.4.2 数据元素</h3><p>&emsp;&emsp;<strong>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。</strong><br>&emsp;&emsp;如：</p><blockquote><ul><li>人类中：🤵；</li><li>畜禽中：🐂、🐎、🐏、🐖、🦆······</li></ul></blockquote><h3 id="1-4-3-数据项"><a href="#1-4-3-数据项" class="headerlink" title="1.4.3 数据项"></a>1.4.3 数据项</h3><p>&emsp;&emsp;<strong>数据项：一个数据元素可以由若干个数据项组成。</strong><br>&emsp;&emsp;如：</p><img src="https://picdl.sunbangyan.cn/2023/12/01/6adcd76098a3f88539d9965e7ba743e0.jpeg" alt="1.4.3" style="zoom:%"/><p>&emsp;&emsp;<strong>数据项：是性质相同的数据元素的集合，是数据的子集。</strong><br>&emsp;&emsp;什么叫性质相同呢？是指数据元素具有相同数量和类型的数据项<br>&emsp;&emsp;比如：人都有 姓名、生日、性别等相同的数据项。<br>&emsp;&emsp;既然数据对象是数据的子集，在实际应用中，处理的数据元素通常具有相同的性质，在不产生混淆的情况下，我们都将<strong>数据对象简称为数据</strong>。</p><h3 id="1-4-5-数据结构"><a href="#1-4-5-数据结构" class="headerlink" title="1.4.5 数据结构"></a>1.4.5 数据结构</h3><p>&emsp;&emsp;结构，简单理解就是关系——比如 分子结构，就是说组成分子的原子之间的排列方式。严格点说，<strong>结构是指各个组成部分相互搭配和排列的方式</strong>。在现实世界中，<strong>不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。</strong> 那数据结构是什么？</p><blockquote><p>&emsp;&emsp;<strong>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</strong></p></blockquote><p>&emsp;&emsp;在计算机中，数据元素并不是孤立、杂乱无章的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。<br>&emsp;&emsp;为编写出一个“好”的程序，必须分析待处理对象的特性及各处理对象之间存在的关系。这也就是研究数据结构的意义所在。</p><h2 id="1-5-逻辑结构和物理结构"><a href="#1-5-逻辑结构和物理结构" class="headerlink" title="1.5 逻辑结构和物理结构"></a>1.5 逻辑结构和物理结构</h2><p>&emsp;&emsp;按照视点的不同，我们把数据结构分为 <strong>逻辑结构</strong> 和 <strong>物理结构</strong>。</p><h3 id="1-5-1-逻辑结构"><a href="#1-5-1-逻辑结构" class="headerlink" title="1.5.1 逻辑结构"></a>1.5.1 逻辑结构</h3><p>&emsp;&emsp;<strong>逻辑结构：是指数据对象中数据元素之间的相互关系。</strong> 这其实也是我们今后最需要关注的问题。逻辑结构分为以下四种。</p><h4 id="1-集合结构"><a href="#1-集合结构" class="headerlink" title="1. 集合结构"></a>1. 集合结构</h4><p>&emsp;&emsp;<strong>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。</strong> 各个数据元素是“平等的”，它们的共同属性是“同属于一个集合”，类似于数学中的集合，如右图所示。</p><p>(图片)</p><h4 id="2-线性结构"><a href="#2-线性结构" class="headerlink" title="2. 线性结构"></a>2. 线性结构</h4><p>&emsp;&emsp;<strong>线性结构：线性结构中的数据元素之间是一对一的关系。</strong> 如右图所示。</p><p>（图片）</p><h4 id="3-树形结构"><a href="#3-树形结构" class="headerlink" title="3. 树形结构"></a>3. 树形结构</h4><p>&emsp;&emsp;<strong>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。</strong>如右图所示。</p><p>（图片）</p><h4 id="4-图形结构"><a href="#4-图形结构" class="headerlink" title="4. 图形结构"></a>4. 图形结构</h4><p>&emsp;&emsp;<strong>图形结构：图形结构中的数据元素是多对多的关系。</strong> 如右图所示。</p><p>&emsp;&emsp;我们在用示意图表示数据的逻辑结构时，要注意两点：</p><blockquote><ul><li>将每一个数据元素看作一个结点，用圆圈表示。</li><li>数据元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示。</li></ul></blockquote><p>&emsp;&emsp;从之前的例子也能看出，逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。</p><h3 id="1-5-2-物理结构"><a href="#1-5-2-物理结构" class="headerlink" title="1.5.2 物理结构"></a>1.5.2 物理结构</h3><p>&emsp;&emsp;再来说说数据的物理结构——很多书中也叫做存储结构，你只要在理解上把它们当成一回事就可以了。</p><blockquote><p>&emsp;&emsp;<strong>物理结构：是指数据的逻辑结构在计算机中的存储形式。</strong></p></blockquote><p>&emsp;&emsp;数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。<br>&emsp;&emsp;数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的，如何存<br>储数据元素之间的逻辑关系，是实现物理结构的重点和难点。<br>数据元素的存储结构形式有两种：顺序存储和链式存储。</p><h4 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="1. 顺序存储结构"></a>1. 顺序存储结构</h4><p>&emsp;&emsp;<strong>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</strong><br>&emsp;&emsp;这种存储结构其实很简单，说白了，就是排队占位。大家都按顺序<br>排好，每个人占一小段空间，大家谁也别插谁的队。我们之前学计算机语言时，数组就是这样的顺序存储结构。当你告诉计算机，你要建立一个有9个整型数据的数组时，计算机就在内存中找了片空地，按照一个整型所占位置的大小乘以9，开辟一段连续的空间，干是第一个数组数据就放在第一个位置，第二个数据放在第二个位置，这样依次摆放。如下图所示。</p><p>（图片）</p><h4 id="2，-链式存储结构"><a href="#2，-链式存储结构" class="headerlink" title="2， 链式存储结构"></a>2， 链式存储结构</h4><p>&emsp;&emsp;如果就是这么简单和有规律，一切就好办了。可实际上，总会有人插队，也会有人要上厕所、有人会放弃排队。所以这个队伍当中会添加新成员。也有可能会去掉老元素，整个结构时刻都处干变化中。显然，面对这样时常要变化的结构，顺顶序存储是不科学的。那怎么办呢？<br>&emsp;&emsp;现在如银行、医院等地方，设置了排队系统，也就是每个人去了，先领一个号，等着叫号，叫到时去办理业务或看病。在等待的时候，你爱在哪在哪，可以坐着、站着或者走动，甚至出去逛一圈，只要及时回来就行。你关注的是前一个号也没有被叫到，叫到了，下一个就轮到你了。<br>&emsp;&emsp;<strong>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</strong> 数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。如右图所示。</p><p>（图片，插右边）</p><p>显然,链式存储就灵活多了，数据存在哪里不重要只要有一个指针存放了相应的地址就能找到它了。</p><p>&emsp;&emsp;逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p><h2 id="1-6-数据类型"><a href="#1-6-数据类型" class="headerlink" title="1.6 数据类型"></a>1.6 数据类型</h2><p>&emsp;&emsp;<strong>数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</strong></p><h3 id="1-6-1-数据类型定义"><a href="#1-6-1-数据类型定义" class="headerlink" title="1.6.1 数据类型定义"></a>1.6.1 数据类型定义</h3><p>&emsp;&emsp;数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。<br>&emsp;&emsp;比如，大家都需要不同的房子住，有钱的、没钱的，各种各样的需求，所以有了各种各样的房子——同理，在计算机中，内存不是无限大的，比如计算 1+1&#x3D;2，显然不需要开辟很大的适合小数甚至字符串的内存空间。于是就对数据进行分类，分出来多种数据类型。<br>&emsp;&emsp;在C语言中，按照取值的不同，数据类型可以分为两类：</p><blockquote><p>原子类型</p><ul><li>是不可以再分解的基本类型，包括整型、实型、字符型等。</li></ul><p>结构类型</p><p>* </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【语录】002</title>
      <link href="/posts/52338/"/>
      <url>/posts/52338/</url>
      
        <content type="html"><![CDATA[<p>23:00 与老哥聊天</p><hr><h1 id="19：05"><a href="#19：05" class="headerlink" title="19：05"></a>19：05</h1><ul><li>长鑫存储此次发布的LPDDR5产品包括：12Gb的LPDDR5颗粒，POP（Package on Package）封装的12GB LPDDR5芯片及DSC封装的6GB LPDDR5芯片。<br>其中，12GB LPDDR5芯片目前已在国内主流手机厂商小米、传音等品牌机型上完成验证。</li></ul><h1 id="22：50"><a href="#22：50" class="headerlink" title="22：50"></a>22：50</h1><ul><li>看不懂斯密达</li><li>😒 不信 😐</li><li>我很少关注这些东西了</li><li>就是国产突破lpddr5了<br>以后内存条该降价了（应该是吧）</li><li>我还以为一直都有呢</li><li>好像以前就有，不过这次是更好的ddr5</li><li>降价我也没什么需求</li><li>我也没有 😺</li><li>玩互联网越久才发现虽然资源很珍贵<br>但是价值取决于社会价值<br>我自己那些乱七八糟的回忆没有人的加成毫无意义</li><li>😳</li><li>我现在看到以前那些照片<br>虽然觉得很珍贵<br>但是没了也不会很难过<br>生活还是要继续<br>当下才是最重要的<br>怀念过去固然重要  好好生活更重要<br>我上次把几十g的回忆不小心删了<br>当时真的好难过<br>后面就慢慢释怀了</li><li>😳</li><li>那些人和故事都翻篇了<br>虽然有时候真的很不舍</li><li>😭 我又想起了往事</li><li>😼</li><li>你接着说<br>我听着</li><li>不说了</li><li>😳 好</li><li>我突然想起来我保存了好多别人的生活<br>觉得有些难过</li><li>我保存了一点老哥的生活 😳</li><li>关于自己却没有太多的记录<br>有很多都是跟自己没有一点联系的<br>😂<br>这也是你的部分生活<br>明天不上班了<br>开始找工作了</li><li>😳</li><li>我最近都在贴广告<br>我真服了</li><li>😥</li><li>我一个月没碰过电脑了<br>我都怀疑我的工作了</li><li>老哥不哭 😳</li><li>我以为老板看上了我会计算机<br>结果是廉价劳动力 😎</li><li>😳</li><li>我去修电脑都没这么无语过<br>这种工作还需要找大学生嘛 😎</li><li>老哥不是说找运维之类的</li><li>这个也是运维啊<br>就是什么脏活累活都要做 😓</li><li>😳</li><li>刚开始还好<br>后来就乱七八糟了</li></ul><hr><p>······<br>服了，以上内容写完后我就推，就是推不上去······来回换都不行😭，我还想让老哥看的······</p><ul><li>我试了好多，就是推不上去，我还想让老哥看的 实验室断网了</li><li>你应该保留那几句就好了 😎</li><li>有时间给你找一下 你那个应该有一些缺陷</li><li>😳</li><li>明天早上我一定让老哥看到 😭</li><li>看什么</li><li>文章 😳</li><li>你还是多钻研一下专业知识</li><li>😭 那确实 😔</li><li>今天面试给我打回原型</li><li>多研究研究技术层面的东西</li><li>你可以看看反思001 😔</li><li>太卡了 手机上还是看不了</li><li>密码改了，是XXX</li><li>微信可以看 我via打不开</li><li>谷歌浏览器打不开</li><li>微信 直接打开</li><li>因为输入法没监听到这是结束输入 你代码有点问题</li><li>那不是我写的</li><li>你把代码给GPT改一下 明天再看吧</li><li>好<br>我都不知道哪一部分代码</li><li>啊这</li><li>这是后来装的 install hexo 那啥啥</li><li>安装有配置文件啊</li><li>这是额外加的功能</li><li>有时间我去研究一下 😎</li><li>前天加的，至于装了之后代码在哪我就不知道了······</li><li>叫你解决不知道猴年马月</li><li>😘</li><li>很多东西还是要学会自己解决<br>互联网教程解决不了再问别人</li><li>确实<br>我这几天没怎么管blog的优化</li><li>很多东西别人学的时候有体系化<br>你单独学会你的那个电脑出现的问题没什么太大的用处</li><li>（blog）不都是这样吗，还有就是我想实现的功能我都去群里先问一下以有一个大致的方向</li><li>大部分时候其实不是这样的<br>而是先理解教程每一步的效果和原因再去推导问题的解决方法</li><li>我指的是我现在的blog状态<br>我哪有时间系统学web 😭</li><li>blog是这样<br>搜索习惯还是不够好</li><li>其实是懒（bushi）😥</li><li>好好好 这样说是吧</li><li>也不是 开个玩笑 我是先问群友一下 再去搜</li><li>为了效率可以直接问人<br>为了学习还是建议先去网上找答案<br>事实上大部分教程是没问题的</li><li>确实 😳</li><li>问题就出在每个人的电脑环境以及每个人的表达能力不一样<br>早点休息吧</li><li>好</li></ul><hr><p><a href="https://npfs06.top/2021/06/26/hexo-blog-encrypt%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E6%97%A0%E5%8F%8D%E5%BA%94/">hexo-blog-encrypt输入密码无反应 | 安小琪’s blog</a><br>不过这个需要有自定义域名······</p>]]></content>
      
      
      <categories>
          
          <category> 空_无 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空_无 </tag>
            
            <tag> 生活日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【反思】001——2023/11/30</title>
      <link href="/posts/47933/"/>
      <url>/posts/47933/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="此文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="275ba82038a4fd0313bf7e3d65fdc68280227bbaa5bfaf05b26e3ffee7a5e366">575a88b480ecfe5d2ccbf0b23c994b0b1765327913549d8a01d83b81569d5109c6c7332d6eab11a740f7b711d1d07b6da399706c9cb3a88a7d7946d134cfe66242f9c5a5c3d2c58e49af95179d346fc5303bf678cb5a2ef4b45669fdb870b303997d09728dda63a81f276b9dafd1d1890a6f6c6c5d42391fbd3d74a066ae15ff5c8ba158034a9c2f9d135c2ac558344cf9faf7decc560241d0adcd6d832e4e2fe719e5ff3e3cc2224b17c552773708301375088e0395c2a078335a51d9f4ef2e41bd51f7aaf5d232a740d8486e77372787b10b43777d104f9eb55c67f777f6273cb126c597c68d0bdeca65d25ceb2fa424ca861f6e2e10918718ef47e5837b4bf084de99323d92548fae201d33ad73c453e0fe3b6aad8a8958629ecbbac6abb6b930cd8265b5310f98461c0244ab249b9e75b472e7255db96c061521cecbbb0cfd85da646f08470bb9b24058776c387d5aa03d0a31c3fb1c27de64d209edf2ecc8b0ebfeb9ece2f18fb61a4fc7883accc1bb80356c9bf5cd973c4f729dc9fcac4659664292bfdb592687ed328f16493ac87559f896a5e248480187aa8c08066dbfbe9a7569cd2fdb737607a2b8ba00f4c794b04df5a42eb453801a265be91c0f3ed057faf930dbef484c633a26bad20d3c40c88cfdd3a526baa9ee37b0da7cd7fae4e9f075ec35d957996d58e5a2763cceb3982135690499e70adb830affac0cc532fd3809d66b8fec6ac9544452284649cd24283d373c6a73215557e2a5c91af47585b1530d07c8b38f40a0986e1e4b8f999c0623b2e9896f072fa90144c2e68b785fb972dd4c222b7f81615578129dd125264deaf899592d1df497080cef43d40141b41aad0584698ca0831260e4b44a48a9e8bfd2d21d7ecb85bfd0fa13cfdb5208bea9de09c536466c41b37de6102fdbf3a81bae52cf12d46fc24ba8b30c385c601a2339922bc7005b3b17ee49e89659e0e4e92322f3fe58727f07c73cbd5ea54c7cc1e85c9fe60b45997dbac3b344ef6e730f8eaa35b62220b99a5e822b037f71e7d34500313b8e82abc3984f6697be57261aca77dca905ec56404dfdf8326662ef1a8e5c0703741532bcfb7d928bbde1b97101eb6538116845d316b705b6a444e213a547bb10a14c9e63dc8ac65b7e0842bde84507fbb3033762c48502fea61aab436f38ab76eefa0455fe6475004110a20b1add89c9b6789aded22ab561f91ad40ff01b23939b4dc6273fc4b5ed23090b11d4ab81e905204e5572703978f2a55c06611e3796e96a054faec668325c1fae9dd4a8a9078b10a7040b1e4f3c57c7f30e3de1729b3a7566da560814f27f135288936321baa4a5229ffc2e2ba26f6c50069bb9dd560f18c310759e8eb4dbd669543c2ab7f0910aef796ffcfe15b56b4582d805dae4d715749244e9eb06f2b139e84fbd31f6874f181f6e2b39b34921e9482e2f1074a65df52f9777db16b1cb8da4a215a8ec870a9320f360f424aeba482c360356737d7c2355e74f3cf6b16407a342e4a2ef60268c443ea4ba74877f1ae24bb0796fe0d165f9c6799947bd1542b0df152152a83ce5b7469c197b1478c88d453f0e66590b28a36348a375d69eaf87ac0919958bbebb1ba6dba6c0df3fb0323cdfad86ace2cc31d55aae057429fec289ccfff2aadd4395278eb9ecf2995350cf6ee405f2a8d0db562a8b12abc96cd6f61690806fbc77824606720eff30aebcc3dc0ec2e2fe220a4f2c2954a1875d88cbe13c509980d7f32216afb9d4a1e3822807b1a5216df63a8c8315bc012e95777d8b6bcf01eb4830efc97636a281b754ca0948f46728d457be9bbe7ffe2090c58c438fc18a1b7a7304d30b4515a005d4e4d88c1c86cf9a3bfa6a984dcc556f6dc4ee54fd30ec2a9f103b72698d5b3fd0f4599ccc28060a3a7775b582217a9e69ed121456f7c12a4180711260bd06fc41a56223f3e6897e9cc0ce796220b54532db0f617b976799a7618f2d0398f1ed8d4a101555ef9e8911d4fa4c78697f29d6c621c738e662161555fe288d67468469069ec10ac768eaf383cf38e3dd7cbba70d51debfa213d9cbb866b5f1edef2cba3ff502c031074152a4bb66ba23af30b092186babbc000f9b1390f1e54b2ae1a32a363704f0b926497aa18ab4fb42846bac2a1a6e9f115de1dd9a898a11ca843f4ba2a9c698db72dbfaa00fbed3c21a79a320e82bc89396e01aa374c44e6d01de05f973798692b94105da4e9ab1da8b61754b3dee233cb5fd02c567a1787d7c9cab430077a1b553e069da9163b09bb57e0857b91ae834da6dccd727c0f7ab11dbd40540299db206222d4fdc4c97226d09e00f4d94a488ce43da5133a79384b17424c141d398712686419a65c627db0aede817e55da8d3721e6781e543d882c5d852ce1455fe3727b766f645471c4f3391f10a1f2eb44724f4b3f03435d0683ce4ab0dd36df77477b8d049b6d768f5fa2fec385b26e87cc1ea7e4801b01bc03693a7e8d1e678d898e7b75bf2f211bcf9629a3aaa5bf106e4f903f892ce0f60ae8fff6f06336ef406f1556b5a52bdb1a0abb26b8e4793d8b74b162d9885f437959ab96dfb95e14614163034943777bc5646e741210b00ac3996c0bc7afa748bf1deef835d54467add1fead3be25d8cf049aef0856c51ca231d24e69572915d7879e36edd16a02d96708e65e8977818e2ff27f575c016c48aa924b18234ed2870ff396f27fcfc2071b7a85508fff8f5d45eb9f71bd5b906e9d86221091f437f426c6fee8b59ee6c19743e076ff2073249721ee3be1a183b5b7c660c5d3dd2f7e9b553b16272f8dc6a07a65456f28f5a11d48cd4469d45056d1e6a5dd850e88181b303a55fd14db3c04bbdb09234447305180b055b464a36cb57c48bd59332a487693f5a8225532c26185a0144e117da5e92cf2e1a776810a70b65d899c14946d34bc35a3f75f3c034019cfc683d307e4b77a7f8cd127554fa9ee43851667de4301fa00639a5ff169d1df0e5945f79aa7d6c6a46252797ed052fb60aa6e592e0e34149c84a5508c879246e5ef87a554acb829fe2469cd17f84e3c4d9ba10ae03db70381ac31bc5c6093e3b60fbb87c73e84e87d1ef823f0cc28a3119ecde456ff5afd428280f1f37dd56eb1795dab535108497c4ba467742187e44708faaa123e2b3aa8d6b57d7ec75fa10bf1faa2fdd3942426bee0665b24985c60d95761f81bef74b3a131d0625ab01036cc52a872fd325bcd7f3668a02ee74289e81494ecc619b5b325d59ed1de013473ae2b60f8524230842cf36c4a0c416494a22c0b3b992b6ed9a03527e216774933bdf13dce1f3ac57b8f631265bf1b9c644327a2cce401bb8082cdb4370751833c6444195d59029ce6f581ff74e0ed81be729541b10637e9e45bd28debbf92bf45ce1b210dabd0ffd79d512ccb9a2728c8a579dd202d52d7b9919a814bcf760b75ebb0d89490016868af9121fa59dc8ca65232bae5006ecf2a20dd48c72d09fc72144432708b9ada11b0d9bba62dafcb86c16672ab1f97a1f2293305d29e32dc5504b146c44b23f2da981227871c221d37cb25401760f8296b70bab73dd8c9c5165940800bccaf4dd604c033e484c25936a6d23c0acdcf3a66aaf190ab9280d75f7823c75e1e71f47e3d0fb7d01ffc7d73e52559e2d721713d03ea93867b1c82ee5270cc88cd2435c1696b1b521ca906bf0d8b1bf6bd2238b2996222481129288e068ac3a54bd7967daf201c915449f03489d22e3bb7bd37334aa30a0d438c5d063b12dd4aa10127686595d1466eb94e4c9bad41d4bfb88bc394b486b625d20af247c44aaa6f3fa250f6ce57b25cae34011507d8dce40f44bdb36d3e69306aa3c590c5711ee0b032b7396f3abe39e3983b1eb66217103b5edbffb34e757fe87596e9b4067935a8ff7ba79b3a2664bf7be096b88bb84625fcd121ff98b6a557237e6eea94b6f419d33be0890d690f8d998e80929fa8a19b236747069dcead2c9b3cb25aa1fa08acbef331157511606160e5242c96eb9f7553281cb97ab601251d8c916595402eb74e5eb706945aca67695c17eaf3cf7e22f2676a5c5eae6cb11216fa62ab17c193a9cd5f954708ed86a76e559b435c1515ae86032a8f1e66162a110471ef9e5516138ffb0d832e04a1ec879b69cae6398339cdc60b3b8a06ba660ade070e4d2d4a9f3d2aa0e648dfad4af79fdd88ef355a02599bc3a153ee0b24e421dc0a78217440634a39fa30d8fd80173584874252f5e6a4e4ebfb0078fb1c450cc0587d2af2dd91d98ff352405f3bb70ac1a8fb096d082f0faded402445f30fced3bb23f4e2c0d4635d06d96de3af3d0c724dd67fee13c140a860f38723d392d911997815058a71c41160238aa5eda31c1f1e09d2b03f52240646a34904b5f5aefe3c90e9e8c1328cf22e45c3024029dec3cdf6045eae7682c558e1d09d9c6507b1f79cc01085b361de1b90696db0790edc92553d5deef26a6f4fdb095d67cac88f278bead350a24f0c95bed3c0b963a6baaa1ec38834c7be674ed0416c03cc488e53dfe6fab4860bf5929e575965fcd648ba8d01711bb68b89ebaa024484eed176d57354280682339d10308c46bd6b4cd12b18a943455a9774061628a0e4aa36eb17d24a376e44af4cf34ae5b00d3601f52a2364ddd0fdb9f9f5e562758d84d25a9c211d405eff2edc6fbad999ac77d702d48347c789ccbd12a7b5a2beaaec4d48b5af1047ffc4951b647bbd704d94a30cd84c73d0fe0f2fc9c0db6064ab94cce69acceda00981c323096272f3e93a60ade755abbedef8a9fbe34c9be72f60b41a4eb2ab4c16e38a7315350601cfa891081507ac913a0a8d4a3b7ea3e02825f2820adced78549022e071adf00e9875ab1226185311ed55eb7a0760550c27a1a62ea2f84d024e4aab3e732d2aa7abca8fe8e8e49e4ff83b199b21aea3598a798e7bb41b60b1eebbdb16dc501c24079bb70d23dd478627615332b2854600caa021bb6a30c5db842fc61301eb2293ae96c90cddf0fa2b44d674ca1f55977b958f38915bcb0302a83f9b4d188f4a0529dc0c5810a4df60afe60daae89c9f45b4071ec4c51eadddc0dd114ead0731d453e48edc25a7b9f98e745aae682f3e53b6952fd8e8de41c4d716d9e882968a36e3a5df4ef77ce805bb42b2866027fccc1e65579830e9910816d7ac8692a92b380eba9cdfd5d4ab034132d3487644ffcb6e7f7eb0660673d3125c6f4752cdcd9501cec55a98aa8e8c357137e22e00ef746e7ce9df55031f6b5e8666e5adc14197c10f2ae156c2f73f00820a2e63f692bc4ea5e0997d7fa5d4240362d6c91167bfd3ca1ba9c086a7ef0260998bd19d3a00b6e13b269d33bcd1d2c30f5114200da10863fecb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 空_无 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空_无 </tag>
            
            <tag> 生活日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机内存体系】理解计算机内存，从位、字节到字，以及寻址的双重视角</title>
      <link href="/posts/15160/"/>
      <url>/posts/15160/</url>
      
        <content type="html"><![CDATA[<p>这个系列视频只能说是小科普，up也是这么说的。<br>我都不知道该怎么写文章，大部分也是改改配音稿，再加上一些自己的问题······</p><hr><h1 id="原视频"><a href="#原视频" class="headerlink" title="原视频"></a>原视频</h1><h2 id="引入：内存的分类"><a href="#引入：内存的分类" class="headerlink" title="引入：内存的分类"></a>引入：内存的分类</h2><blockquote><ol><li>装机视角：实实在在的内存条</li><li>操作系统视角：更多谈及的是 <strong>虚拟内存</strong></li><li>硬件视角：物理内存</li><li>电路视角：内存电路</li></ol></blockquote><p>&emsp;&emsp;当然，这些仅是简单的分类，在实际应用中，其维度远不止这些。</p><p>&emsp;&emsp;首先会介绍 基本的内存模型，然后了解 “字节” 与 “地址空间” 的定义，接下来会深入到地址的计算及 “字” 的概念，最后将从双重角度详解寻址技术。</p><img src="https://z1.ax1x.com/2023/11/30/pirgJT1.jpg" alt="pirgJT1.jpg" style="zoom:60%"><h2 id="物理内存的模型"><a href="#物理内存的模型" class="headerlink" title="物理内存的模型"></a>物理内存的模型</h2><p>&emsp;&emsp;目前有一个处理器和一个固态硬盘。由于处理器的计算速度和硬盘的读取速度相差悬殊，就需要通过内存来缓解这种速度差异。例如当我们启动一个大型游戏时，系统会先将游戏的关键数据加载到内存中，这样可以大大减少游戏的加载时间。</p><p>&emsp;&emsp;<strong>当处理器需要读取数据时，它会通过特定的地址访问内存，而内存会将对应地址的数据返回给处理器。同样地，在写入数据时，处理器会将目标地址和待写入的数据一同交给内存。从中我们可以看出，地址和数据无疑是内存操作中两个最为核心的概念。</strong></p><p>&emsp;&emsp;内存的模型通常被比喻为一个巨大的快递柜，每个格子都有唯一的编号，这就是 “地址” 。而格子里放置的物品，代表了 “数据” 。<strong>许多教科书将内存形容为一个字节数组，或者说，是一个按字节进行编址的存储空间。在这个空间中，每一行可以看作是一个字节。</strong></p><h2 id="字节与地址空间"><a href="#字节与地址空间" class="headerlink" title="字节与地址空间"></a>字节与地址空间</h2><p>&emsp;&emsp;那么，什么是字节呢？如果放大观察一个字节，会发现它由八个 <strong>“位”</strong> 组成。在计算机科学中，位是最基本的存储单元，只能为 0 或 1。这样，一字节就等于八位。现在，考虑位的组合。一个位能表示两种状态，即 0 和 1，因此有两个可能的地址。两个位可以表示的地址为 00, 01, 10, 11，共四个地址。而三个位则有八种组合方式，从 000 到 111，代表八个不同的地址。</p><p>&emsp;&emsp;可以推出通用的表达形式。分别转换为数学的表达形式，再转换为对数表达形式。当画出该函数的图像时，会发现图上的点与先前提及的数学表达形式和左边方框内的内容相一致，这为我们提供了一个直观的方法来理解位与地址之间的关系。</p><img src="https://z1.ax1x.com/2023/11/30/pirgBOH.jpg" alt="pirgBOH.jpg" style="zoom:60%"><h2 id="字与地址计算"><a href="#字与地址计算" class="headerlink" title="字与地址计算"></a>字与地址计算</h2><p>&emsp;&emsp;接下去，让我们看看一个 64 字节的内存。当按字节编址，每一行代表一个字节，这意味着我们有 64 行。使用之前的表达式，可以确定需要 6 位来唯一标识这64个地址。当我们将这 6 位二进制数转换为十进制时，结果就是你要访问的内存地址。而仅仅改变其中一位，就可以得到不同的地址。</p><img src="https://z1.ax1x.com/2023/11/30/pirg2ff.jpg" alt="pirg2ff.jpg" style="zoom:60%"><img src="https://z1.ax1x.com/2023/11/30/pir219f.jpg" alt="pir219f.jpg" style="zoom:60%"><p>&emsp;&emsp;在了解了地址计算之后，我们来看看字的概念。字并没有固定的大小，可以让 1 个字等于 1 个字节，这样的话该模型的 1 行就是 1 个字，和上面的一样，需要通过 6位 来访问所有的地址。而现在如果令 1 个字等于 4 个字节，那就相当于 4 行为 1 个字——标上序号，可以计算出需要 4 位来访问这 16 个序号，同样可以展开计算出十进制，从而得到访问的序号。现在不妨将这 4 行压成 1 行，就像这样，此时依然是 64 个字节大的内存，但其中的一格代表了字节，而此时的一行就代表一个字，里面是32个位。</p><img src="https://z1.ax1x.com/2023/11/30/pir2MNt.jpg" alt="pir2MNt.jpg" style="zoom:60%"><p>&emsp;&emsp;6 位能够访问 64 个地址，而 4 位只能访问 16 个，那么这两者之间的 2 位差异意味着什么呢？</p><img src="https://z1.ax1x.com/2023/11/30/pir2KAI.jpg" alt="pir2KAI.jpg" style="zoom:60%"><h2 id="寻址的双重视角"><a href="#寻址的双重视角" class="headerlink" title="寻址的双重视角"></a>寻址的双重视角</h2><p>&emsp;&emsp;重新整理一下目前的情报。内存大小是 64 个字节，使用这一个模型，其中的 1 格为 1 个字节，需要 6 位来访问 64 个格子，一行包括了 4 个字节，需要使用 4 位来访问 16 行。</p><img src="https://z1.ax1x.com/2023/11/30/pir2Q4P.jpg" alt="pir2Q4P.jpg" style="zoom:60%"><p>&emsp;&emsp;仔细看下每一行的内存，一共 4 列，那使用 2 位不就正好能够访问这 4 列吗？我们可以来验证一下，在模型上面标上二进制表达形式。首先计算 6 位的结果，对应的就是其中的一个格子，再计算 4 位的结果，对应的是模型的一行，最后直接可以将 2 位的对应到模型上面标出的表达式中，我们就能发现，通过 6 位访问，与分别通过 4 位和 2 位访问，结果是一致的，可以转换一下其中的数字再来验证。</p><p>&emsp;&emsp;目前变换的只是 2 位里的数字，而其实变换 4 位里的数字也是一样的。现在如果想要访问 25 号的地址，我们可以反推得到 6 位的表达式，其对应的行和列也能得到该地址，实际上这 6 位的数字和 4 位加上 2 位的数字始终是一致的，不同的只是我们如何去理解其中的位数。</p><p>&emsp;&emsp;<strong>这种思考方式在内存中并不少见，不只是在缓存的映射方式中能找到，在虚拟内存中同样也有类似的思想。</strong></p><img src="https://z1.ax1x.com/2023/11/30/pir2nHA.jpg" alt="pir2nHA.jpg" style="zoom:60%"><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【语录】001</title>
      <link href="/posts/46612/"/>
      <url>/posts/46612/</url>
      
        <content type="html"><![CDATA[<h1 id="烧鸡老师："><a href="#烧鸡老师：" class="headerlink" title="烧鸡老师："></a>烧鸡老师：</h1><blockquote><p>我始终相信还是会有那么一段主题，它是雅俗共赏的，它是所有人都会面对的现实，也是所有人的憧憬向往的点。所以最后你会发现千人律者篇的故事灵感有一些现实的影子，它来源于现实当中、生活当中我们都会遇到的社会现象，比方说网络暴力，比方说群体极化。<br><em>“看吧，这个剧场的所有人都是这样，这个世界的所有人都是这样，盲目、冲动、自私、悲哀，不知道自己想要什么，不知道自己该做什么，只是任凭他人摆布，当一个可悲的演员，一个愚蠢的人偶。人心的卑劣，远比灾难更可怕。这样的世界，从一开始就不存在真正的救赎！”</em><br>它是一种证明，在经历这个故事的时候，我们曾经产生过某种感情，而现在 我们能发现一个毫无关联的陌生人正在体会与我们当初一样的情绪。这其中 不仅仅有感动，还有理解和共鸣。也是在这时，我们渐渐明白了，我们所追求的那种雅俗共赏的事物到底是什么。<strong>正因为生活并不美好，所以我们才渴望美好。如果人性就是有两面，如果善恶一定并存的话，那既然生活的残酷无处不在，那始终也会希望有一种声音，它能不断地去捍卫这种对美好的向往和憧憬。</strong>它会由琪亚娜带给玩家，再由玩家带给更多的人 永远存在。<strong>这不切实际，但我们期望如此。</strong><br><strong>我们还是希望在这个故事最后，玩家喜欢的不仅仅是这个故事，或者说制作这个故事的团队。他们最应该喜欢的 还是陪同这个故事一直走到了现在的自己，可能是曾经努力去做过某件事情，又或者是说 因为这个游戏 结识了一段重要的关系或者感情，或者 在这段时间里面做出了某个重要的抉择。它们一定会和这个故事一起 成为生命中被刻写下的部分。</strong><br><strong>今天的自己有没有变得比昨天更好，明天的自己会不会变得比今天更好，就像我今天坐在这里，在镜头前讲下这个故事，它只是一个普普通通的 随处可见的故事。总有一天，每个人会和这个故事告别，走向不同的方向，独属于你自己的下一页。但是那样就好，累了的话就停下脚步，怀念的话就回来看看 这个故事也一直都在。且行且看，尽力而为，不要害怕，不要后悔。就像 崩坏三的slogan“为世界上所有的美好而战”一样，我们每个人都是在哭声中来到这个世界，但是却要笑着走向未来。</strong></p></blockquote><p>是啊——</p><ul><li>“今天的自己有没有变得比昨天更好，明天的自己会不会变得比今天更好”</li><li>“总有一天，每个人会和这个故事告别，走向不同的方向，独属于你自己的下一页。但是那样就好，累了的话就停下脚步，怀念的话就回来看看 这个故事也一直都在。且行且看，尽力而为，不要害怕，不要后悔。”</li></ul><h1 id="Shiel"><a href="#Shiel" class="headerlink" title="Shiel"></a>Shiel</h1><ul><li><p>我现在只需要 <strong>坚持</strong> 就行了：<strong>且行且看，尽力而为，不要害怕，不要后悔</strong>。<br>既然已经找到了自己的方向，那就一直走下去——我不是超人，我只是一个随处可见的的普通人，不过只是一个喜欢 <strong>ACGN</strong>、<strong>数码科技</strong>、<strong>文学历史</strong> 的死宅罢了。</p></li><li><p>就像 <strong>老哥</strong> 说的：<br><em><strong>没有那么多天赋异禀，努力也是一种天赋。</strong></em></p></li></ul><img src="https://picss.sunbangyan.cn/2023/11/28/cd9a58012975da248ef85cedc01272d4.jpeg" alt="0" />]]></content>
      
      
      <categories>
          
          <category> 空_无 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空_无 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序——快速排序</title>
      <link href="/posts/38023/"/>
      <url>/posts/38023/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>参考：<br><del>（不会真的有人不知道<a href="www.runoob.com">菜鸟教程</a>吧？哈哈）</del><br><a href="https://www.runoob.com/w3cnote/quick-sort-2.html">1.6 快速排序 | 菜鸟教程</a><br><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">1.0 十大经典排序算法 | 菜鸟教程</a></p><hr><p><strong>此快速排序对数据的要求是不能有 重复元素 ！！！</strong></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Shiel"><a href="#Shiel" class="headerlink" title="Shiel"></a>Shiel</h2><h3 id="1-5种常用的排序"><a href="#1-5种常用的排序" class="headerlink" title="1. 5种常用的排序"></a>1. 5种常用的排序</h3><p><em>均假定为升序</em><br><img src="https://picdl.sunbangyan.cn/2023/11/27/ac0144c6a79892daac91ac8e06c2cd6a.jpeg" alt="4种排序" style="zoom:35%"/></p><ol><li><p>冒泡排序</p><blockquote><ul><li>第 1 个和第 2 个比，第 2 个跟第 3 个比，第 3 个跟第 4 个比，···，第 n-1 个和第 n 个比，每次把大的数放后面</li><li>第1轮比完之后，前n个数的最大数字就到后面了。</li><li>之后<strong>递归</strong>：前 n-1 项、前 n-2 项、···前 2 项</li><li>排序完成</li></ul></blockquote></li><li><p>插入排序</p><blockquote><ul><li>把第 2 个数据插入到第 1 个处，保证前 2 个数据有序</li><li>把第 3 个数据插入到前 2 个处，保证前 3 个数据有序</li><li>·····</li><li>把第 n 个数据插入到前 n-1 个处，保证前 n 个数据有序</li></ul></blockquote></li><li><p>选择排序</p><blockquote><ul><li>在所有数据中按照某种算法选择一个数值，如果是升序，选择是最小的——第 1 个就是最小值</li><li>再从后面的 n-2 项中，选择一个次最小值，跟第 2 个数字互换——第 2 个数字变成次最小值</li><li>······</li><li>完成排序</li></ul></blockquote></li><li><p>快速排序</p><blockquote><ul><li>快排名字起的很好，快排快排，说明速度是很快的，快排也比较复杂，很经典的排序算法。</li></ul></blockquote></li><li><p>归并排序</p><blockquote><ul><li>两个两个排，先使两个两个有序</li><li>四个四个排，再使四个四个有序</li><li>八个八个排，再使八个八个有序</li><li>······</li></ul></blockquote></li></ol><h3 id="2-排序和查找的关系"><a href="#2-排序和查找的关系" class="headerlink" title="2. 排序和查找的关系"></a>2. 排序和查找的关系</h3><p><strong>排序</strong>是查找的前提。</p><h3 id="3-排序时重点关注的"><a href="#3-排序时重点关注的" class="headerlink" title="3. 排序时重点关注的"></a>3. 排序时重点关注的</h3><blockquote><ol><li>时间</li><li>空间</li><li>稳定性——每次排序之后不改变原来数据的相对位置就是稳定的</li></ol><blockquote><ul><li>甲 60、乙 39、丙 60、丁 89</li><li>即每次排序之后甲仍然在丙前面就是稳定的</li></ul></blockquote></blockquote><h2 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。<br>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。<br>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。<br>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p><blockquote><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p></blockquote><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/8305bb225e3aedf6f2371.jpg" alt="$fileName" width="80%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div><p>点击以下图片查看大图</p><div align="center" ><img src="https://telegraph-image-box.pages.dev/file/7de5ec1c1a6ed5da2cd53.jpg" alt="$fileName" width="90%" style="box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);border-radius:10px;"/></div><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><h2 id="Shiel-1"><a href="#Shiel-1" class="headerlink" title="Shiel"></a>Shiel</h2><h3 id="伪算法"><a href="#伪算法" class="headerlink" title="伪算法"></a>伪算法</h3><blockquote><ol><li>先找到某一个元素的确切位置（指排序后的正确的位置），即 中间点，从此中间点分成两半</li><li>对中间点左边再找 新的中间点 的确切位置</li><li>对中间点右边再找 新的中间点 的确切位置</li></ol></blockquote><ul><li>即：<br>假定是第一个元素（未排序之前），把第一个元素的确切的位置找到，这样左边是一半，右边是一半。</li></ul><h3 id="图片演示"><a href="#图片演示" class="headerlink" title="图片演示"></a>图片演示</h3><p><del>字太丑了</del></p><img src="https://picss.sunbangyan.cn/2023/11/27/4bcfc72d7e48a54302585e14cd199ffc.jpeg" alt="一步完成" style="zoom:30%"/><img src="https://picst.sunbangyan.cn/2023/11/27/9d93efbc9fd8194db4be8a4fb6d0107a.jpeg" alt="分步进行" style="zoom:40%"/><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-后来分成的左边一半和右边一半怎么办？"><a href="#1-后来分成的左边一半和右边一半怎么办？" class="headerlink" title="1. 后来分成的左边一半和右边一半怎么办？"></a>1. 后来分成的左边一半和右边一半怎么办？</h4><blockquote><p>按照同样的算法，把第一个元素的确切的位置给找到，又把左边一半分成两半，那左边一半怎么排？再找到第一个，继续分······<br>即 <strong>递归思想</strong> 和 <strong>分治思想</strong> 的应用，需要 <strong>递归</strong>。</p></blockquote><h4 id="2-此算法最关键的问题是？"><a href="#2-此算法最关键的问题是？" class="headerlink" title="2. 此算法最关键的问题是？"></a>2. 此算法最关键的问题是？</h4><blockquote><p>如何找到某一个元素的确切的位置。<br>只有找到了，这个元素的位置才能固定住，才能进行分治和递归，不然根本没办法进行。</p></blockquote><h4 id="3-如何找某一个元素确切的位置？"><a href="#3-如何找某一个元素确切的位置？" class="headerlink" title="3. 如何找某一个元素确切的位置？"></a>3. 如何找某一个元素确切的位置？</h4><p>快排分很多种，这里讲的是比较快的一种。</p><blockquote><ol><li>定义一个临时变量 val，将第 1 个元素的值赋给 val</li><li>定义两个指针 low 和 high（参数），low 指针保存第 1 个元素的地址，high 指针保存 最后一个 元素的地址。</li><li>把 l 往右移，h 往左移</li><li>当 l 和 h 重合时的位置即第 1 个元素的位置</li></ol></blockquote><h4 id="4-l-和-h-怎么移？"><a href="#4-l-和-h-怎么移？" class="headerlink" title="4. l 和 h 怎么移？"></a>4. l 和 h 怎么移？</h4><blockquote><p>5 2 6 8 4 3 7</p></blockquote><p>假定升序，<strong>最终的效果是 val 左边都是比 val 小的，val 右边都是比 val 大的！</strong></p><h4 id="5-l-和-h-移动时涉及到的操作"><a href="#5-l-和-h-移动时涉及到的操作" class="headerlink" title="5. l 和 h 移动时涉及到的操作"></a>5. l 和 h 移动时涉及到的操作</h4><p>首先需要明白这里涉及到两个操作：<strong>赋值</strong> 和 <strong>移动</strong>。</p><ul><li>赋值<blockquote><p>即把当前指向 h(l) 元素赋给 l(h)<br>什么时候才需要赋值？</p><blockquote><p>当此元素的位置错乱时才赋值，即此元素位置放错了：</p><ol><li>val 右半部分应该是比 val 大的，那么当 出现比 val 小的元素就赋给左边 l 位置处的 a[low]</li><li>val 左半部分应该是比 val 小的，那么当 出现比 val 大的元素就赋给右边 h 位置处的 a[high]</li></ol></blockquote></blockquote></li><li>移动<blockquote><p>即把指向 h (l) 的指针往 左移(右移)<br>什么时候才需要移指针？</p><blockquote><p>当此元素的位置正确时就移动呀！即此元素的位置是正确的，那就去看下一个元素的位置是否正确</p><ol><li>val 右半部分应该是比 val 大的，那么当 出现比 val 大的元素时说明此元素位置正确，就把 h 往左移，直到找到比 val 小的元素——进行赋值操作</li><li>val 左半部分应该是比 val 小的，那么当 出现比 val 小的元素时说明此元素位置正确，就把 l 往右移，直到找到比 val 大的元素——进行赋值操作</li></ol></blockquote></blockquote></li></ul><h4 id="6-移动时会出现的情况"><a href="#6-移动时会出现的情况" class="headerlink" title="6. 移动时会出现的情况"></a>6. 移动时会出现的情况</h4><p>由排列组合知会有 4 种情况：</p><blockquote><ol><li>val 右半部分：a[high] &gt; val</li><li>val 右半部分：a[high] &lt; val</li><li>val 左半部分：a[low] &gt; val</li><li>val 右半部分：a[low] &lt; val</li></ol></blockquote><p>现在你知道这 4 种情况应该怎么做了。</p><h4 id="7-一轮排序后就结束了吗？"><a href="#7-一轮排序后就结束了吗？" class="headerlink" title="7. 一轮排序后就结束了吗？"></a>7. 一轮排序后就结束了吗？</h4><blockquote><p>经过一轮排序函后只能确定第一个元素的下标，其它元素依然是无效的！<br>因为一轮排序只是对第一个元素操作，虽然已经比较复杂了，但只有第一个元素确定位置了。</p></blockquote><h2 id="菜鸟教程-1"><a href="#菜鸟教程-1" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><h3 id="伪算法-1"><a href="#伪算法-1" class="headerlink" title="伪算法"></a>伪算法</h3><blockquote><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol></blockquote><h3 id="图片演示-1"><a href="#图片演示-1" class="headerlink" title="图片演示"></a>图片演示</h3><p>菜鸟教程：<br>  <img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="菜鸟教程"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>测试用例</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 2 6 8 4 3 7</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure><hr><h2 id="Shiel-2"><a href="#Shiel-2" class="headerlink" title="Shiel"></a>Shiel</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: 快速排序</span></span><br><span class="line"><span class="comment">    * @version: 1.0</span></span><br><span class="line"><span class="comment">    * @author: @Shiel</span></span><br><span class="line"><span class="comment">    * @date: 2023-11-27 08:40:26</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_Quick</span><span class="params">( <span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> high )</span>;   <span class="comment">// 快排</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span><span class="params">( <span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> high)</span>;    <span class="comment">// 查找并返回 L=H 的位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">7</span>] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span> ,<span class="number">7</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    Sort_Quick(a, <span class="number">0</span>, <span class="number">6</span>);    <span class="comment">// 第二个元素表示第一个元素的下标，第三个参数表示最后一个元素的下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_Quick</span><span class="params">( <span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> high )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos;    <span class="comment">// 中间点 L=H 时的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( low &lt; high )    <span class="comment">// 只有 low&lt;high 时才继续进行</span></span><br><span class="line">    &#123;</span><br><span class="line">        pos = FindPos(a, low, high);    <span class="comment">// 获取中间点 L=H 的位置</span></span><br><span class="line">        Sort_Quick(a, low, pos - <span class="number">1</span>);    <span class="comment">// 中间点左半部递归</span></span><br><span class="line">        Sort_Quick(a, pos + <span class="number">1</span>, high);   <span class="comment">// 中间点右半部递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span><span class="params">( <span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> high )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = a[low];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 首先从右边 high 开始向左进行查找</span></span><br><span class="line">        <span class="keyword">while</span>( low &lt; high &amp;&amp; a[high] &gt; val )    <span class="comment">// high 指向的元素大于val，high左移</span></span><br><span class="line">        &#123;</span><br><span class="line">            high--;    <span class="comment">// a[high]&gt;val，不需要赋值，则high左移</span></span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = a[high];   <span class="comment">// 即a[high]&lt;val的情况，此时将a[high]赋给a[low]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再从左边 low 开始向右进行查找</span></span><br><span class="line">        <span class="keyword">while</span>( low &lt; high &amp;&amp; a[low] &lt; val )     <span class="comment">// low指向的元素小于val，low右移</span></span><br><span class="line">        &#123;</span><br><span class="line">            low++;      <span class="comment">// a[low]&lt;val，不需要赋值，则low右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        a[high] = a[low];   <span class="comment">// 即a[low]&gt;val的情况，此时将a[low]赋值给a[high]</span></span><br><span class="line">    &#125; <span class="comment">//终止循环之后 L和H 一定是相等的</span></span><br><span class="line">    </span><br><span class="line">    a[low] = val;   <span class="comment">// L=H，此时将val的值赋给 a[low]和a[high] 是一样的</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> high;    <span class="comment">// 返回下标，等价于 return low;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="菜鸟教程-2"><a href="#菜鸟教程-2" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//严蔚敏《数据结构》标准分割函数</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">Paritition1</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> pivot = A[low];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     A[low] = A[high];</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     A[high] = A[low];</span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="type">int</span> pivot = <span class="built_in">Paritition1</span>(A, low, high);</span><br><span class="line">     <span class="built_in">QuickSort</span>(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">QuickSort</span>(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">&#125; Range;</span><br><span class="line"></span><br><span class="line">Range <span class="title function_">new_Range</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.end = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 避免len等于负值时引发段錯誤（Segment Fault）</span></span><br><span class="line">    <span class="comment">// r[]模板列表,p为數量,r[p++]为push,r[--p]为pop且取得元素</span></span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = new_Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> mid = arr[(range.start + range.end) / <span class="number">2</span>]; <span class="comment">// 选取中间点为基准点</span></span><br><span class="line">        <span class="type">int</span> left = range.start, right = range.end;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) ++left;   <span class="comment">// 检测基准点左侧是否符合要求</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; mid) --right; <span class="comment">//检测基准点右侧是否符合要求</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;               <span class="comment">// 移动指针以继续</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class="line">        <span class="keyword">if</span> (range.end &gt; left) r[p++] = new_Range(left, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-递归法"><a href="#C-递归法" class="headerlink" title="C &amp; 递归法"></a>C &amp; 递归法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = arr[end];</span><br><span class="line">    <span class="type">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">            right--;</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="keyword">if</span> (left)</span><br><span class="line">        quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-函数法"><a href="#C-函数法" class="headerlink" title="C++ &amp; 函数法"></a>C++ &amp; 函数法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a,a + n);<span class="comment">// 排序a[0]-a[n-1]的所有数.</span></span><br></pre></td></tr></table></figure><h3 id="C-迭代法"><a href="#C-迭代法" class="headerlink" title="C++ &amp; 迭代法"></a>C++ &amp; 迭代法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考：http://www.dutor.net/index.php/2011/04/recursive-iterative-quick-sort/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">    <span class="built_in">Range</span>(<span class="type">int</span> s = <span class="number">0</span>, <span class="type">int</span> e = <span class="number">0</span>) &#123;</span><br><span class="line">        start = s, end = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)、&quot;大於&quot;(&gt;)、&quot;不小於&quot;(&gt;=)的運算子功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">const</span> <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 避免len等於負值時宣告堆疊陣列當機</span></span><br><span class="line">    <span class="comment">// r[]模擬堆疊,p為數量,r[p++]為push,r[--p]為pop且取得元素</span></span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = <span class="built_in">Range</span>(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        T mid = arr[range.end];</span><br><span class="line">        <span class="type">int</span> left = range.start, right = range.end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= arr[range.end])</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[left], arr[range.end]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left++;</span><br><span class="line">        r[p++] = <span class="built_in">Range</span>(range.start, left - <span class="number">1</span>);</span><br><span class="line">        r[p++] = <span class="built_in">Range</span>(left + <span class="number">1</span>, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-递归法-1"><a href="#C-递归法-1" class="headerlink" title="C++ &amp; 递归法"></a>C++ &amp; 递归法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort_recursive</span><span class="params">(T arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    T mid = arr[end];</span><br><span class="line">    <span class="type">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换</span></span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) <span class="comment">//试图在左侧找到一个比枢纽元更大的元素</span></span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) <span class="comment">//试图在右侧找到一个比枢纽元更小的元素</span></span><br><span class="line">            right--;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[right]); <span class="comment">//交换元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)、&quot;大於&quot;(&gt;)、&quot;不小於&quot;(&gt;=)的運算子功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考地址:<br><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md</a><br><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F</a></p></blockquote><h3 id="C-3"><a href="#C-3" class="headerlink" title="C#"></a>C#</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序（目标数组，数组的起始位置，数组的终止位置）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span>(<span class="params"><span class="built_in">int</span>[] array, <span class="built_in">int</span> left = <span class="number">0</span>, <span class="built_in">int</span> right = <span class="number">-1</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (right.Equals(<span class="number">-1</span>)) right = array.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> keyValuePosition;   <span class="comment">//记录关键值的下标</span></span><br><span class="line">        <span class="comment">//当传递的目标数组含有两个以上的元素时，进行递归调用。（即：当传递的目标数组只含有一个元素时，此趟排序结束）</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            keyValuePosition = Partion(array, left, right);  <span class="comment">//获取关键值的下标（快排的核心）</span></span><br><span class="line">            QuickSort(array, left, keyValuePosition - <span class="number">1</span>);    <span class="comment">//递归调用，快排划分出来的左区间</span></span><br><span class="line">            QuickSort(array, keyValuePosition + <span class="number">1</span>, right);   <span class="comment">//递归调用，快排划分出来的右区间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Exception: &#123;0&#125;&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span>快速排序的核心部分：确定关键值在数组中的位置，以此将数组划分成左右两区间，关键值游离在外。（返回关键值应在数组中的下标）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Partion</span>(<span class="params"><span class="built_in">int</span>[] array, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> leftIndex = left;        <span class="comment">//记录目标数组的起始位置（后续动态的左侧下标）</span></span><br><span class="line">    <span class="built_in">int</span> rightIndex = right;      <span class="comment">//记录目标数组的结束位置（后续动态的右侧下标）</span></span><br><span class="line">    <span class="built_in">int</span> keyValue = array[left];  <span class="comment">//数组的第一个元素作为关键值</span></span><br><span class="line">    <span class="built_in">int</span> temp;</span><br><span class="line">    <span class="comment">//当 （左侧动态下标 == 右侧动态下标） 时跳出循环</span></span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt; rightIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt; rightIndex &amp;&amp; array[leftIndex] &lt;= keyValue)  <span class="comment">//左侧动态下标逐渐增加，直至找到大于keyValue的下标</span></span><br><span class="line">        &#123;</span><br><span class="line">            leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt; rightIndex &amp;&amp; array[rightIndex] &gt; keyValue)  <span class="comment">//右侧动态下标逐渐减小，直至找到小于或等于keyValue的下标</span></span><br><span class="line">        &#123;</span><br><span class="line">            rightIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftIndex &lt; rightIndex)  <span class="comment">//如果leftIndex &lt; rightIndex，则交换左右动态下标所指定的值；当leftIndex==rightIndex时，跳出整个循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = array[leftIndex];</span><br><span class="line">            array[leftIndex] = array[rightIndex];</span><br><span class="line">            array[rightIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当左右两个动态下标相等时（即：左右下标指向同一个位置），此时便可以确定keyValue的准确位置</span></span><br><span class="line">    temp = keyValue;</span><br><span class="line">    <span class="keyword">if</span> (temp &lt; array[rightIndex])   <span class="comment">//当keyValue &lt; 左右下标同时指向的值，将keyValue与rightIndex - 1指向的值交换，并返回rightIndex - 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        array[left] = array[rightIndex - <span class="number">1</span>];</span><br><span class="line">        array[rightIndex - <span class="number">1</span>] = temp;</span><br><span class="line">        <span class="keyword">return</span> rightIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//当keyValue &gt;= 左右下标同时指向的值，将keyValue与rightIndex指向的值交换，并返回rightIndex</span></span><br><span class="line">    &#123;</span><br><span class="line">        array[left] = array[rightIndex];</span><br><span class="line">        array[rightIndex] = temp;</span><br><span class="line">        <span class="keyword">return</span> rightIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 排序和查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念</title>
      <link href="/posts/2927/"/>
      <url>/posts/2927/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="此文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e8154bb397505c8ea84d6b84961f7500dc8b3ae9be0b90bec3bd0b37d98879f3">575a88b480ecfe5d2ccbf0b23c994b0b39f17ceb46ffcb18c570768f81c0b199fcabc54499f81c3212a443f98ae4a408feb39957f667ea972e1baca5e07825be250e8bbe0974f0683536b0d26f0ab83ef8ac5490ec5ab35f32ac120e9e171cca2e515af5cdf78944da4b2a19841af427f6bb264716389caea2cb4ee4f049e41e43e473a5caa3607aa9a6627cede39c57b4af9e58ca189cf29e442a51f7e2e930a813e1d26b3a4fbaaf83b830e20f666981e6d2fb0ba093c1efc3e94f9d7eda6e8f2019fd79b4edc7069146744ccdf64a7e1ce02b6d880aebe5430f02e14af5490b61f02cac4bf8ff688c9ee77099e518f0521734e0ea9ba39a7d5d467d51e74e802664bab0a9617f1fccf3f0eff62dc95ff397ca0ba7a5bcb19d3584592fb5e1fe1791a391168a66893c31df05f93ddd888628a1620f2825c7b729243257d2a08f25834dd4d742a38ade983915f55671c0418642b82a8954b476e30dc2f862323cd43aa494dd8a83ca762e11f653ebefb2752ba26267d7c3a790e217c8c33e66cb0849e5615362166d14fb1c096e3a3f0968f7c6fc61fdb436fbf32e846e239d7bbe5036bfebdcbaeb6dac01684b175d169aa2fd3abd829a8587176592faa26aaef198c9210d97bcdae392dfd64465fcda790677eb34728b3328b3c8cc282bd34fb789327207698aab922db99d59c997319a4b72a4c8ee0b3cafdbae221d32b4f3741e04c5ad49deb236b7a75e1419edab72505e035e6c05a365fbdf901960b33102290274587abcde553dd741f8eb224cd46645917ea24ffea3a9d3d34fe2defcc29838860391a049d940b7252dbce6da145082ee520f75f9ff2f144db91ae7e58e60dc2b561af43758d68d9a5a27d0e71506bbfe333fe2cf2dc45e8331fe2ed2c0c005f399d876bfb8f0302791c27bd47632afa0a957e24b5db3c5036694557b01308cc9ae1dbd221b17568e5d95533bd720fd6b59b40cdf53caf866e35e35320f4bfb6055a4d113f8e3aadcce39d11d774950d1ded9c8df3cde4c4ca3a90d18630a9dfc8fe3b9ff1c06b36b7bb63d22b5884e8117deb8717ad3c8a8a7fdb4204e041dd95c1ff084ca26463c7ee78e69758afecee1319b2f344b65964aa5265471aff229767224a81686aaa0f7448a80891372eb2ee3fa1604c3b23a2d1d99bf1aec12a311491221a9e7baf52c77d9b6db1ba83d79b12ac3667179357cd80b3c87914ca3adcfe86d6b49752c2e93917aa05e8fdcbb96d6932f52bff542801b4c77b5790e33a1c9f8e127c7a3802597190ae923d98e9cfed82f2201f72fa130a90bccfeb8bd89e97948cc63c6199c726be37e464d147e606f1383b42c35b9f32884f4743c42fb786ab6f1858cef50b14e6e9cf13ddf29c33e65d80c22480ec3d2a24098c63e2856c1803bad57048fc81465f154a2d0ff3460bcf52a05a717bda851fa87b074547cff22e330e6dd5f88cb26f51b95d6ed14eb4b38a447826a7e30801b73305ad1d61462ed7530735867bcacd663e003970695777fec49db5e364fc540671db0d1e951c186568bcbc5dfc2e9a0cfa462b7137b475586c4016a2d75c9e33605a9bb4563b5a7f53234b4f09fdc8beb7043aafb9b409367fbe16ad3a6ada2b9677829d9c20a69b5649351579bd1b0d9218644ad5f453e20bdd3c4e1d2a1b2e3143eaddb7f6bae5eea7b57a7a364026de8423169d50fbc7b015705aed6d67836e841ec5045531ad8bedd020b749d4a67083db302b7c7f33dd95ca4d05e3dd37d8cf23399550c4d2811b27712c5a704b7595001fcd7fc3cbb9a8689a884b4a01469f6713a6c747c4f83c0a50a509348dae6696d9dbe78cfbbd7958d15a3de01d5b32c93a39ecc121a1a20ef225509ee66406ceb59463a1b2a650f751e31f928959b3ef2e862e4dbcca2ca033279cd00d24a9424833bfec00a1b10695fc22074182804d96884172f455e196323f1aa4dbe3ff28238cc367ae262010a59535a4e6c692b99cb76c7e3e773100c512c75c119189db203ff0760f314877e43a5b397b7a864847093c40365de72aca02d02a22079b921b8b6ff643753a31ab53e3fcfc63fa30f8fad18173837437467ce614de155e0d9a1edf6f8f4bbfea42bc90d6618234a4ef253ecd818a28cf50ce7f30895558b12ba16a1b345296500359f351dd7d99dbf027d9a66d5f8be7f8a1aa30d54571070859f68a3101b304af7e3594a42f634adf8d0628b22755372cc415c2c63ee172c272d6a6ea0adff211881f55e6225fc09967b2603c125c426516201e09b74e8310f7baad3e2dbe36faf3ce95465f57ea6e53ecc850251344b54e7ffb0302153c328371f465f8c6f2caf3032fedca62204130bbc0556b2f48bf560df7c8f9f4a5b1485bcbb62576dfba1961cf00e8cb4912b6cd1503f7a18cae4dacd21f8f2ed8ecc7d1f214cfe00a1272165d18ee8f97b0f34258b8f59bdf5fe72c93bd74a698e0c9bd0abf33c12ed0c3f63aa2d1b182a6510bb147748d1e986009eec2ae5d24808a6bf99682fa3c84104878a6d1cd1c11da42041447046c66a6f5869fdd1a3616a2abb81c3c8b92a924d5f78ad7fb06dc230eadb6d59cfe2dd48c218ba3cba6fef9f6b43674b4599708cd56e18cb55fa52a97d920e9e12a7652bb622a8022e014fff04473d8351ab76ba85a4a5435d9dd356e88b61ec2e7a90941dc2a23067916022693e855ca7253279c79a8d06a4cfa28493b4dfb8e3534c4d136a6aa8640713466e7edc30384ebeedfbd74b612a073724ddc0f44a85324b26c93a3c01d2451e16a8613becb18591acd8df41fe4ae35c5270a47be5ec5a7acbc2f82516759e823337dc618893749c827fd892c56bf7e68aab8b78e42955a359e1002d64966dc893a8f30f6f5ccb7012803b22d69ef11a1c780e247d3e5a6ee7cffd803729b20a3f932f49f6b0c3720051468fa3d9cb50ee674d743cfd3567969d593da27353a8fe60c650d330b512f0325db86fd2c4f891b61b6c09c947b9bf48a50a582629aa23c269b6eaa2ccae6c98b8a110b214b8c4506ac7d9ef67cf9020d1b8bab245cc7fb27418d3141817eacb42bbb11fb58b10ddf4f0861e6ef9292a07ae5b3e8828c81079d1b4d374234619bb43cb101273ad4e1b2617dd94c2e1b4f8fcd9210278b4187dab6d728fe34d0b0f32c29fbeeb4bd23b9d07ee649f91f82f6940c00508f8d3100a35cd99c9719e80c0b498d157acd2bf9f5be323850cb562cac0a025d43d0e5239d961d3f6666e7e259be0e4512388ce7f71f01614fccacf4d06496a1374c9c37ded2ebe657593d1b2490e2172f3704c2653b74d8b6f5bfde668fa3d7d0eae676bd06dd48d66e358c0b9ee314e3a1453ffa3c5c0a097de3917d78c0532e0f909c27170b20d50c62db6b75a203bf0c7a44441dd596a0c3100300cac4ea74e9507465ae6bf53b4d708f84db7fb75b43bf12709b7dbd4054203c310ab909781365b7d4a1ac2d905ed349b230289da80209de16143dc1a0fc0ff8e0fb6a3d5efef0059130456a73cde137d051a548dc6ff9a2ad457998991ac109eeabbd285f96229c7f2276ab26e78815293fb8a0987ab5c14e9aefb1a3cbc4661888af2eae9dda1bfea07727b367b24f274817bca4ea64af5f7c1d1fbc6e8d086040581f2df496cf2b4bcf9146d4f78fbd95c4285b8f2f76f2f3ab5772bd2b60b09718e7752c68883ff6107e42ba9655d10b68831e68b370d36a2e850a3ac957482f3960930137a3d7288bca8e28463623b86031ca97504329965de05c170f93567f0c91adf5aac6dc1574608d19d518b88ddd69cbbc712002e05bcb2c568a5c5a88d55aff67906fd9ddef9584798999b18d5ed78109e4e605b018f3b1df7ce345e08a16741437b4e94bae02e27cd064a36b56a95590fff5be077327baff65bad9de81c7b51aa2b53842b9153c4a22a26028a87f1e66ceb0ca6a005e223d9a3eead940579676c3fe4214b546d26fa9cdb5dd7a7b6aaf83495301d91caa050e2f4826c1a7c814424716b79293096913d3b53e453868e7c518bfe57b0770df3589b831f13f64b5e32676180f26722f30af10742477cf37bfb6f2095385a823362f3baef4cf81775398bbfff0fda2d7631abbee9c582b7cc6266d1e2f92890e4c774c0c53010de05ac0de9ee03337fb5e6fde16ce625f8e5c3d58ddfac7eebfbdd403740f05978b62091b26bf4280e5b9cf785f3c2a36ac6def1f293df01810fb6ef38d54f56cf9f7a2b62f9e77cf4b30d24ea670af0b02c411ece8b74ad28184ff414f0571d91eadebcf9644897efcc2ec6fc4782334a2a10985156a76d2873ac8900b82496d588e79eab67c7e3212a578a66d7fcde17c690ead463c4517bd840c87a4505e4e7d23002658848ef94599b7c02b637466541b32f69c4189e76e22dab5120711cca9754f3ba57bf8d28bdb5459b1ed1bc840a60a1e39957a60748f7c7521ad098fde707267ed65f332648096415e088b20f8cca6998f60a4b38635304e58e633f28179a5c1a15f39260f7b2d30486717bb1206c5e8c15588a2e532077fae1bb36a8e64b2ee2948ebe8b18374ca861beda9d503cd73bb73eb3112d7fc66810d5c36e91420eac029d24f8d66473174c1615d09bf12fcf2736af06d0f9a22d2feb3947655ae59afb5a66bb208840cb3a0670e967c5b160f1fcb32fd094878ba42e861f7f9d09053fee17941b455288dcd57357313ee583ee8881842f7a72c377322cbd56a75673d47d2f8413ebfc8c8b492798312032d4ce6a18286c19a1ddfcf53c327f88a6fa39e3f629e42556e034d8d0c74b9135bdc390758b4850cb4ed7d9f832a2753439821d28337e7a866dcf2f2e4f83f9788ecdae136c35d89bdb04a647482335f97970613f65d05b3d9677628ec07c6518077c81ff005552f13b1f78c8f3e853f65e9d4c262e01888e64cf009772172a20082691b2280d211f37166606f8e1381fba43626242b61ab7ceccc1b88e5bf083d4890befd430d42824515de3fddfd7280e48487d41060439b8a9ba721b8e9e1568b20109e6e8d2f37d5f6a0bf43b17d1eaf15128239654d84365db639b588dffaf2a58136c90f1d2639abc24f5d2e6e7d7a891c782f1fa94fdacdd4d2e705fb873a82183a776c997f945351df6766b8a75971576ba3948d5ee1d307f13ad34e90d7adad98189aa540d344fbdaf2dfde8f9f331c1c0c2596437c8a30725c6081a737e62bdb415b5a4a00f314f2b1df92bbc18d385b732fd16e59b30cb87aa0cba4de1937f5fc433abd438f0d52c1fee45b504f1503c2d93aad1ae9d8987a3a184bd6ac144a29b46653648d9945c9ca7ef836666afd524a0acdc66379452513b42739e74e17a82e72d2b5968bf24d54c721862fefa08cb5d1e797778be1c9808d100933ad3cc63ad33ac322ac985831119b1280771caa0d086e8aceb5eee7421846c8db251a4b85668ac98af0c7d0801a6ab8e534c8b8dcfb534149de160cb4a39a7141c4c6b212558d36b6c37c402d243b1519521f1866140f50faade2fa247a89945b90e2237803c1cac8200c5bea345c9d45a8d8ee9eaa0476391a7ac9dd46bba233d204165be2c174b6479462ab893360121694d5f5cef756850578afd28e06bf1bdf137e2d7aba67db6b610d8cdd74e042ebe708c608eef9486e2d26653f7969c153b7e24037d1b59bbf404b6f008d23090894c78ba6e95d7d97c95771b449d4342a435a59b725cfe4a9cdef03265a8bdbce029564b6d555bee61e9b1e3d9e8ee6d801c740264a74af1b86f7835a4f1690e298e15d4bc5469cae0127ae80285d13219f437d3b83987e5b1d883b8e34cbbec2f4a642581d0a84e0633e536a05821716f36ce2dc4b17aabbe8f55b3e2625bbfef328f7f33b1556be59390a5d2ec1b2cd5c5c73691464dbba28ca087517524cb2f58b406eaf2590e225b8e67a212ddb6dc47344eb9eab79c151727641a2e6cec9b21de558aa15676634499d20bb44daefa5a24185ba87296551ed2f6b1a2cf391a21791f5f190f26300ea8d3a6c862c28b8e55f4890499bd7e00f74dd1d10da9c6f399831f8d9fe46b120b68cfb3b1065767d3852e0d4a4694e28af7690e9e55bdf50789bb35ac0c2cf53e1fbf7864cc7be8c684a119b6c21322b5ed0c0a3dfbe92f66e85c097aca3bd7f9361dc2d43e63d63fabcb0219e5389d409addd5ec7b46f826e5ad534ec8b94c200e5897702906fb7dd7ba9dd73efaa96cc198adf26515c4e5585790efb9d2fc91401ed8a3442f2d2a2a541e36051aaeb624b9a0f5e89c5c7f5052ffd67834d10b93450c18569b530dceffbb569249b8ef09a3778643a4eb48e994a0ea3a253371254c5e1c6f42c48682cdc0a91f220dd02655e8c77ed50ab8f0e2f6510b5f521d8582079ce26de990e78d340106887ddfd20bcbe30ca9b204f5a17f835cd668bd1a19befcedd640baf25bb1366c1f82666bc57fcc60cd701dd344e884509f1c7df102f9fdea9181dee02f4f9dd1fac39cdeb19e777b92395862e005c69d9473a8ac8ce7b4db858e69d182f74864c1be14c780f74b4541352d93b3036054cf2c385123b51112c94400cc8b54733c4594caf47042d206f6da71ea1b54795fd39355056afeb2592bfbbbe821e9c9f8426b4cacc507475ad60c307fe694137975257dd99deab1e77bddeb3a25173fc5e61bb5627b5a098faaa5b9f18cc0ed289e8f3c618d81c402497f917eddfe284095721e0b4d24325ae924f0a531dd42f0031c37c7540535f6a49e90d4927b1691c293fbb470236c83680cea4202376b90cb1e5d9e2518794309b9e054ed659d0e590a78709d3e63004bfde1119a71847dcc307052c8bd2cc1bac38ed5729cf4aa19e2c91519b21b51cebb4acd64641e64379e871edc19bdccd1275beaf3384652dbbe4167beea5d7c4c6d841d323f5ae00c2f14c287b2d723f535f18526cf8fae7e1bd699c4fd0cef7a77afd02409e4db306fd48c50d88ac82d567e53cd3280686ec940ae55eaf4a0fbf941e55093b87f897317b0bc817502b81112b9666ab74332fb895cd838c867e530d5ac76ffebd0c77cf62a0854b1be34872ef3e79762dd65a9e4bbc8640411648e9160226b76e1c12b75eab60bee2f8d73a8eab2152d3c73340e30574d36fec7bf4aac0150a0c91fd07fc9c38b5bf9cdc1add2943d322be93488873c3739d41421672e0ac85f635874af2028e613ce96ed38dc4436449f336bc82b986232728390984de03f7f2d34642d5476ba53b5e450347f75ca3e2946cedc555203cddb72255ace0e2e4214921f39df5f12b8b8ed243c6be8741da782361668a8fdf9f6c54932e8dbf00010d1164acdfa16bc8e01897ef915a191f46ddc289bbaaa9e271ff1c2d563b01c397d55c6af95f4ce86407f04d7ef0f3f7fc830c21769f94b6db2de96e0472ff0a6eb9f1b652f46388e0f44bd3d45061ca3425ba548b8b39cdccd1b0b2dad13ded55e77aa9826b6f4daa5fa25b3f4a1674553828c1d3e6fffedb3bbdc4a936d19fca6f20c87e472051807bae74141ed81a2ba312fad459cb60844a65e836163373174317e1176608269bb3137ebc6b15021f9f6ef876acac435d6a46895e9337f26b4442b157118ee1c01327190b01a3b741b5d2c4900efc362700b04dbf3db715684eef58f09f8c9f32ce1518918f1777c46115a67dd001c60b7544ea8b3ab86c806ab01b39484f16f2c99add94207425047b4245a385ed2d5883c89534aed954b95af32a142694cf39479b673db19d2527d29247b8407192d0c437435b068a488a77990dc1028bff95a462dba54c14e1b50dab788c6cd1881adbe1abce8afbfbe9842c4be0c84c385f94578d25e7069562be17b20f9fda6d373ed903649644cab6070560764d7b2a67f6443569490946c18cb6f1c216965c2d73878cfd80445b20aa71ffd2508884a996542a406e12c2ca2781e3a3331bf4d38f66462632f875bb872ee9e93526946da014455674686f81ea8777a07b6140032ddc9a9e229af7af32a47f625c5559cc8f6f022fde05f94a7217051d5daea683d1cfd8c0b1f0eb7187f7cd543c6ad67a2f33bdec42b7f0318321286fdfe7e56e456d66c90b9c496581c2a06336e0dc0939c0818e780ae2db1ad61a9707c663266355d2f6cd994cac1b124f611ebe1a4be741209ea47999e72402a10b23b5cae7ae682d5522b451cfed5e86a826cc4e2b56b2430444156375be35702390ac6e032515ca034413f0c9e0a2c10cc810f705491a22a25cd76f4216133a3a6a2b76c0663bacc40ff62cd5fed0823caac35dc30bf6213e4505c80624340558ccfcc3daf83ed7bfd4e78c096ac64f46455acd5d539c8fed78c847fbb770ac253a76bb28f2302f2ffbf2564c8c5ffc4f6682d390359aa853a7f589415c46a9684273dbdcc060dc062a255b4190a73545ea63cf18b2a77cf7ee20a5f19361a00d11b8cab8d33a1c3efc9691e8c93a2688048c709334b015d89f7198581c3bb796f59895c47e016c9461ce7ecd50b4cb4e5b0bab0c082cc7dee93fda4a8d60845d0368998510071d80b0e09dbfd689842a538a9c0b72592eb522755760d414963b7610f85aea78cc0e56894dddedaf1d7933656c9254016519c25dd09347a76e7e48a300f44e713a4c8a96c1cbe1dc1da8c04ac17772b7197f6e8470563eb19b64d61a7619670ccc0a132a673473c255066bc3b46ee7ef1bc90e1b24609f9b37efafe24dbb1b525ae0ec1d9f07a551c4dc21aefb10bf3644ba4434b1036c2d9b67f7962331557cfa2fe254ca2a1da2e103cdf75d6a27d92f692de89875086984d9aef5335a0cb9957c313be7b3a9d1f29c933bc31e8e1c7fbe32876922ac88141c30fde5665e785f3e530cb8c205c05cca51817d680dd407cd5c288b33145e0a05e0d32d134b3c2df0b8c2b7e268bc8c0dbae5083a6bd30552bc7392f4f2a507a5e10d9e9c8ecb17bd729cebf30c0ada2f71e3d9b890a4515210efa4c562b5c6f5c73228c695f20cf456373246179b99a189df402decbb279509a9a6ec70a8849d9d4672a347712236941d8f45b0c3b4e8f076d09bf393eac01c5c5e246079ba7fe82f39b305f71c50db43a90e0e1de007dfd130b41d9a050dc2a37c7e9e7c0cb378e31f2cfea97f25457ca3bcbb063da004e14c28dd7ba22a89627530490c8549d90cb541f68b582c52f375f0aa726fe7f86195ee6f0bf05f4ae62fba298168854f9d09a419759afcbaa27cee7445fb60ee8d12a82d4f72aa066d1cb09d08788050490a45c81faf91ae492f3315c6a378d7a9b06ca708447a442e42f40112a2eeb31fa974d79b7dd63919845d4af4c470cb7986d34abdf3f3366c86ea3d112141aa8f10b766140f0285eca4f96add8aad60f70b262bb7999c9e23cca61b54d8fde290b236ae3561ce7fc0c7fcb39b2fa56adc791bfa6105d9f098d8149a5d518d3a9f71e8ac9603e8dc378ad0197f92b098067ee8c362ce1d0c5f8f8d54faa6bbffb2f4ad82a33eba5bed553d0327bc102ad21bd2295bdb5ee4edb056e84b51e12936d263aace569f42e25c9b3e1a09437b7825add51b2a0f996c53bb68c0e37f7aeab4649be3a7116c12a37f9e48f513c34e5fd98abffd94edf97bad9ad464fdc02f2c30ecb9408192683fb6a7b830f8f353504fcaca7518f3c63f0aadd2e21fc7b18d531234d51402002127230f6caef15383e3db3030b37cee9c689323ff16dfc5e326d16da3da31275a93c97573429afdb59223283848b30be3759c7c9da81b5f2b258df4ea094abb38a810ecb12ee9006ffc194557280de20bd5123825fe663a46380652c15ab2b0592f224e4dbf7895d0e18309255cb455023af3845cba230e1a933859b55c72aa5cbf01523c87599cb9b796de0a44001b6d83c427b0dff8fc4b92daa0932496f57ab71aeb7a0e19aaf394a904d66ea9ad33291a259075741981331ddc1a471373872f7368eaefba58f29cf046ca1fdf6a464a799d7dd6b1ec1135f3cae741ae45f3c0a278b070751d67074e856e71bc7b2ba17dbde30c3dd9d66612388d5274275dd4242bb48f2b9b28b4286b3f3d1c79578ae148b69ac40ca6998eccbfb8b8741ec89248b84e91a9f7233255e224307114bcbed2f959c4394b9bb89a3a42dc98ddf3712190beca55d21c252ee50f68d222c67eac98dab1e4fa27e278cb54c0201ccde71d4ce2bd741eef9773b1847ffa3851e5726230fe1f43fdc2e414caa05b50afd45b9f9fcce803590f12ae7bf93112fbf7b7c39072be308cf24958ae30313dfec271d9f6cd77076563d2fbfc1a2c0806d371ddeed61159d7dd79357458aa28b4dea75597b45cd51e8d0a87425e0019b48e9071e8bf1e8d6866234a0ff83e3cf6283c865524f55523541d4cbe2c1a1f4c4eee8769cbc3adb5451a9f2b90729a43e1cece569359e1452e4e57833dd81fbd4ae1cce884d482eed6f4482ef8d757066ef5f8e893b08dd0c9cd8a203efdf6bcdf54b333b225c9f416fc9ca95922448e50b7cb4a8d6458f1b0bf505526e5906da31373c1a6808f5634d4bd1d3d98f97632a79aa64461026f7ec9c088396f9638d9a7358586c0413bd78c3ba6255014a0053926136da1ab8d6c1d5c744b4ab23806d74e11dea9f418b0aefd16d9d7f076ebe1b13246eebf30ea4746600dfdd3507997d04e7e2e2939f76f1043e72ef49cb009e4a8fb20b7142dbc2ceff2a8d352c2b8403431c4627701da46759007844b9064dce0635b49c28356f9dd1003addf57d2545ebcea78bf77608c319ace58da68bc3e8aa0b4ed83f897673535918e22a8798cbcee117f583da20c03e13ec2a37a83b8d8d16bcc3229f8a7e9f1d8743f196b9a0c73513f2ce9683218d8919055cc64f3823a6afd474858366356151164b54903b8c3247f9af88437b70ca0ddd8084f500cda6aeb055b41ffe7149520039a12e61d81eba08a3d2a593f42c00118a7c2adf2d72d5ef1e432f34fb98a48a319c32f0476565b5082c322c0003f6625fea4b5745cb864a48ec76ac11a86b452c3213785bc3dbd84a9ff44a8ed297337fcddc79b5dc0ef824f3bf830cc2a5c2beb6679d3beb10bd2b9cc3c787a8e74906085e9a4d7970f180c5facc9a3769e8b8ec79b4623a9f13eb7c5c4880e3d1e8d3d5197b0e913e26c61d07cb09eac8be209db1e7094b047e1250797f58005d919ab87e920510b874304e32f5e78adff7007febe39754f46562d465d9082a5faee5d7223dec738620e7c50ef8dfe597e74c64acf8b152ca993ff0e266b8b764fb4fe8a6e326ec94eab4488fbff41b75d8313dbff19cceaed153ab0a0d64e15109aca19b01681995b3cb0c9656c26382f8d7e5783ca59424552a826d256daef2babbc0c98544ab6c5b8354d53bda64235382ebb900a29f36cf33bb70195295181403008ccadc2b1882b0f4092d5583ce692ea1aba61cef2a3cffa4443aa29c1e2df9b9d9219142fa5b7a3f62f705de7b794a14c96423f54ae07a85061e5df9e3b4207d661b182a2d1c20275676376af883f3667e92c81a7a42c9a308781201eb3d4aaaef5e98fa243309b34b16b8eaf003ebcc919851e3154d7dbf8669d4df316fb6adddc54cb017574e6782b6f5030d13d77b7d1c788fc8a9181e498c97085244cdf2d076ec9b0996b0a1170da66eeeeb08aa2db85e2d8c34792a41f35dd9644b1d8a10caa7fed3b0acb74e4749689db63a1d30c2705c811387b12978c22a9fbdc79abe860d59b0c7157d8c80637046775bbc1aafd496bbedb88d896b015e6125ac3b5a87d56cce89be53fb1f5f1e148b89b30ab0985cc045b279bd9912e72fa86fe5f2af169c99d422045cd1bd8d2b35294736a3fddd311a9d87e704d39361bd41e64cea29731bf6b53b897a0f321830e1488ae07ec8fcde4bda9712ac29e81b13878c3d9bdc538ed02f53af206533f008e0a1d985d0b6582951b334f446406ad33d1c66d9829194c07d05706f6beaefad0d3844ddf69a74bbf27c5f9d5aef0ee2719109bcdfafbbca869a5bc153845f0cb38501020b9126f42b954dd1a2553c4ed355c351ba514c3441e2941433d74a738b3039e1c331b61f42245f969ffbb90a4c5da303af41da319911b176124a9968c059e083ad2d5ac4852c18b6e4da7cad29e957d6c5973eb65417cbfb53a5221c9c60d306695e67bc1f3516b23d24c1eafb20f2a520fcebdb3d4be89338b244f10121bc21566e97b2867de16af1167ebb400bad149aa69f629315b49ad3bd1e0e7332e9e724712a6522284a28a96ba7cf7f66f1723ab407081c851a8950c7259f15bc965b6158e20b15fafeddfb852b96e7eef3bafce9f5e5ffaadb4535f66433167eb91968d888ff14c400178e6d717c36c527eca23dba914d1ae169aaaa2f0d3e9d36fbafa1827db0387cc4d64087d342d2ff419dcc499ae37c2014edf99ddda9e8017d9798e2ed9afed4b63aaab0224ee6f228ea096462b754d0f274061541c6983fe3a728baf189e747773240dd9ac22dfaad57e36393af50f4d75ca2148e0d93939a49259ee0ffe72854e5ed2c65a2bba96ee87a1dc8940a5e4dccb4b82f965cc6064473c12aee52193d11bb2e5eff733b1a9a01b12a2fa527c128424c9d66fb039a0df0a064d0f7f1c3ed5244e2f8d4210cc8e68795fcb7f23620e3890710d01546cee0e54d3bbfe6dd3b5ff3db60f8ba893847d938ef6a69905bea6b46b7f5b4b6b4790c7a46dd7521b793f30c4a60b68f7facab4cc31b39e80f339d22543bffd3dd15ea73913612644f1bce195751392dcf46b284adf7d597e3ad4b336affdfcd64c86b45dd57a8a8b6022deb054fe0b614dac85563275776ef1d3d4b2e86c8d0936ef5dcc2838aee667aefba384fb4fda5d1cb48daec3f08711b9b69e3a72ab89ea8a26e40a5a2a51d55ea64399b493284ce423594901274be57c132994759b67c12e7d23409bb660de0dec9283237d217af4fd72850b54a27a490b35b25a44fa684e782e94e98dc807b6baaa98f032803f83cd27a4dee37a3c9246c27e43e1fa88c941e2c96b0e4e3061460d7a4073ad23c704e7a30a619fc4a19e5e4182f562f4a8764eecf36f9272911b6836244273352fa50deed8f88e107e27baa608320537bd704735ad3f7d6ca2b9092d6e6e0eb27808aa4646e2128fd8691582577d9a49223d5a873c8baceabccd7c691936ae93e6f91ea86c7f3fed0ebf47a6caeb7354b0384586bde484d41a370f794721d47a2e8be9bd66de0e26c703cd473c38f4647eacdb0bcfa8d4564c8ba4192866669fe9201546aabbc3d3937c6a26ffd63b0d73604f94742032dfabe4a5db56beac74b06d463426f3b12ebda688abf27e0e4aaf1562d03daf6bdfa8ca5f8134394e1aa9093aef61feca79eddbd934276164b123e4be479d319aa3e9fd12f1ba43b37b43e5130e8a385127053960155244af15b4ea99e81599b707aacef001c4cceb6f07b5ff4896f34c4e24d8ad3c91b5edbe2da5c1295d42cb8e0c7d9a2dcdc5e82fd6dc15af330f9e7e36a19d42234318e777691803ed92364335a513cb852b8bad5d1ebd1b1114a2780a0feab691585cda483ea1da05fb06cb46db2fa95d921e2ea25dd4951c8e48859e5f4035157c9cf3342d45d5ea6ea6552e0138bd96a9582f2b61198692f82c993f77e0b12f595fb724e52e13f16731d1d1863f7b05192e76d55f2f6d1e32403a3368356e45959df5f6610ecd5d55e06d6b7c409ae08aec9db986ae2184b4f1bd459c014cca6388fa4492dd9410650c5d857f0131f5d753a216736e0dbf288ef82f0ccb1d66624c0be4fd84d0e8aa7428f06ea1230e7de0747a78a75f1a23efd9dea185d0d27ed7f84ed1809401e1ab9d330327cf6c5b0836167024812d26c2620a96ac98f2ffd8e148d3d1ec623f03ad7def0be839bf3acf9333d26880aebfa85bd0d09f56caa08c0bf4c523b6ec9a6d5f8253cb3bc88f6f4ab31103daf496d1b742035e7e7bb50d555e47351009a377b9f53b42ddb9616e0b74f5a1d0e35eed6ed0d012fa5ffb23bb2e8296567b14b4144cb5e5eaf24ed45a00082534ac764c8fecb6961c499a6c5dc6c27c241cade49b3da151c998f96ec096d61828779e6cf7c883faa4ca7b89dd8d5e1fdffb9c6a6fdd04c62dfa23754613525ec3ef7b4ff51a4979ae82da9621b8212f0eb6216c2451ec4ad62349236479be1171d1d4115743c9d4a65213d1d397e224585cf2699e016fcaf9469ac21cb157ed5faaf0775a84e800554fd1cd12b42a726263a783e67387e44e02333053f0aafe74740f5bd74d5a9b047ee2f4ccfd2fd6cf2ea129012ef9a8bc60ed7a64b2ff00c5aedf6e1dafd65389ffa1c1c961108cf7a0bcfec21cac967664165d83af176825b6e1044c60ab265e7959d125de3df168d88738af77668a7a7000b8162ee1eedacd9dbf0bb315395c4590c3f469081013e45f8b1972aee65ec4a11cf14d34b83f03ce365cc63828d71e7cdba41e5c8e3445f94cd0d9d380dfe4e2b06ef8fa645c43b58d542a659277054796e93effd014c47d66452189cc81ad4d87f0a67f153f2389b9dc16e2657f149b1713b28a943890d2b85c2c2ce3df8a4a8c8e7bf46249b5a52559ab737be86f65204a2f6d88d76fc641b66651b407d75e1ad43e4d0d40b0753d66e48d33a016cc10803fda4dbc760b2d026f421951119e09cd437ccb9e3702e5ecd9efab626bff4bbd2134017d85e7ed29816c4054af15e2ef7ec2761b085d0a2e229ff16979f9c6470ba7e836417e84f61d79f48ec3ad176e1c94f588cd21c59c3f0e52f3046d8e82579839a14768c42ea69884e288ef407777783b314a596305a543f4d1104b242d4512f9aba320f0a571129bd236f69a7e7e04ed78b8191cdae60f27ad6fe4ec3488a6ff4f1d905e10b9506a900c4cc2681c2c2d266efc1e24880c82879e49e9f99e46d171af22bbfc71873990d6d1c6b2587d7728cc5e10cb3cd82507592d6b349085cc507c64dc66192f5327b2c2b12bc16a6239a18cf5032ebaaac319b4114c09c7784509530e3d24a369f4a62d3ac957626a5d42cb98d39196f2b76bae3c18adbe5eb9682ba6c131af2a83bbb885b6167fb4ede1bf6b1f5a3b9e214fab80c83ef004f36568c45dbbf9525f6e9c923219e89813172ace2ed00036def72297ec1b9b8484d42e2e80a194060e87178341a334a811665374112c9c9d7ed047d080d81fbcc5a0db3fa6afaa58abd69e1554c047fde53cd8803ddff25a7c35b2442f3d011f42580fbf2e763a2d4e0a3e6f5df368bb824f9e0be7a18ba99ecf63896997ac891e003dccf8bd2e6f6d7d71c414683b180146b106c9b3827be7be5d8f4139aa68865761f96361060d719cd702a34a41716c1fa996b8c7cbd096d45cc98264082d3dfe98c070293245caec7025827f119c367bf0d8719506fb441034a3d5abaa4f62bf6be820d2a5135b5deafe520cce19f49a40c9373f54ab60ee58f816f79b67e8cce37618e6d98c515d8b5505862892ff65da01d89776c20b1431a6b2046e3739c2672ceab953590210aa738923a3d9d238983106c52ef1d0ceacc9e866524d30c1ed68fe0aa0e1e1cf578378df9fef6f23219b5a92ee16058fbdcca597c9d9e1db080913c38a787c00ca205ee3e5987f980faceb1183c3148806506c0c56acf77b988dde93df3e9eb46a359030e7c95fd97c01d572021a6b96103c53ee8b2e3f878bbdabc2cd07d706c9614eeb5000970eec53f5575a68c798abbf4d0bcc148e5074a555130a32449207d90c31d21ded6c0e02979a3a7e71928d57780510bc0557ddf9bbb233d6aff3c93f72c3379fde06bb0ba0b909c37711040f3ba18cff2f06dff985a0532e22d267c8af70c58b0e4909444b2a143535b8a220616ec78829cfb6fc81da72ef49cffb275ff3cfffb5e8917d2fe581f718eddc8b37676e9683457a7edff0cdcc8f8ecd91669bfd2d5b3b86267d93a70071e70ceb3b81a47816fb5309b263b184b8a45edbf5d50a33fb07692812fb19abb69d7d49b2e04dc2b55a55fd4b24988b7888473cce1170ef1ea38ec59685ac3416b7623c44f6a891daa3cdcfcb99abe618a799f5fc0eebe13f9dc812cac70f293b47d189186d7f7cfb788a52b3c3cb8d3ffb8d321b2dda117fc562b6ddab1302ece5db61712f66d865434615c9ce52ad70ba675d4eb99a9d4457d628f02f39953ab0c092481f00212e0a26e649853e45a44f9f509341bf3ec228bd17823a26200274113afeb4128778d2c23368ac081a9473361c24cc181f8b4eb5f2ebae89d26f39d8a1ffa0dc98ef297cbebf94e478da255c1ca8a148412d7a17bf4f822033e003173daca5666b2c7c0fd349d139f54efa22905b5dfa94006cf5711dc391b9216c5116986780035c28877844561919cd466f793b2b4e8c9c766f6886a7db3a16c26ebab23257c882c2918044da46425b927eecc233170bcf661b4d48a78e7a7830a67cc0f2c2048040a2c3c1bea6056ff6f5c4456fafa58f4f57aee8e43c64fc0539c72bc5811b1c552a30e70a4fa55a7455b01a5db96bbe681fa6d1a9e9a7b221e43925616480b8b39b63a5e0bc40470e70b7d23ae3047f5e272b25426c7c851794052f71720e1b193388aac1e19eda483e75b31c646a9552e425b02e205dd125bce838a020ca4c04fdcb83af5069f33ad06349bc8fe6bf7997d0e72d662d0de4b5a2435ffc1aa0e042e3ac37e549d9581482bbd4eb83d37b9796df8aedc8f54e1e58fa981b1c2b9601f30ee0818aa5e230b8a60963f3ecf27a57033ac265f7d10693f2646e1a27d97f2dd9bdf2761f06fbd47fa2d9c8c1ef9d37f5cdad1660f1d1880e858e8bb7f2a5ce018181b6f784560c3f256d26e967335310c94e25931d94f8747814db09999db924cff6752dc6c32751e5871b73d7ca3232c8fc49a046e8a760a7ba843e24f84bfb2ea32b0264f2b71d99db3891441a22df4010e5e89d638ae1cca5a82f5d8198a461528e0e525428043718c97a3a895f324082768e8daebdad77fc6aca550d36f747fd24e7308ac218246d6b03fe67545f6a88379121c4c01f1a3612b5df133bd90edbc0711ac2e9c6590e5c4688d2f0f0f0cd030f38bc059f92b8e4103b723aa7bf2fcc837c4758bb8c34f8af792760a66815135cee72a57193704e63e4b36d12e09cc74c275f5bfd57cf5b30cd8a7e1d664b980dd96742523bc8bb82202f641f86add8da307dd95269f0cd2ecd4e6f5ed32ae062090a2c8d9f08ca61ac013ff0565f9e173f5c637310732f8e414b74acc178ee9ce35c1c0a88145a0a0f90f2717e28e358860b6815592083672fbe867500e3b9c45461293c0a18e8d112f9c2b930a39bb8eb9d1fac3a0d71cfb80d916fc84b90e2ef747079336f45eeed52e4b76fca0212b67bca6e2d67b51105c65b122991a2d1427abe6f23adb2b64190803b91b14fe243495af6f02b820963ef10c527159f9c8e0559bf5140c4114f664a48f419aa7e6550c4d4fbab82ad37d85829d428d4474b5d015b86c29fc956f72d65eb39db67815114146d277e6d180652d3975e651dbf0bd44d87f4f9304f209010d088e0d20bba7f4da821b465f91525539f6a500de5906633fa3dba79dfc87965802c67110c4b5830cbd263149abe0763e218aefd1c999eebad5640988890c6c0b9529b2ab6c6a42a2c24eeb3ff1b0122eeba184d2f1722a967542e9d4b71563a59683ba52572ec781f0ec1c062759813eb3159092b95c093983803f895b178aaceab4543d292939ce70139c8d0743e595e7c4955862d590e7c271cd57969d72145f4d5a6e3e4bc458e4a31e12b25dcb413427f44c929d996d9a64c894d75549f87aa2a0197eac3f3056da45121d431e059fc6da912b04223df075a4ba4c3ef62fa52fac309bfd6fd0561f575c26e6b2e0a622c1053dee5b9ef82e743c73efac0860852282bf85369142e2f511ceb22892823ad734847f630e1931acdcd6f58ae63fbbac1e75aa2bbefa0f933f85f5402adf38f8fe612582671183868535150aa159423c8cf94165155a8280afbd1d62993841922abe5a6490254a3c80c19329d991e333618bac1dc955622d611bbdf4c26f2adbd398f0b386019c00366b242a9af8fdcf6b10cf548838bc8a7120381e220f3bfc2d72ed92f742f535fb7e414c84737a69ce2de2ffbba0f2ef56fb481f571989a4c40682d79d85ba8f8a1dca0765bba2a094dadee7f180f8607fa27135b28371ec215e204f3b3bdd5add1ca85a3d65ca7352507b7d07bc1e69304623f9f1634fc0e8e648af0985cb863fcac642c879fe5be461e8a4a19861fd61adda69ce0f0ed2a0bb9fcaeef9760fa32b2f98b042f443efcdea3eeea01f172b130972bc8858ba257166ed16b08573b6cd914ee7f665c0d97efb475720c3cad82a67f86c234e60d4454d82d2e7ca612e0fcaf98e7359f9778263dafb4cfe8e54344aa888d108cf26320fd97d809250ee63b02621f50ba4d04ffe97776b15e31b84841a244a5ccf2f8879f56756f65c26300734015f9897c0b87d747d6bbeaf43374649ed306306c9e84866ba05690dbf9a1e3c7ef37e1a3b09e2d67270e563173d9d70fd7a5e5069ef66afce0118a28ea45122bd3860ecc6be051c12357f85c0c6e356d5707510b01b8a5b02bb61e0bce74291c1a0464be8fb861457862aecd52a4c0baca3c7670a0056f8b711f2d2957d0e709341a0bf2706ab90a33432c82fe66a70344890a189ca6782b1a09c0b0849bde9ff9709e8651ca760770c6a6dd66b07c781e8e9c35ffd78f328dfd6c03ff7ce0d445b3f8d86494f9d205debf83c3c83caa7d83889b341adf23a92fe8d85c199d03c5f2dc3158a55ebd20073f6a0ab03f412de00f7919271a6cb66258f5325c85e8afbc439e0b0513c8db2e749e33160fbf102d476da5ced108306a22af799c693837df7d2a67c08d4fd10ef9b070bf3b572fcd908dcaf170fc103fe351f27918032271988b1e8eac0f168f3fcb22ad2e0777564e0a81dce4cf1f98c58f064016f1e912d4aa9d1513d8b5d0d62391bd310898949f63de614055c53f3fdc79931a98fe6194498fb7ce0a7eb8926cf514727710388789f9fc48cc3d23a272cb0f1a166d4467f2b40069ca88f1d643b1f88626ec9ccd72c1483e5627bd097246c49d323d0a58a5bc17467584ded5b594552ce9e17e789b1c686a0fe4c07e9c0298a11c06d619a2774acb26a24ad376f621b579376a807729cec97598a5b53e20a60ff9721938affe0c89635a184a1aa1f51e7cf1b89dbc3b6a3d724d5f62fab76e2a57c9a31a4f6252270b05d74e97b2025ccec1e794be563eb257e3abc9b426358a3bcce31c9b41719a71a30fcadbff7a5a56af29dd1afaa1ab2506faf55dfa49a057b75e99a906b47b505a7657fbf61bce471c3400ce2a966d7cddde293d85f98323d543f1cfe9fa2889ffd13e9ce0ba590c0277a35bd25ffdfb669876c894312fa35f42602aace08256868d1fb5a4ab5d042b658883eb24542b0cd61275766da65873dc4f04ea530c1df5dab846fbff20636fc97da016880325a62cabafea325b35e24a064676071f5716ba9e5a9f9ae1dd06b58a57359b933953f564bd7a9f8b09c2a490340f8245fb2d74151c3c7e3f510c7915a4ff339b1d88cdd2b5218b53cfc2b7ebb15a3f4fbc0c27cbea7b1ae8483575bb68fb93fc5fe6cb0268ec3a49643ef3ca47218f1e4a7a8b7743214b62b6b104f54b51b1944b55006529aeac220bb7a6458bbbf515c1978a42cfbfd5bbe0a83bb6ec0de669db13c76b8aae6a4ed03437af466f09b1a48de25a78ad051444f4c3ef199c6443cb358bda399d23dc88573ac5b60239e2461dffb03dbacc39ff663810169d9d056b4c8db732aa8faad21bf441b605c1c2cb7411ba2fa6feea7a21d26a56b873b9625648b6ff8a8a63e9f84331b5348d2421bbbfee2045aace6dc828d16d5d8dff4d5fdb9e627edc9a47d51fa5639aabd118f83bf8a47869ff165fba6d3d7306627934d6969c092226dee5944dad8d698ecd1458bf09a8937d3a70bfe2e9fce121b6758f0a05ee1c0794230488e20696133a4dc35d8e4ddc15a30eade7f91a346925718294b4af7533b46bf8220e213b6c8785b45a49aaf11ec43c465e0b8d47e8250cd18bcb3321608e033c82d7dc71bed14b9f425a29aa48a761014ff29aba35041126a9d1abeb7448fbb51712f20f342b776c9805efa4322314e11091c8ceced8a139a3273fdaa8736620596f7cc0a7b3461810613e2d55461eb6ac87faa5cfbb2ff3a94d29f2e7548e1130a2a74fa452c4a11e75192834153ec6ba2c1c0bffeb37016a071abc35cef16f57472eea79b62709a47b078b8e754c5e590382e973a205a8d6aaa7f8e0744d1da290dc5101838dd568d95769d50accb9a49eef9eb5c7a5d9a5096a5b53026323870b6cb202f50600319e9e5e6efadb729092db8fb9e389fae7c7fe3db0bbb42e4fd2f54c0826dcdff4f3cce26e26e9c0c3253ec0c8927890c42fd0a75abf55adc06e04f15e4501d92f8cce8b7cde010ae41b70d27255efa47a5ac1563dabe571924c8f6eff053e8626d6f3b88f838b5db1153ba5bbee3cdfa0628b5923c2bc4c315516c30056e325543c747f5dc5e5cbe93a8b9f7e3ae373cf9acaed734723be928afaa4d7aade27fe0f9c0bf8d50244fdfadc6e93de4b9a992096c8d3876931fff7c1dd016035c0bd6ce65c7d27e417cf5058068ccc486ad036bf949513bf67bd2c60c8f7c61ac7aba0ca911cc677eeceacb0b466ccfeebc36b79ad901ea1aa48e5a343de84e26145ad3ce246f1856e64b6eb8e26ff8f890a5e2441083ff103a67baa7d48ab10225c0e88ce3671580b145886150b6569ca62460a1f497b095618f10024fad7b5469c919aa91bce430372d9a6fdd0e436a2386259ed93c50ad6b0313bc265119718b6b5f538cd8b893c79a7f43b42415b2e33d49d81335a8f1a67c97dbe07951fdd954410af37efbba3148a764b05701fa79945368085d020cb9e1fcd72c7bf1bcdea5603495746a4807069160be8e6dba45ab2a6f998d38a92ce56c1c0c52ee2c4f95d37458f0dd32b1fc2f72377db32199ff9abafdbcdadf2f0f064aa0d17d6c657bd3598ec6239b3b54e6f55498261824be7e5395202b680911b3f23df37cb06f6a53486c13cdc5d0a7a1996532816183d4f251263cc66d6e7cc814eb8faa882454db6fcb343b3c582bc939bd8977424aec81ca88c4b54b8d58d37a8aee5a06fd0755f3207b7c9c4c632fc559ab511081997491bbadfa13edb77e3973efb2585d67a435c4052a372d276019ab3ba7bef7a6d5e2c745935a0fb7adea9bf8a3bee622c6ffaff3ce774a673b3b7425ef2ed911ae91544fdbd8d3b39b2b68a4597e40a61d3251001447cb6a8ae831e44b2d659bbf5e20fa0ef0322effdfea43201cd7f326099414cc9a54c98cd832da4b11e57354f52890b2da07071d42da348b5f5a765c9847d275d76314b7cd91d43e14ecc8178f11125debdc1ef7399e6f72f7717bdd8685e623a891d61dce5fbacb07a41bdb75e6ff3b10d05d114a3f1368db2245212ee57de145258a1bf26c708948bf781178337c1d7f3668c5fd0842f50f5c9ff189c5bb89e9b523957135607e61163673c54563df658362ca3c31cb6e2a211e30e570089845c1b9f3737f94481a39dce30c4b07db8de104c2da53b74ece113908930b4f093a0073c086850ef5cc232d37314a0e0379005df96217c8aced6ad0aeaf0f06db90bd520194a96de0bb5c60aac8b0834ef80d99be85ba5c4f7aa628d53b0055d5eacc8a2e2016e952e6980fe3d684aebfcbaed19858bfd2dca471b76d2eddd24aa953046e3a4a3b630f020082ce8764699c39418d9f1666737fc892a52b2718990901eb0c729c7634231de4c10c517b0803296333a5bf155a66029f28695230e2cf6f96323f5d1e3e42f670fc40f152561990847a5a11c3687c4707369302c58feda9e508b8841ea0283e5cc806373007690f61f9eafc78390fd6917339168b31d0f32148047ccb681e6048ece807e16dbc3b72a6d20096d04c40ab01decc6741502431a983cb6bfa158b7dd731eb245464311f3398449a0ed14a30e5f6fd6b401c304da9ef51544666185aab10468295f9361097ba36e2358055d064bd108601884c1347e128b518b3302cac7938ef3f8bab4ccea1e581578c5000bea012e314721efce78486b2999b1f7d9cccd1359b75886f627de467e65ece7a979507a068c6cb6cf1996b2b71ff95b800ddbde185d56e078ce346227df9d5a71191fa5c5492a2d6f936843c3a37b89d33b5a97517d83d97da93a9112afb8a406ef307d529428c4339ddf7d9fd9ad06a9bca1cb13321f202dba7614418b3fb40a678c3402b4ade28b96e8bd343a7880498cc3d4a1b8bd13cb77247425327d7807bd2d7a06261910052d82c84132aa3df4d492a85550ed4e53bad2cb725a48daa362fe265f5e3a1cf77825baf19526c76ad5d78c8a1ccd7dffd24b2cc0bce8f47cbad92f185d94177d920830ae827bfa6519a6e25fe7ff9f0078062ae2ee873ada88c70c8f88a9dc802523f9755ca278b76d6b5b008daae24c3bbea81747e9d3e6a04b80adee8c16c9e1200af05ab81e88d5debbd1d32910d8bba1c7095e63520475100f6af0aeca0de0a14d88cbe7a7ea5e4a2e26d4d1736fb0d9b5b05992a37a66db054e5ef9060ed6fb10879dd3f0905b5ab02236c76206bdf06c0b1d31e78f09ce89af500a84cbeaf13844522d582f4697e10cb2dbfc635cd95c3123a2f2359f86ac34ac7caa7dc18103c546660365c16d06283803a13a5a302664889afc083194950bd47e0fbb2f1f6fb70a9780784f90034f62053628e4229aaed2e2e6b16948fb29f12d631881ca7757ba6777cf12a6dfd59690e7eaa9b2d577f233d5f4f8012128f60f653cebcfa0ddc01837a40069b212620c93fd40cfd15ab13a1891241efdfc314e758308f89859dcfd2b5a8823474741c9c0f1f421406a0e5a28a7312c9acbd0a51fba570acf200f80b2297f2bd70bcbcab0d489a64f4f25efb65199eda4750fbba1a6d3e6a2969ecdc247fb21828873bc0263f5177f8c4e13a9aafbefc6d091ab7c837bccef7da5f499cb6cbeab6d1f6c10a584bd9edd183c67f9068fe2de69c17f417fc5c8ec9c8a1d5b08d6c2a3bc29bff81358b2f0c9aee89fe15d0eb636954eeb56efe1b9ce05aaf36d29564be7e66045291c75f2dd579bfac4c444a2bd62b05c98dba3c57e47cce68e8f8d270310ade1b49c464ffbcdae77a57038f64abe2d00aad10e0d4f170a1cebd3792b3cfa792f05e2ff8f16c051cef22c558eed92c58b4e246ad0ef49471113d501a56c7d19e051479172dff997bb26f8c9f82320ef151b232571ef43b84f74eac75775acf72fe508c5d52d9b6c88fc9fa7f89b60903e4ecf0de2ee96090c96bc6863541437e20db7feb616642aa8626a0d4918d273780bc13438cc984140eaa01edf3e9e2650667d6b4d47e63a0ba1944c2b2487ee5c2b646f1e040646bed7cc7947e3fd4085cee375fe977e06c5e8f2b8b7df8aa332bd5840aa9be4d93081874afc6f20e0030bea3dd30b0b2abdbb74db25129f1db987cfb488a17a476ac00176ca3e8d2d122e3903320a62d8c8b5de1bdb35f7aef2fc550ea26bd6087eb03d85da37fc67cc2136f01f0e684b26c82a68614a06dd49f2c123e4add8e5eef1c090954b02a46f1889ad9ea7db4b00cf9069c00c55008d4ef6078920c1121e1b28c23a47869895a2e2142868e5749b0dfe2bb417fa1cab562b21a94bd5285799b6bbf2353dfd247d160ff62a727082de692d8fc3d6ac52a955bd91ba9833a83b3dacddd78ac96ddacd88bc28c84795b647fd9da544dcad16e2e717dd4537d726a2fb397988096f27291b9fc3d103bf43476c22bc6775ea68fc09bcfda97f3fbdd7c674abb35f2388eb8cef200e0fd1834edaf4e2ec94e282acb102b1c61178d740fcd562e34eb0e4c816e594eeaa01ca6a97a7a7a453dae56e791933015a08507dee9c58dccf180b43e8a77af63bb68c1db86a569569578eb2ab58e4f6cc79b89aa77ce4e554e991ecb834112f1af6a1f2f80e15e40fe5a204494cb22240ea89e8e62fbe30b350f26fc7114aa6ac6d2fca13743ea016e2a9585e97daeb27130ba2f960d5234cf9a813b75987ba54a265ff114e3f597ce53f192c396c9f333a860f44308651fb5ed0d436c9fc7276aac4160ae81dfcd4f66e470ebf68282975cf915f248f21d39d3ee931d748749ce85f6758a7f5d00301f07ad554d8afdc27a597eeffe83976f30cebecb87fd03095dfe93be1cd050b1bdef8f6405b0f1b816880909fe4349f4030da0e87929c887a529059dcf39648aff07c3ed7e3b2acb11cdacf4cd13a7ac84271ac63fbd18597f1036c77bd47f0eca89d59adc977eefc6e733d44563c672b6ed8449c69ef16c0a37c2561ddc6a39f53b590966f9bbd7008a7b710dc759cc1ca213c7590144ce6d45ef4a66fd6410e42cb96e9a9c4c6fdd1d62c31eb87426336e7f760b3aadd8e7163ba1116c4c4854837fb5eb422965cc34bfd8b6875b9334d4cf2ba51744fefeaf1fab4e66de92724bd3823c9ff39a2f4f66a7b419437096e822d555b1bb13395b745bde22fa5b3bb29a218f3ec14acdb84e3e58216dd7970ee5ebf7414a9a0fe390f924aed6d582b09da3d7552eee0bfa5a0d55ea037bf3032bf5ac43466d0df98152411f83413f74047e2e00c54a9f6ae7f5a3bb24a1d045e563b2189d7a1e9588646493e2efa3dabd71ce736739ce65d7a5550140ca434e5f5c8e3a0aa2abf60a6bf7e41467cb1cba485a7e96393c78fbc0876d14697c4570b7657c835a293645f0f708b8624b2416745ca55e4ed24f5bdeac34eda7a93be51f685e046545fc221d634f0063a662c2cf4428c379ea100c216de809f1b42346f1a6bbd853895f9dee2ae86c30def49ff87f9e011ccbe0532bc365ea78f618227de8dac41ff0af4293851340de194352dfaa2962c429d7ce7198eedf925999a51ef9a1d4e18e0e32950149522015daf1e3da0eeecaf52a98b28a6f2ae6cbe5caeedc73e9f29745d221449d46145fb8500116e43f04774b0656d0a9048c0d764f76d55cb9d1235937bf16b2a42a2f34e9598a3a1b2d13ff0eb1857f33295f966f49379e4668def4c9de505bfbaee907218f807fa2e2f63446520a132eb570a66f7c2969a20c405aa681b1b0f3bdb180f4cf9e5a18eb54d6c82a17f37fdf051454f74007ee8fb4f4447b5c351a0e91e41400fc2f6e2eb5e32b2b86ef30ab5fc5f0ef95668c6f024a3c0fd1cd86148b9a9ba102817273e46e6d70c618e8d4f98cdacb95ac70d6dfe94c0614cd6d4a51580f4e95d3e4874bb49502f61b16036757a63aef5d1a81d82f7b88647a47a4008982705509f671b54e61e9f7502db8ecc085c564f376cb2a37abf9c00a7c996542689daaa893291300b1b48475526ecec4070402ddcf447dfcfbf8f94c7cbc4f5d6d3bfd597be6d93a9bcdb23a6d8d0f2f437570a55e55f2b2170d4754bac55fdb07c96b302ccc5ee711428a412034367545a9220935a732f631dfc8a346749e69ff7f445fdcafbbdf587ce7fd0af260dce519e2e0b3b3af5c480192a0cc1a3e2a3207fde3232f0102c96a5c1312b9e61ca3515ba35c6669aac4538272ea6d8050b173833d0dd274d85c950e7de02a9a1225abb59463453d525ab6a734b726e96043e3ae73bb71223986e5ee08808b74722f96c2746498d12cfe26697c439912fbba3531e602b68c852ebb947c71b6e5af3e3a428057db00572453939e9ee5e098570f5b1721fe748c4c59af20e6b33093961e1173589d58a5a895c82d5a4881244610ebb1e254b01ae645479d9eb0d2e9b1cc445b0d65ed3aab19af6b917cb69f0ec46d337d42633f855fdb8b7cff0075d209a9ab5228c37801508b29bed37c703b58a5e66e555244312ff44814daae0342e340cc67ac2d471bf9cf01b06de595eeb5299e4f6ae9d9914560710a353985d0f6ed5e882b2dfb079650479c43b144f0df11e10e613220e89ddceed221f42aa672deebe66d213384f6181cd24dcf8be174d611aec5e7e707a6a66b59dffebd2996d64af8d7f5aa511fc7de4314a1f2b08130aacac2b2c88aa3824bf8abda3ab302597c0f87f4162c14a0745bd16148ee1f55daae7c02d9189973c618eef1ed516cbeefb2e6c9ee12223c2b9d08dcf3c9b7bf5b5b60170878fc979e8ee08c13776dd23db7fd6f3051aa34a6caef9ba4e9802bcb49f6ca7479f1807d6f5fc3bd6899b95e5e092283c3cd95c13fe64f2087c83b4b5c3093bea8c7cb40c3ce5900f385a5dcd39e7d38cbd57f60936d6fce6b53f99933a4bfb784a76ac892985cee682d28fbbccf5a4732eaf55a3beda053c5ec7e456834406f023ab08f2ea7cb98a1de461ba5796fa1c556cd338b56a5dd642a559f4c4d73a5cc2c87dff2bb12d91f9ea37a0058543f639ce88fc00b26ff77daa98ced330d6d8beefc05e4b4b7421d11dec03bdc48d1a3171d41edc99e1abdac140d147a2643b7b2916f99fae5a3506dc3a467c9afacdee7fbd6e567f25c414cdcdc6b8d6ec2e93decb35c1f27d2075507baccae3c5482cedd440ec0ffee43280c9de04e30b4ecf0b5a9e6edaf7348898367f0a7edc820149223fef79f242a390fdd45bb232f59d832fd32a546df615bc83a7f9930b39ebd29b7ba07fb3bae52f58c63c86c2714bf2bf984c4e43de66784a404b262c6d9c22df6655b9f7dcb6cfda42606933631f5b55fa07a5a8227d2f1fa118e732606d1916e8e236282e3dcab9e2cee0a7fb1a5d7e5e671125929ae1a4433615effcd67bbd02b4068f4dbe7d4aa1e1ff6ea788df95055881ba1b0ec1e8433d3c5f048f5960f39ff00da1061ec2ca2de0fd614c9a3c1db4388f9ae3f0bec18394ba3bce9a42abdc29223e3b25485ed606e178964f13457bc0ed01e1700c9ee29521c558fddef2d74b643bd801f950ce32c28d5287d09b77636fe7bec5f05cb916465503835179c7f8b0fda7c1aa58f93b8509913ee9063a5f1658208f4ecc9362324a21f48e7d149a1192a6863b19164837fe45c590a189e4d8c5049619f80e966a81c87b19faad7a860b6ab78ad7712772dd1daa31e5033f5ca358e6ea5b518da1c38e0abf0bbb241bc0e9ec2904c97ada22ee136d8738603acd62be6165655d4f8b80bb94772b122bacb0b57c2a9193dec598b8cff05cfa2625adfd89ce38da6194ec8b83680cba4e9aaa4c1fc377f67216dda5008c58048a55a39837a08cf1313f44cd60462b7ec723003d5b41b022108b45934e9d051a3baae34dec91934cbbeb927acb2c8fa904a268260af6fba1ada3208865aa56cf05e87b08b85b6fd7ad237007c0fbd29c43a6b307af7a1f7cd4c3235002d6bb68b4f37e8ff5a8a400120806d12f6cb248e020691dac3fa8a82cbb66d4c9eab24e49e3c7f60deef91cd7ec8ad834b9760e1b82675fecf24f2aff7609886ba87ecb8bab6dabd5171f3df736294ed459c6ce3f5dac5ead48c113fe893708e66d43a33033fe636400851a48a09261e5bc3048bbb30cc84038e889878a279f2562e40d05e00bddd749094c014108962a4e6956a49353d4fb4c29994f85bed59de971012a7138f1386e96e5343448cb1d5cfecb19313868a63c88a6bedf63a8a06a49149694629ff53c78ca5eb3ee4b1e72f48fcc6cecb8553db401560abf2c2799e1f1b164370df28c3b6f73f9e61c74c620b7a0f2d6970c58258e1fab149df662f0de82d17b41d9c259e83397ac583494ee0d6a150ae1abf41dfa1db3c791dd48c85460c687eb26db0ac99995eaa58073abb0bf520faa4023ce260a3d5d7189d9be779c6874ab7d183e418b1a7bb81da0bf620a09de59a356cd9e2263ac8d978cacd8c6141e0c563a23748b15bd6a581d842563cf7aabca379e02abd2cb68ce69cce08d429d9ca7a33b2eb2a2cd06649a775bbd93fb5b2819220ea3ba8842d0333acbe7ed60d85a39eb9c39bcafa16270fb0e6adc39373b1bba575b52bb5bbaaf9a6932cc5e242df0947193da8c0bb1b53e4a6a769faa15355cc4b964d67b0e98154cafc32ab6a4c18af20dbde5590360e6c980fa57fb4395514e321c62f60d4c02576b8c689b1aaa65f60a56e1998f93c8f3c4dbcb1a2f45a0464768e20d1c751f9888413fe106b7e92b060c276d3c2bc233973f0317e18a206571cd6eb37ea31d0b162a5b4a789df590e4427d493689a362a0db6d213a98fd33164f322adbbcfd6da7386118956783a0afb5d212abf381d8a17c934416cd348648d00ad28587a485eb0b741b2869310f9a2e966427519a049ceb561c75f301e404eeb5c674a9429e91cccd8dbed20cff53f18a622bca5c0ea7a803d3040d07f7fa7539015ca687f815c5fba0fbefa39835aeabf944cbdc4d51df900ab338b662ef6a3e9cc75b54092d3fd9cdb67e0760c05b47baa4d24ebca95714589c6b1435194a37eb11c4fc272a80a3b3347be320aa74da6cd8b3764428b468b4e6b002ccb9a71ee1d8e781401834505b441725b63f8c3005615bb44d145c3e0e79675706ea7b4447101062105ebc20b4f816f1881b24eded340ee870f1994aab8ca5ae7c96e6daa24745bdb67ba1d72a44d2207b516a14fb7acc86622c59fcb67e7795850a4675a9bcc411af9654c16f0061521c71e63f73b0fc4ed583e5f4e5b53b8144ed73c2694713fc163e6c1ce1dcf82ca7b5d4cce7349a7717ac53e838333310d6a5e795427f909e2243c461f5061bc541bfb2d284f9bc03a6309c5ae7f6c8c361a614f688b979e56e2be4d541e841d6c27cf9fa3f22c2b5516112d31298e382d04ef2e9b49b1f25c3e22f3c66f8f9ca7f10ba0f5da9f7c980e8a99eca27d502c5372d28a74a98953bce31a9bd2c1cd2899ab384a6b597bde41f8e43895b6d0439dfb02d6e3d3807e45335effc232c15c4289f47482880ab29ee618a06d477233b49d21b3c4f4ab29a3937bc27743a33678b9506b9eda380f1e0689a830cac9ce4e60c3d8fcfe7ad79ecd9a2729a4b4e48586fd116f30cc8e34bd492fb85905a0ef9a75c2e0e01c33d3aa4e1c1f493adeb4f9f9078288efd55fed24d169c35b706895d241211b81c663c140379d688baf7d5bdb8041505d33bb3d9d2fb9847c2be289ac819439522063c6186b285633757496770ee653ec25f1bda806d1dc001854f6e4e964f9225bec792165a0ea5bf2a5d2edd5a10280be501380b13f8e8aad490de8550a6c9a19586e0fcfc742e9fa39d91a98a7636517d858e6592ad8684ee878869a5b78c8d5b9cb24abc137927685a5989a9ca377d641862a8767c4327bccf10442fde4bb0cd82e9d997c66b8403b704c2e8c7694ba3d5b2e7ea8c920e05ac056f9e51804dc69bdb100e99549632e1766177af490fe858942237eca32a50eb316b913950486ff3da6ee9f815e410e0dff090c087df7bbbf7bacdad7b0236e0cac615661343e6c5fc27a573170e13974af7b86627c6264371ad6ea8f45d7857e5abbff206cf639a9a47a83c4fbef514c15dfb1a2416ea7213c0005564d3d12b3d4327a5968fd130408b556b14f0edb56f2c873729cb428fd6fb58d625d3558c31a967ee9d05c066ba023672c03a44e3bf27ebbf966426bae2d25c844b7f180f67bf5e3afc459ea9cbf0f7cd4c3a26e1106e403bae4e4e708b85756fd983622314ae5ec03054146870fb9c9b6b173f1627e7ec7e68915145f106e9161f756d6c43ca9ad3b6d589043e7258b279175c76cd5c237662d2132135e78723153a987531bbbf946b2e2e3222e2b811ad1785d272aa282b9ad3309fab1592df891e0bf8776d61669b0cd1ad7036f8fb3ee541dcfcb359c6630fd77933ce2e66470603667c459104b00a9f0a819d0a3cbc2849668035837242e1f93940c2f216f8b08ab0c2c3014b946251faa0e422554277bfbb2f4f64c64ececc44227778107c35892f99ed3e359c0f2a957dfea51a1bf30582c1a3dd23631ade21b69b8f473c522754d7f7d19e9b0f978aee7a1eb18fe8309fe1922ff998dc654b555d7aef7eee211b64e16b7dae33ad256ebb9c4f86e3fd575a08e1dafe096140a80f26179cfebb2d2829fc89f7944dfbad1ecb71d5065f824ea9e8e9034e31b701ded8ad70ddcfd1c437d1f496c40f37fbbc73de492ccaec8a671248657ce72c21e93c1ff11dcd0a4b45d398e3bc0a725b80b8882d8e584a0ec1e43c0b4d3efcf068be2d91e0e921b1564260456ee528b788cb87355319af79b2a2be9d8dcc40fc672f621eae38252c9a60759894370ae7d721433e21b51486e310439553531fd50555bef7c29f121869d0940dd49d67a008d8e1193f5edb8e374597d11783941b0ae3bf0d2b20e8fd0fb9607d2b623121f1cbb1d0d188af6a7db7cc14e91db3c0d17b4a7a2a91642287d69cf846b8ab3b64b47bf9e28242e3643daca6919784eacb70ed356af29de6f5c8c61ceda4d3a37964c7def1517ee2b347d993512d03015477152f90d61f47cc4ea4dcf333e907b75c0fad9c075e1976f321b46d556b5d9457ac7c5ca09614330855c4d88aac58bd90e3d9df2a87b63f9975a709c4c92477a37fbe8cf154380fa021e26a5d7ac879f86276955dc5a12f3abfeb112f56abfee47d4adff415e393219a9cef8f19028c5f3da5cb8eff8c7a57820ddf6f634830e86684173f6bacb3ad4fc6376a29276b9a20aedee3c951b1c10dfbcf6619fc40074070c9033ad9ddb8125e9c3d5187d67bd9e5fe63eef038fc2875dfceefe375e7c3c3a881f0316b16cd049cc8dd078b1ff1ba35cc2c5992c575d6bf3f8361d682b2cea1fdc3809b3efcf30ddf6ba937892a515c86bee52741643d77974a93fdada3e021ec19e11073a0d39f80271c9716382a623e8abccc57f23600aa5dd287751cf19dcff8c46f110ba3a732d9233acaa200df8126c94506e3660c289d0235e7a0e9a09792eda993b608ee9d375abac856084899a4132556d49fac8962222d0f4cd99f8b547923504d5e0057121af79b06e2b2aba81ad394d6a1eaa005dfcca63a79a525f57dec209f4f73a472bc4b678957955c0d31e951dca2e22a33cedef9351f6de09e8530952accf39c2649c7a8ba9bdafa54d13e8b1e64c339097eef11234acd428c27a368f6cceb9300a2d473510b29af43e47e3a61b21ac6355cefc2576d48e3c42bed81d5dce8ce15d2631772ca7b4437f408c9871488f88f16972ce5b0efc1734fc82f1ad28fa69eb95ada891a406f7304d71defb9db019ca74f053da10d758fe564e9975bb7b815b4cfe72c1479e91f426a7bbcefd24d4e571c247010c6d79c54bf45baefb429ddb65647ed413869230305bb272c8f3b0f4490433bab0acb2d8b235eeb7aa3bc9dd4cbe7185d083ce5aea0db3f5496c2b86cd79cfe79b07d24c5011e503bc33bede1f42c89a6344fb1eaaceb6bd6c8b50cd6eb4f102303c16d83a26f3a8bf9f85cdae5769026e56659510f8e05c60493b890aa4f7eecdab0e59e63a5f95ab4db923af43b774c0d0b0be08339c881fac590baefcc3358757793abbb813c77d445d8619340730498ca1e0da25890d7d1a26039dcc14204bbdf4f389fad5d5879d6109b53432d2c4a16e86a8b7a635e2bcd02bf65a11f4fcc72bf235ea56b8961a25e3f7049ab960118c19254a33718df3870855c1ad9bccdbf8e3cb82efbf395d4949070fa8b8e15aca58d507fc2f3f38b7b2e7838c146e0abf41009335b792c6e297ecebc302069c74d45d59d27c5220740b83a8eaacd9fb9688e05f45931f1e385e312de4db73d0a3764807e9865c368cf6f176fc7137d5c6fa7c2c1b2537f4d8f9e00bb0a94690e71d766e3f4f4e164c052b92e026d8428c9d733d8ca121d05e6678903819bbf03eaa836ab496bf4b2824fb8e1c4521a6f01f3cc3dd37decc070b8860097fff569dde1d4cb97a09ed2f48ba325ed1cb4f282d9ec8a4da4ff3a4938b728f84c3fe705d3dd5aa3d4effd0d445cd240113d9a4ca66d15a8b82dc778ca16d2422b63e7a0d27897269a1333f8f87c95c6470419197074f073198e4ad7cb7a421699919918f4d1e5aee013f28363e0a147a036f87bb2a0258e44caf034e80e02f9ed8bea84525eebb4dad9b35fdea3681fe761f393aecfe598875bc1525640a10855151432aa8f9831613d2d811bbb84238241fbbe448f35bfb8e94e7bd2469aa7c8ca0fcc7c032c42261f19dae1104cea119bb49b57d8e9af9c47a9cd69423d3fe039718046887eac62cc93996a5530672b7c126800f79df22c401686d59808ca041544dc3aacc012ef4fcb655ab0b94a4fa7fe5978dd039f6a593af8eb0ab1f48141a7d91f43705bff845d3c19139eb5232dd97a322b9908304cbd7393067b6b0f96afbdba4f4bd84b1eaf9f65e89042d6c030ac010aa3d408c1a08da5309ea526ec292555d9cb692addb2d1fff685ed70fd1347de9974cb5fe21d244beb926caf8d5706753f7995aaea9b9d9a08f24de8a9140f808a0104f0fd4e5c1f745f7a2c30053c1f908eeb52b1502e0c7c40033ea744cd1194be90c4a3cc248ec3625bdf2857f6f0fbf65825af53fcbb53e3fa5efc698636a55810bfebc112ed0738df16879e4881080544ceabb1626b7b1e32ab0757d121c426fb3a3686eb44fed1cebb57aa80049607d7a84e54bff9876fefc9b7466ffbeb48f5781b15d805e4bb0745fc69ffd2528cb241fbedc84dc9f3b19c6da7ce58a8c947373e95bcd3a0b61829d561e232698fb178ecaafcaa6c0da2204105eb39120d00ea9621421bdc2d2be4902f75c6b2d177ce64ce872bf242afc815d2d228f673507d21475025fe8783a71946c6ef8aa970ab6313f88789aa50df7d95b88713e593b3d29c5987d53b4d444f9c03ae1d7f0ed246887973e50f081de43cc5fe09094b4f9d345e335d627fe3c7ba44cbf702a5813f94abb7165cf5af924ac0a1b582f72ff64f71240ae0b456d5d48c19384d51ffc1acca5a9b1dc3506c706a46c048b369a1af3200b75da1a6d67ac1bd740fe248214f71fa11264db03e551469d187baecb601f79ca9e0931ad924059e4f74865589c68c478a367dfa483c513ca555750dbe9a8f3ed51866a1c19e8dfa737cc5c069c8969486ed60f008fa1f7f325524d8d45fd8e38f3f55a1d0082b8d6775af93ca252287a4b2704bb8ae0eac1211428e502612ab73789c47716ed9ea8e0d96b1aeac7f7725fe7ac84b3b0c0d9a7fc69e11b78a84ba60cca54be6466829a2cdac3e0958487d68f09ff91765992f833426fe7dd57d7a46cdeee9e41e162b219bbc5647d1373956f9066ad54dd9fbb65894e78d50624e535801759b90e83679439a866bcc21cf4e5aa9d1a16996735c641e87bb0b276eaf971e38e06812cdaf25ee26eecddbbb2bd8bbbc462b35e5e114ea87024534cedaf1d1b580c6a30d36e3564902acaaf9d34a6760e8583102fc3ff82af63a68ae75576e17ab32abb7e24c14b11acaa7fd2e36ad5ec8cbed8f0b2c6966a0f4b848c94404e0696c4ac15a13cbe2b6b8c01c8d50336133002c287e489f40bf0254d772ec198f5bcec54ba3ecefce1dec169f5e670c8d783ea138337a659f6aaf1920824c1a85e9478b4acafb40c4a50f0b8b33ce61d8d4bbe1572d3c24d0f58e0a6726958db2b84038ca3b3e931b7df68189b908e7bc8c86492dbca425cf4eb074991e67afa4421e29e027686ec4c9f3a0a748c5d0d366107047b930333ba279f4291e3e42a3a5e593f78ef588dbd9c1f671b30f52651543fa46f7683291de68f1bfac3c871e0a10bfb81c76a5d8e7327c75366190bdfd1d10aea1127e36ae5eb764fbfcbf55d69f3714f730820b690e2641dbefe79c74e1019da7145ba390543f7f5476b939f03fe4a8d6148c07fb4ab7584ec60893f69adf7884f169db614fa59b972c3ca7882ebd42567d2a95023fad32bd3bec615f874d8511595f6d4eb3572137f3567d9df5cd912074c93b25a62a87db94e05bc4e45a2baec76f562533cddfc2035998b05b6137c6837ebae9104b58fde45e9c03bf5fd0f35bff5e191724d8ae7bee1b13377c8956b4d081ed68510be5e686ef3a240f770d684608a522525fb52e8dfbd6a77ca0183320fd46b5a02958d9c8323288248aa9a14a5827dfcf5fc6d6aaa0ff03986223c673d6a1084a3cc28efe0b71854c0d139e4fc91df2243ee01ca46c2d0bea3d1bc6253a054586457383de2276ebdfec39de953ceebd0b8b8a45831ba1e27eae5bf11609d4e4b9edf9a1ac7321f0680eb95f425841c8969ccdacfb53dbbe81eab7b95fe646eed40d1ce26372646ac36f64cf097feffd52c36aeffcfd7bc7932c2d26946911cb1e10d2aca0c23b042d7a657ae17d975be308c8334871aa0e35925ce5460938953059d814a2ab44b04aa184057530b89cb4a536c519d6320983025bcdd6bd1e0cb24caccfd2fa68a7df4bceed46bc068893de215a20e3245ebd2b74190b33d5a67bf66635849c056994681da4159104f4068c117674a87fba1ec9679176117c5c89b4cd47b82bd2939523524b52b4182777747fac30f453a3d8217f703ee10b81965d09e3a2eb205fd981befbb59acf6465fffa66e13a3645f90aac7f833e8142383de828e7a1954411b72f31021fb494f3b6fd275493ac36855ca3b8531a5b6768b4338521ee32cfaacde79b4cdf6f4e58e31875eb0987c00094acbf392b3696a81cec1a730eb760e5d2429c9218deb0117dce6754296298adad6a5547ef1b46fb9927d4322016ca37649f800d3b4f80ef224c8c300a85897d1ecf7a01768b5265aeca31869f711c8f09d58982f8f66d9f04b99b0a051b5538b50f95554adb5c843aec56d903d8973413d79e4904dfb5dddf7b15c79047af64aa7fb22fe8ed900f298a425d0f6213e6ec3cc570ffcd338fd51dca199e96001d93b80c9b4074107ea2507c1f4c5bcf1c24befb703700090787d9828ad9464bee1f4075799c3b1d9315ac92025d789f7355c5a002551a7693df1021c938e46b95a98c71840018eb5358497c3f2a5c0c44858ea0f7f56d18e64783fc1a81baf68b0185336022169d7fbf9ef00daf136567217ac61858276785b14d5799879d9e3f894c3cc9036251c2fcceba1eae13df236c4b704b1dc77e6e041de8ff9b35e43a0162733a5889f41326250da032ce55f2ec21394098f0a63e5972c65390cecd5fac9c29bd1d2997b6d68a198406a5a6d5153c41cf4bdb325c698633b21ad4b424b1997b45216f007ccd9168838a4480c1ed3efb695c61858f20ba453a77a10d6e52158bf6d9680840978076379889657a5beef06b93db406f4fb9491ed87263cd5d751375d7565ff8a3a87c5c52c542e5af8e2171b20e5e2f0464370d3eccb927e6e08c06575b2db3c72d8aa33d7b2cad5075676ccc42dfc0676650fe237c40a80e93064a7620d7fc9060ef9103552facde337bb3455aabaa99886c24f0b9f51af7a37c19049df0b2018be64d476e1bf77bb60e9bc991373906173569e2723afe05f4d2136c9c1e40af00928d641d3ddb0fa24cd7ea6ee13429c04e2f43c376ce1f81609880bd5197829b8c45230d044da71b1f1b7b0e768f0cb06306f81a4c4fa6a3d3f030a669786dbfa0c0751eecf0c71ab3c18f0ef325555e5ee2401c2c286461d68167f61b77edea2b1a9a280a0b30c8e6844a00bfb5af6053ee04d589fdacbad90a00a66b7df47bb91b9d7d6a69213f79b953f21bdab0c39ffea1376a5fe4cd060389d7ae202389ef9a0596aea6d2976825d4b06c2b4b40c78040bb7f0fdb2e88e2c2582c8358c003863fc1d92dc40fef725de48113ca919906f396d27a64e127bee4e261780d6df2f8a090bcdd503a500a7c717e5b0915f55f6191facf8dc0b5f266e732b732b0d5b51229f4813f3113f383bec73ec19827754af7bec4ead1f4f65ebab034df4a3216f0aaa11085e8fc0441bcfe759d17fe5f3e21581a58df4e8b50df866e989e18479819c67f942f6eebf5971427d628d0eeba76b8e6bc3ca7009d5a2c937ab49e6e1a601d52d5e06b0e6eb503581b06136f5e7671af420ec7dd3b4d8961df6c8e006b4d108f0e49e6ab88c8d1e1097e8e2163852f22cae67b800565e0f5a5fe1e5cc62742303e0d7494ec7b5de8995372926ee14eaf45f6cf445c3ab9b613ce91c4571c2026df43a0ee6446b8c4021a3be94a9cbd2b51665181a5b908083627640de8d29f2d3b14a98686d9a68e79c8e7789a23ca2d262969c0a12aadf981c06d09d4355d023df9835f06bc6e8e1674ec1cf4e44c5eee968b7a9ea5664b20001c65076f1de9d78a8d2fdfcfbcc67f79059e041b08fc85f76767044af47e735f8c75e73773049c9c914b8db3f2b26f173a082b6a2d3b5b0314cbd55b5cb59f3d5677bd5fc9657aa4306599b96a9d4c68dc0ab841ee475c9000b81d30279a8d9458b4d70fee9164985dcc377d412265ae94b7756917b2aac8cbcb0f4a26c848b8862c15a0754e0438436ff658903c5f137b2e7d19e0206e97ea70f143ed884f9135561065628b2b5dbaf0ea83cb647816c6d41aceb964ae6cc12a9b12a49b051b0306912c4a2736fa19125cb72e871a0619f750a5c9c893d8e671656587116fac1005632cc41e4176fbfe01dfd2778e9a9be47c004761096b2b04f0f283aebcf3aa3309f3bac032acc2f4144f399480988725d26a20918ba5f6e907cc14b3aa4ec02c6c893b58e184603eaa1759e9e3ab17d8690e55b7261088ca4d0db479dc7f5ed50f7e7c79cced3cdf4620c1c4f9e8b1588b1ca4eaec42a5ce6fc46333433b1fdb60721ad4e4e410b5fba51546455959a8cea7937d4657a4ef05b4b358530a2b5ed20e24dc668a09f0d824beadcf5bd1d9690abbaef1c223134f920b7bd9b0f490e1cc199315a92d673b1a2ec94475b304351e18d71d1883bf9b1a04b850e3ca0c52f8d80badbb4862692894620c5b7d4e0917c536a87d4b83ffb62e82bee04bfc6d283604de0dedc0de33f3bc5dee3fcb48d10b34a72078ef262d873325e157bb44baa7ad02a5a183a4c74a77f6aec27b42b44f1887cd54a98ba38946862fd8e72379a408dd8c7744dfcbd38c04f7a6f7eeb1d12b0a07613908548f1bdff6fbc36b47250d1a5818986c4c5335a5d2937fbe401a661b3550e652eee5049d8623eeefd35fb64b0ab2987ea0d055dc43ccae1bf43f25dfb799372ad755743d9977b9435d159adc327cebd6be707300ca67c8650db23bd375becf4328e1f3047b6fae9ef5603e265bed5315670c9ad557b8ecd227dadaea41cc14115a4d50f743490086b1051a19696087b06e167198e92a7995546b9c311703a7c3f0ef4c45f8e78209406fab4221b2fafacaf202e22245dd321a446e74089ecfa5a5f07b5bdd0157358b524145a1ab7a745d728ac1f6b14bb753a8c2c10c7502544cbca3c26ecb6ade1080c979a3df2f4aead2771aefe624f030ce697602b77c5865d4fe14ea53ddd4dbdac8e93ce5d4da8da9d50772e038f3a9e114ce6666b019e1df83813403d9d6d27262653d994a68d96de8425e78cd020ea76311ac8c8c1afc24a581758d3215891f5a581dbc491b739172ee3b4fb99d4cbaa9780f518fee650b70fc158d048f3bbd9c1da8b466accd87c34397be6a942039a74b592cac3dab03b8e3c19e85996f10bb0316feb4907a98a4c7b2907695d92f3c2a3720c4d0d2f321c2e0dfecf65c3a096ebc78e8dc24642c8b0fbf6f5f64c7652ef914f360fb2f175516c7304e4c11d59f0b70848e61c1204669ba9bd3db1e899d9adde0e9126d00c73f8d392d2a8af271edda1d3902c256a4fcad629c0f284e1d82456588e80c6bff92ca15256a61f72d95f3dfe573962c14ad136b8c0e53f1e41fe489447db4331502072ce7d183afebe9a39641d5ff7f9b4069d5404ea59fb64cf4393d9d8f680926707c85470eb8f40dea505ba9ec392df1138bca0febd0cf5466bb637086e09ddd112b2cff7d6c537c39a272161c5dac0dc637e245e72921eeb32cba1764c1fca17351dcd04b2c7b17bb903f56ce9ebb85dd8daee06bd5f8a0d5fb86399ab9512190a283ffb9062690725ac23fc5a888e221a59f5ac1c4ffe67daa304977232ff3980af98c43039b85e8d5d7a5a5b0b9a7dd949a0ae5c3a6ebc39d9b89677f5360b41c76905106aed3168fc94d298068f0565fb56acb6a86264a059a90a845557fe2a60dbc09d0d0b92143bc297eb8c93a460edbe5e277246d4063635c7055e232cd535a6a7f4a0dc7ca8a97708f62c67311483d831250bd96321a86984101adc2d9c6d5f3df862cdac4237be2f8a0e6c7babf81e50ecc8df6418eb420e800caf4c138428766811caae34274810139342107974393c00b026fe2b7ef88f728ff304a07b0fe9a1463f1536d7f3446c85f68ad8cdc5f8df60dae2b22d01ace1c1976254135efa12123b8f628485042fd8c9b1108e87ccb6f040343940feff5e79e9a8277aaebbebc414539c11795ceb8feefbe8dd05321b3b6b56225566bc2f2d6fe138511932b84d12740fe740d110839b4a31b67d5a150ad02e7e6143b2075b166b176ba46c30bd0387fe1c9aa8690a5d738c1359e7a6cbe9f29e6ea7fe98061301cd7ab0db2cca1e85747fd6db4df00ef3febff14d14f20022375d861b6350b7ecf2089ca84337c250830b1f002d79ddea1e312983f8af807e4a7124b945518815e60aba188492a166221641e81bb2389156b95978366b70d4aa987b80c463d2679c6dd750435007fe75fa0531ae410bc4649ae4ff3591e4acc9304ee96a83cfd0818b608a5f2631b1a758dda57ca2225853f97041a4bf085be10e8bc6d7e3d768c41cbaf3d45073cb4c9dd33130b92c4d3570db40b5b44d6e11caaa2eb3e1b1c218ea278cd7e634a4b6227dc7c8856ae2c575260db21002386ee6b2042c92f7d39858a5590e7ddc1fca0a70ba8c655c318494128ad7ae48fa4f1957e819a2ab16d942611831746f01530d7459a73396aa7c3f38936dd5a41cdaff0a1c5f113aed6fd8f1ab4c0504d72c430ce45b656fd1beda1807d436bfffa58a9868d77c458971d492de9d7a32fd57d4c5a76ceff38fbb9829bce158af4cfd1dfcae97fc9794cfc83387a5a1d71f74dfedd65ba241a8cecac56af4a029bfe7342627440148c0c5e780cf55573ecc74eabaea3ab1cddd198764057638d6654531c3c386f7b2bf27f1c13a4a92881610e4df0baa27af40afb3718d0fe8a26343876e4ce36b5c22e5cf862b82bf5c2cbd85aa4d46ab173af4a16b71b54068c6e6bc873401e96ed61d5f37b3b927ab91bbfaa355b40a525db13d9052a65986fa895b335ed4d5d18c7f2379fee74afd9b0a3dab222c7aedc26caa105da1b4d42a5e1b5bb62eef4ef642471a742824b535c968ca54fdd62ded8c55975d74062e3e50e03f8186b1919213385df3fe91394abac299e0fc47e7c1d7d1d88ba63372218e1fadc29eb2b5ca680a02986f091dbfddf812c9aee5b1165002e66493f973a6764de73979a2ce48c41d9194c850c49cbb26e45614d7f87aabcf14207f9e59da2ed2273d4d22e415d8531a03d7852cb02d3b8c1e5c745f6b317167536d350997c40d25da2fe10e71273878983112ddb67d7fbc16f7cc044f33f08ae9a66ac9282199b3b973ea4fd42050507be6753bd5edfeab5a77b0d250cfb7e5c50692b4c4f9dc40a86f3fe3528ab5fccc3e4224d804e14aef13dffaf6cd39f6c815a8983463738ddaffe5a2fd25e36568fab6b7de468295481f93cded932807a7f5db26711853ffaf757f2dbac4aa479b039d6a449051f61ea3079504c19e14bbb6ef5263fbd7ae68e07f487f2d1efe6a5239761888943c3f5a45eee14398158567296ba5c07a7970a4406451396873be87941da8372912fa591999ad5847332dcebf75919c311e573c5d992ff0cebe1276a1cf4935f50d6d08e51c8ad2baa343a5bbc6029ba63f068a0baed95e1579f8d39427ff53e28a9aed23548fe3c1cf3533650bd149e55e944bed1281b774ba14b5391ab06f5f3b5b5fac4f0275f30936298c2ce2755515ce36c8900fffcc0f0fe7cc9c2f4f8d22dcb28769e2abe43664738aca01c4554652a067406d94c2a94929ec174fab714dd9a4d54392776469a7a8ddcec9ee85796502ae44ad4aa5e61f47496a52fff8c4d4c615f45362b848587aad916b62a0ffc5b5a654c2bc89008261e359070679b09ff20a13c4f968d7d64d3ca915b53396110ea7a2a4f3587c7f5fa7f1b82dd9f01cb6aa065ae4dc5359e90e939a667e97dd32d908eca2ffa61e5be39290c43829fab8a6ba3fd449798b18914158d825695e4aff7bee649deec806d0362f17690e91a5e8a73de7c2991d03e200c30c681d5c495dd26a4a1c9c68e491b1f9ff49868a660e976e5b1ccff9b08b7177b270e30f1497a2dea33bfdb90b07f0d32a3712994c08bf606280ac13f8dca541531747996a46293852f1bb4a2fd0fda6c6195df06d751b8de6d25e6d1fb2c72c3c3c760138f3c2de8cbbc0ecf23867cdd0d3e4bb68df89a6bd0d14db8d1035d324aefcfbfad1471e135a30e3988bfb65a23f9133ac07b153f56c20cc0d19cd320df30e1c6428e12ff5d7322be3ce63d3a835ebb2d6a6cca47cdce0180c18175ba0b88d2ac92dc028410f27ff2ddfef9097a4fb09c5762547e11e6ba524b76553e7751311702027297841997ed097ac040b0d7b40c2127ff1d36b35c2182e0b0a929c62162875044c76847c88b0750c39a25907817415ed37f0a844d30226d165ea29ad508776e9ef61b8cd75585ba941deb406b3088550bc52548aa8a60986748189268c95d1cca7e1935a539a0c41bf0db800b3029a6e485c36db0b3f31c9e9164b3c8c59e25d20ff4eb688c8f54a26859e72c966c77d2e7bac334e3b59c9cfd776e819ba716cd8bece3b2a3149f92a201b734df9298fe1004ef9afab7393265e008b1ee3cdac43c8526be40fab4722b9c6a6ccacf612949772a051d95f68771197cfa8738f99f3f6f5a06e91ec7a2105b43059f7b1e7ff3124ffe446b97e2f8c49899fdd98e626ce58e0fd90acabc0c17e9a40855ff0d932389171ec85e0fc52d80fb199c2faa96fe389941a5310b4acd3a32d726f3363d8d7db9f53f5d548d234284deec5c696a8e3b2dc0f2c6971d8e258e08ea412a0a26ed231f538d40d5d694c4497dec6130a8947b7ca6f1b0d3e5eab638854132809686f775d08fe999560ba526f643f7587c07df40ecdbd5147464effe3363c1d581b73f4d9740690b0f549216b632c4fbe94d61e34ca15a2f23d2f42e76ebf0210004a5ae5c2033642c9353165d389256b4f3939e46f0458362c683d7481c621b6a4970ff9519811e3589ecbef9f125a3ba1f90ee8fdf79863462e532933c2bb467fdbd458a86245cdf7b3aeb3d178321e76bf0af722963f15e2d7ddd218c18fc1b0fae87b7b041891ca6fb63ec52eae6477bec231f34a982a68b85fdfb366f4d7fee704fa5fdcd9d1002b063af93b2e972fe6a301f4ff9e776e6fd1af8f8c383e6374674451772301a6e77ae64e0b5c1597880df1c906c881c2875dc7f539d791694e05a77def0c6296768d7ab78b5fe85de3b8de1a68a6ec908b0759342c3529274ddeb5bc09992febc8a35eec1358019224e73ddd7a0a2c874c4ab2b19c30a7415a9618e5563312fb0c9a55c5bf46d43203351d6c7bd021e4866a71851720c5fe07e0a7266c1e54a7e33db3ed48b53211f3c27d8784f05242dcecdede75e2acf47a2c43983bc8dd17ec4541b6be75bfe20273942dc32421c918f26eb3783d4399dc5564c42b7afe88a34ded759fdd44f8196fd7b1370992cd60cbd4391690d6ea87750cbb0bd31b9877dfde20fcb9c6cf2f651325fc003adef590b9d585422e3eaf136f4fde36940df3d494bda1e999a19206ed28e387f35f8475166ac564fe3313356fba100ed2af8c48a80f6842586faa522dac23a6cf194ff5eb271b090347a85d8a30d7eb2eab06d21ca95c69716fd4c237a868e8313947187546b666fe11dd19f58d8a8eb59171b67636a099fe9bff5ccfcade7c126973ee66b8b948279d9ba20dfe4b45988adce4736b7ed9cc1664e6f55da5824477eae36e2e98aeee915dd538688c2224c02fe6e6ed3c5ead1202d61db38ea725471d01c9c7172b2d590e2b22d554d006a60ad238a8b9550b47c6db6e146e167f925db3f3fb86d35356ea611adb65e6257c8f17a16232cf5edec4427816258f435c5b4d31cd9acf7c5004a1b90ea1f498f86edf7d1fdf8c3e5238eedf1b5052e298f40488f0451e5e619beeba86e92865cbb2b353ec381134f02540cbc2044c4656b78101fc28a55a89ce68530faa875f908210ae3983024830dc5c711c50872ba2a5e1ba474f3c279c8caa8db470cc87f2d9da2d7a0755f7c4a8023b2e9ddbb5998cfde66d103fc374b853d655e9f61ed79501c93ca7ba6213ee5a3a548ad4763e0cd76e7ad04fe95b86e05bbd9548bdc3bdb030dcd2747216d68f0f15b6000cd84f43bb1079d536faf0e306046ddfe1559b053181d5e412643ff164873395f0e95357a824b31994b0badaeaf5b07fad5a60dda1690b399961032b166a90501de0002001922cba8d26d6f1b7520ab9522c05202f9718620307a92e07c255c85ea842231813ee67e8c240ae7dd202a8e7ec93875385bc7dd8be1e138f5104224e48694b941cb74c41b1c3c2c88a0047fe1730ae75bec0e34cbedabf22a21486f8a7a3ad395ad96ab2350993ab88c3aad9331c37cdf2e5168d0271fd0ac2c37ffc1d52c0e4a4153ce9a0d1f5dae01bb9797d1c730932af5e241afa6559521d1c12948d327929c46d3854231bf1554f1ee8a329046c7928784079b9b9d88b95d2cf77dd4d2cb367f5f127d130c88c1178ede2f059086fb097682534b66b8b3ba8f221a682a81be11258f8053da3689e0851796a68011dd64f44b40ad8886b85a6e3fb8c58438c10443d1392916c2bf1d987041c6c6b97688e0264e2a5258a92743377589ae146d78798e213d0e785e44a2be9ee1494f183578ae2550f8aaff2a06ab45e8da9f373207d5a72d56483da6a0b04e3e8308bfca42d912d9ad66d239cc0ba9562027f4a24a77d5fdc242da6fd741b01466be1954f51850391312ad20ff33059108b6c63d3f9a4180374a74becfcd392ebcc8f252f56416ff5ef33207d123f7d4419f55664cc0ab8be04cf893b1bd343e2eb2c2098ead1b24dfb6604ad5daaeadcef3245ec1e00c9576c77244f318b58aeb8517ce0048ac8aecf0d2873a393e93ec7bc74c3069077d5dbfbf28601cfd1be3c0e04fcda5a76a9e2688708ae5af778d9d1cc084df0645f122a9b388204aa403c30263f2a30fe023e119060d6d7423fdcf54b946edd463e13fd10acda45927a11572f1e3df0bd9ca77c6578bebb99d69abe45dfb545138465ddd2d163cbadb8c047b073de168cabb28e7f72cf9002a31d65be0a946469f8053a64b3881864754251581142ccc6d5f3c86e313b03354373f17452e4eea5590d14cd9de1fbfb461455ac77c0b9e4be33432cab50ebfa07b117b20f3ce6664944ab0323230fd80bd0ca879a9c3b11bea06149eb7ebd2f0cac2664f5ae3edff482e8321bd901adb42ae31dae505ec99a165ee27548959bcf15eeb9c4183e718d9a6bebe3e096d836c7975c6580e623a481ce330f5ce9911d32364b303c6fa753b18ec49a8fc7f3299fc5731c0528b358acbfd77115468e644cc1b5fbc31bb3f41a1bd4f842ee660e2f1dce4bc7bcfec17ed8f9822889022cbe150c60753c05504683bd7d0183201d208133557aa870146824aae65fd27af0e8f5d06bc6e115c653754d39af413de390c31c022196f37604d37af6ebe4a3aecf8bbdad8a1f2cc7193adab24f97977bac8539259d2f3ec6688995f99168719d6c92d93f1b863f58df14b34f158b7d3140006e7800a6a16d5c4fcda2fb0956dbc2254dda55bce43cdc5ef38a778d361a750418bf60e79e4eccc10b553acdbf60000424d3663e7dd9fbb89babb0612eb0014ce0366be565fb0991a73e28fcefdf4018e31615ea526b22955f3ad93a5412882143cac4ca826b0dd131117447d699a0a6f81be04aaa5021994161d6e4e365b322fc2339ddf4a5e45e56aeea9fe50b8f3fa27f766279587bd007511214bd3bcf3f0ed1dabaa9e8c461067cdce579fcf39cecfae10fb331c949141beda4457828eac01c5601fa277190ed83be72620714a39a24ada25000e42cb12cd99849204a452287b549d30870d14be9984f447ad2dd139b394a4180c3af562950b8ba413016455ce04da2543b1f5f2a0c01c6d2b095b01accea9609fd8dc5620d4e228b2fa3534368d7e7b47981e63090a89072f8cd07cde415df82ec6795e69270f9e291717ac98b94a799b3a4e1b125d666cb4913d440400449dc4b82551fe61d0970cd5443e976e721e1f5794ac043cc77e69204a6a3b3eb8244c91164b0a73bae9335adcf13dd43dfe76f34514952f55c0382cc9c341e3997441e4950b47be6297c4d6d1421dfd347a56a7418cb50453ec1e6d00081938befb4a595ac3d10ab72eba7fc960dd18f84edefaf52f0c501ad2b061b9e3eb18523a6debb5283049c4a88428bbc7f2c80f9042f2ff09994ccf468a57ed7e2732a7e83a9d13ce53c217169151f9252cf0582d0ee1dbd10fd7dbd269bd4c7fa7f29dd813d13a856d2e51e17fb9ca4777851ec36ba236b76d686e6823f4ee9047af42651b6cc314602a00bd66f319e55f0da81803055443fce3fb1630c4f3be3feb2884fc113a7a9b872ad1b2ccc6e5d9c0350646be8964f8ae49e2fbb41b954eb5c09454ebdd64de764728dea6b542dc1509089e9dd96eca00ae4d194354e8dae4ccd01cf757e7c788ebe09dc037b5be3fbea6e7e37138e73760d374f93df33da70914552061de9d52b7a7a34e50a592f48395f86ee046e5093115cc8301e5630be58903dc108be89641b6ac1b5478058646dd813b93a0420d9ebef25f3f5950c6ca8fc357cb0ceac034cb17f8231f73d85c34df5f645126ffa2d7a9b99d09e7cb6e65cfa19461b276092e2d6a7a6ead5bdef9d42fc4f827a4d340b00886b2c8ab29dff04d162e0e0c60eb7fda82ddcb466ee71f6c42a43c6848e43bf0bb65defd8c2d19c11e9a2b9bcaf3ec583630c642438cfc1b0dfe9dd73393677a8b519ad3c9cd78fe9a057457fe03e42ad7b947056c84f3756a2fb4eeac5c38b7ddc26cda7f2a7d03a2bf6425f6c46f837423600be4b3b6151c9c318f84c581bf1d6bfbed3654b0296670b38467c99084a2b30ea9f2e53d24355546bc56ed6f0065b4be1a3f1430954789fa02da9d1aad7b35381e11b88836244e93a96b680e82fbac65bcf1c88f378a0d58b1f8be13f7ee291b5faad2ac2685555cb65789767fa21c093b06184da01f4f8b406c96702dba2833d99ddfa032de24bcde7f489cf7a760ccdc6e4e9b07c9c5b121206df415522ec7af11891af776ac6eac65fc8ba61580f2150824fdc70bde9d3b6c1e78a53416f17aa75fb4884748d50c63fec34f230a149de561c5fd93ecbe1d898345b61bd543d4f6219c8150c4c4664d849b2b744c127c04bf542c2e972eb4023df1e21581ce39fde10d879b5f68f320778804153fff74741010e2afdc25b3cada4706fe9debf68c8222d2c76585986e3383ec8597165805e21ab5d5cabcbd1623da65cef29d82932f3ca7d6cbfd4567f4fddb78644a7924b0e1643958e819e095dc05d36f2b2e4473a6f24c047a51d58b389929a3d46aad8f5e15cbdc3fb180ccbeff0b95a4d010e3597e6a07f6c2038a498e77034aac259312c27bc7025e8e3132843500e353e90cf8a445d6958b0eef8177a29dd55299cddf8aab7bda9adc0bd17225d9e3fae38257b5c01aafdaa240df79ccd7150a666c8db7289cbc4c6b99407603e49ba230a6ae56f8a8e3f5329f6e7d9671ce0c927127366c172c8444fbb1a062f7e578286f529b523ec10e7b7f451fcb2a5f6e8744e883bb5899dfa258e57928174c56d054d9de3cc387dc885a750ba24d56061d6251dc78c58a8c3008792f7295180b09ca443bdcc214f168fcdfa8d81dcb7eda495ad9140744495b50d0d7a2744041398afdf8708f596166eab4515aaf524d6bade391d21945442095a2eaef7b094afcb986c60757a6aa3a3489320c669b0addce607bace339042ba88d84540f0d94463bfdf242d4b2199e246007ac4d88482b03fef2ae837afd44018cd078252d81a40442ac8959e84224f1aac47f0168e4205044bdbd0e697cc03452646b00f97a200fa759880579b6e263a3363a63568c0e48371ddfbd3d95b4adc7a46a45c8fab14e9b1069b5e6d48f527c5a070e99f0cf34c00801a786c773068414dee1e77f667a632ce03364b132554810203bdbbeede938144d93edb02ec8f8ee8fefa804ce1e91f8009164f871aeeb7307426ba0eb4867b238d4907c42e10b2f11fc7383be5e59a319083c9d599a4f92a47cb90a7b146af9766492f4f68ed18590576fa6ce36f94ca2a7c5019bbd32cb2a4310e469b5bdb5c22624d27fa675c8e8c7f0bcbf0f1aed53d00123a8f68dc15c96d43cd2bf779bfa53e9a7cda7b9b8ab1194dc02c9f99b2c5a456b55f8338b9d27561e9fee06f4bf8accd24075112ffc89a992a4ef2ddabe623551c13e2181388908dd0ff3b7ae59a2b2def5c8f11e3218d617d79583f0790917b6580065529d9c98d282ccd9b6342108e21434bc9319e05e395e94bebdfb4198c0e4716dde2414fa44d618f93dd60a25330ad23b923a5c1cfe153ec9722fb66d250415422c0c22c1aac4ab9f4e57919f885492777a50237fbf539eeb07ce79cbbb97f075a85bc67fea10a5a70300c17c9688b843f6d338d3aae739a328e29fbd783db79eec209e7bfd6dec133bb95b693b2477747839459f790a311e71c52bb367ce24deb9f87411358bf79d5a639cc5eec654284cf1b4d1bdc14eeb94b2997888ed0fc87ba4b5998842ec65800cfd84619acf16bfe7db956acb6e3793e63c9cf2e8c87fa999590c042322f9d2cc355956de69b9781e30ae9b00615e2696a6470cba4a76b93598dcc763e2a0c714bc496ddf815537d4448495622c92039dd0bcf1d00d93cc207a300a03cce802ce0eeda16f131386d48e313b9ca8cd5c1ff63232eb55e9db46ed8c0f83d4c6c7a83b9b220c962b3f651a94ffcc7c71feaf4ebc9b8b658dd41e4214b1a1171beefa5aa21e2ec849d7ec1f3d27c6ff6e5ad44802891e3a65335cf18589dddadf19b36b6cac168877c03b8006fa3606c91b8ea2dee33952d558faafc6e69e4506519cb1b08a9a2e794ec77f3d76f463546849aa969b186a1e6b9f3ffd09219309d4a9627b79effc67abc690151202ac102b158aa84fb52e732f92d67c819c80c440d35b4fa262c7b410e7e2634ac40cd3cf4c4a789cf91a7955c99471af59d7fd4e43a3077bf6bfe5ee4b9f4bebbc2d498593a2418417be428232a3881026afa27d6191e733b4951532ca67022dc176f3ecc0a880f45fe974e84d7370cf1654265ec2d72024112e73896e0ac22c47d8d0584f37dd6e18c0073592b7514bdf83d0835b36d075e760b2467d3eabc2f57e0bf8975366fde08cf6b8cdb4457d547428627d83d4af9fdf62df350e78ecd8d771e3b751ac2b6afd8ceb15fb89a18cb08e3ba479cd0ea7a546bd69f42df59055df3ae1ef51f1bfc6fab8110cf41df955e0da0312f924f949d745cf42dfb6b5d196f138bc853f9fef04f5a09ecd6e73fbfdefc7ee0d134c09659537643d0b7e30822bc6e20beb0382c73eed5b11848d4aa7511da723a8f1f13b25d7b2e6363870761412e40d5bae34cc3d47301b6c5a4e3a58cd2c2f77ded9579c3f6e769d799fb4ed904c88e20c96e5378a0d67914042deff052b083f97fb52900f8cbdbe8017895ccf587936b8931a887d8eaa74be50584b5d96f3361ce1a6ff83493f23d3c326b1330104d010103fcb034df49fa8e60eca65e907df3d9a0f05cc8dd56df9bf201b59913aa4ef5ffb01a95f0ca9d1e5e25ee9a68359122a74253794c50f6d13db3b5e6d3fd60e0d8785477a1995d3842d14163392f1ca5df90bf06ebd9100529cb672abf950c63cca3db5ba22372c4d34cd432841711d0e3bf3b977422768873751c2327494140bbed0a6d49075f0ac67e45e59300e3300cea6b482961c5917dee69720836001e65262e08391a7bf5a3b190c8f80c14887b92dca34fc037938b59e6b1912e01055af01f624575173bc79f079bc337efb5af7ffacf12ad044ea933ef07acf97cd8d469a6a2c2624f9e8d0aad8642ab67eb965dd481090a9116c42e3b1ae54dceac347ed400d05aa4dd13169600347a8275448a0a1e5966093f585f09bfb0ecf7cdc0b8a6f26a17ff54d7e8d659ef936ac0d0c91354d08101c4bb53f97ebd822760fc98a0aef9ab23da4af312ce9d87d461b9e31bfdd0501ffc44a850c8692bae0b377094e5507f88f3dee42b2a8548b21a9860f087b1c6eea9eadd526d2d2920233526b8e2d9c55f86019b6a2e2eb316c5f5ef65db4ba2bf0fa5751740b49971083970553382678598698acc884d2d645a7a09771bcf7a10a2984394f1d527fbf8aa6ab2cbeee9c7b7e9278f7854ae5ed3ca0aff5aae67f36b2f265043387c873b0ff872168a9b686545d5bbbb205c7d288bf65885415711df076022720f6148f1caed1a160c49adf773f03364c10f2cb881bc31eb502035bf7791ed3f0d00c21cd1a8cc355ca445c77dba995656f6771b7e07ffcb12cdfa43d1e0b7472da9e9744bc39c80dcba96d923420b400e0cbb9c16020c8e457e19fda253286058276fa4cb08f1ee65e363c113f021ed28eb5f7694b1ffa33626f0f361224294bd36aaac452dd7e83ec79a94fcfe9432650761c0772b7b5115502cbe4491819f1efd3c32f345f1b9c78096be5ef6e75838300061f5fac88ac227ebac753f502f55b026a2883d15c6503aedca50fd330183fe3ca9e5cf84ac7794fa36a4386727a84fefc085e228b6ddb9d5c73531562f56a85aa2867bef151c9548873f10c2a76f1d0e21684e518a234fe63720c797019d7d36c6f8c2cfaa14c2ff9b3d54040cf5f2806b6c8426346799224d5d3cf6793de61f8f981fd5c1b0db148996364d84b515ea75653ebca05203cf24d2301e03aa7beca7ff649eae6947a1e60f1cea6fdb4c6ba2d96ab68c0c5870fbac7c25395de6f8879bb9d67f501e8d5c0efcd5629c022344d4011edbce40e4bcee366d24ad5b4948578098d64a2308ca36a6091b2c16f5d421b71fa4e2c0b7792d6f4d5f37d3aa366b4bc360c611430670f1ed1c226fa52ec4cb83d86f4d20d5739d7e017dee4e8dff590cf0b28177022b7de8c8adfce8a82ee18f5695cdf585ad046219aedc4c6726d70acba223c8d9ee32b4a507f1acf78e82afa171373d38c33f41719f8d694578ab89ff848460b0d6639518d83849c8ac8832fc79666f8f1756f05d6493bd7c556323873e99</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空_无 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【拖更】———炸蛋纽er &amp; 计组小科普</title>
      <link href="/posts/33655/"/>
      <url>/posts/33655/</url>
      
        <content type="html"><![CDATA[<p><del>新坑+1</del><br><strong>关注 <a href="https://space.bilibili.com/39521068">炸蛋纽er</a>谢谢喵~</strong><br><strong>关注 <a href="https://space.bilibili.com/39521068">炸蛋纽er</a>谢谢喵~</strong><br><strong>关注 <a href="https://space.bilibili.com/39521068">炸蛋纽er</a>谢谢喵~</strong></p><p>相关链接：</p><ul><li><p>视频&amp;仓库：<a href="https://github.com/ZDaneel/MyManimCode">ZDaneel&#x2F;MyManimCode: 存放个人制作manim相关视频的代码</a></p></li><li><p>up的blog：<a href="https://zdaneel.github.io/">leenadz</a></p></li><li><p><a href="https://www.bilibili.com/video/av492622096/?p=1">理解计算机物理内存，从位、字节到字，以及寻址的双重视角</a></p></li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">主要介绍了物理内存的基础模型，内存地址的计算方法，位、字节和字的概念，寻址的两个不同视角。</span><br><span class="line"></span><br><span class="line">从0开始学manim到完成共花费了50h，剪辑和ai配音共花费10h。本来计划的是cache的知识，但一开始的内存部分越讲越多，就成了单独的介绍物理内存，算是比较基础的科普。</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.bilibili.com/video/av493658546/">理解计算机Cache：从块到缓存结构，以及逐步推出映射策略</a></li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">主要介绍了Cache的基础知识，包括块的概念、与内存的映射策略和缓存结构。</span><br><span class="line"></span><br><span class="line">代码实现花费20h，配音剪辑花费15h。</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://github.com/3b1b/manim">动画使用ManimGL v1.6.1</a><br><a href="https://github.com/ZDaneel/MyManimCode">源代码地址</a></p></li><li><p><a href="https://space.bilibili.com/5859321">配音使用AI星瞳在线语音合成（Bert-Vits2）<br>作者：Xz乔希</a></p></li><li><p><a href="https://space.bilibili.com/401315430">声音归属：星瞳_Official</a></p></li><li><p>参考：</p><ul><li><a href="https://docs.manim.org.cn/index.html">ManimGL 教程文档</a></li><li><a href="https://www.youtube.com/watch?v=V_QS1HzJ8Bc">Direct Memory Mapping</a></li></ul></li></ul><hr><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>前两天中午买完放回宿舍打开平板就看见：<br><img src="https://picdl.sunbangyan.cn/2023/11/26/2f2f5dc2ed09bc48b7ae482c40d3a19c.jpeg" alt="2" style="zoom:45%"/><br>好家伙！下饭视频不是来了2333······我点进去是合集的第二集，我就看第一集——计组相关的科普吧算是。<br><img src="https://picdl.sunbangyan.cn/2023/11/26/e6a6be4cd8ad86e896db63a9a81334f8.jpeg" alt="1" style="zoom:45%"/><br>AI配音，而且语气和声调调得不错，动画、PPT都不错，只是我听不懂——问题不大！<br>于是开了这一个坑，其实也就是以这个视频为主，弄懂视频讲的就行了，不深入，有时间就搞，没时间先搁着。</p><hr><p>然后跟up私信聊了一下：</p><ul><li>谢谢谢谢，我现在大四了，在学语言的间隙重新再补基础的知识，机缘巧合下做了视频。文案需要的话我整理下放视频源代码的仓库里。关于视频和书籍，推荐一个up清华邓博士，我比较认同他的观点，<strong>视频是高度浓缩的，看不同老师讲相同的知识可以得到不同的视角加深理解，而书籍里有更多细节作为补充。但不管怎样，多写肯定是最重要的，多写一些高质量的lab，这也是我遗憾没有一开始就做的事。</strong></li><li>视频方向还没什么大想法，接下去我时间也会比较紧，可能会做一些有意思的内容，已经有一个想法了，也是会跟之前的有所关联</li></ul><hr><p>还加了up微信，哈哈。<br>这里面的东西我都挺感兴趣的：AI配音、MainmGL、视频剪辑、py（up的代码是python写的，1000+行，看不懂······python确实强大啊）</p>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归档（拖更√） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以文学视角评价超越时代的巅峰之作——《白色相簿2》</title>
      <link href="/posts/23610/"/>
      <url>/posts/23610/</url>
      
        <content type="html"><![CDATA[<p>原文出处（已征得转载同意）：<a href="https://mp.weixin.qq.com/s/ahzS_uIqVofRT7AMPkIwMg">从文学视角评价超越时代的巅峰之作——《白色相簿2》</a>，只知道睡觉的觉皇 Galgame批评 2023-11-22</p><hr><p class='p blue center logo large'>白色相簿2</p><p>又到了白色相簿的季节。</p><hr><img src="https://picdm.sunbangyan.cn/2023/11/22/56a25beeee22758bbff35056c4ae2e7d.jpeg" alt="1" /><p><strong>《白色相簿2》作为Galgame历史上最成功且评分最高的作品之一，直至今日仍旧霸占着亚马逊R18Game销量的榜首（2023.11.16），其在浪漫主义作品中融合的“现实感”的做法令观众津津乐道，关于白学的品鉴分析也一直存续至今。本篇专栏想从文学的视角来谈谈这部超越时代的巅峰之作——《白色相簿2》。</strong></p><hr><p>余华在《鲁迅是我这辈子唯一讨厌过的作家》中写道：“鲁迅已经从一个作家变成了一个词汇，一个代表着永远正确和永远革命的词汇。”</p><p>如果要在ACG作品中挑选一个成为“词汇”的作品。那我想《白色相簿2》再合适不过了，《白2》已然成为了一个“印象”，一张“名片”。只要提到《白2》，无论是否玩过原作，人们都会联想到那个名场面以及它带来的影响力。尽管现如今真正体验过原作的人并不多，但每当宅男宅女们提到冬天、提到三角关系时，那个经典的分镜也或多或少会在脑海中浮现。</p><p>纵观那些屹立于Galgame巅峰的作品，似乎只有《白2》的设定显得日常且平庸，它只不过是一个设定在校园和职场中的，几个学生与社畜之间的故事。它没有《兰斯10》那样恢弘的异世界设定和独到的游戏玩法；没有SCA-自笔下《素晴日》、《樱之诗》的哲学思辨；没有《樱花、萌放》里奇思妙想的魔法世界；也没有《Ever17》、《命运石之门》中有关轮回的那般丰富想象。同样偏向日常的《Clannad》、《Summer Pockets》中光玉、七影蝶之类的超自然设定也并未在《白2》中存在。</p><img src="https://picst.sunbangyan.cn/2023/11/22/e44f069662776b7af8130c73f5cfd592.jpeg" alt="2" /><p>但是，站在山巅之上的作品一定有自己的独特之处。丸户史明用残忍却温柔的笔触，写下了这部理性的浪漫主义神作。残忍在于其令人扼腕的结局和悲剧的内核。正如亚里士多德在《诗学》里所说，悲剧的六个要素中，最重要的是情节。情节乃悲剧的基础，有似悲剧的灵魂。那么，《白2》是如何处理情节上的悲剧呢？</p><p>人们都说悲剧是把美好的事物毁灭，《白2》则是先创作出美好的事物，让观众爱上美好，醉心于略带苦涩的甜蜜毒药。明知悲剧不可避免，沉溺谵妄美好的幸福感和无法阻止悲剧的无力感在剧情的深入中互相交织。在中后半段，故事无情得将美好的事物撕成两片，强迫你选择其中之一。而这也正是其温柔所在，它并未毁去全部，而是保留了一部分美好，让观众仍有所留恋。最后利用尾声、AfterStory和广播剧、电子小说等“番外”展开稍稍填补观众内心的空缺，或舔舐曾经的伤痕，或再补上几刀。</p><p>当然，玩家口中的“胃疼”并不是说着玩的，在这个没有猎奇的作品中，生理不适的情况真的有可能出现。这并非是因为画面的惊悚和文字的血腥带来的生理不适，而是对情感纯粹且真挚的细腻描绘所带来的痛苦，表达了一种不能承受的生命之轻。在体验作品的过程中，笔者也在部分关键内容上出现了“呼吸困难”、“心悸”等生理现象，随之而来的则是不经意间的泪流满面。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/0414614b20d678e57e047f75ef1da475.jpeg" alt="3" /><p>凭借出色的脚本设计，《白2》贯彻了悲剧的内核。这里可能会有读者感到疑惑，我觉得部分线路的结尾还是挺幸福的，为什么笔者认为这是悲剧呢。这里我想引用朱光潜先生在《悲剧心理学》中的观点，“仅仅有没有不幸结局这一点，对于一部伟大的悲剧来说并不很重要。”仅有苦难和灾祸构不成悲剧，至多是苦难剧或惨剧。对悲剧来说，紧要的不仅是巨大的苦难，而是对待痛苦的方式。没有对灾难的反抗，也就没有悲剧。</p><p>小春线对校园暴力的反抗，和纱te对整个社会规则与人情束缚的反抗，还有那贯穿终章的，春希、和纱、雪菜等人对自我过去经历的反抗。这也是《白2》中没有传统悲剧中角色失去生命、失去记忆等桥段，却仍能展现悲剧美的原因。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/de48b72fce5b60642d1b9bf49796d6e7.jpeg" alt="4" /><p>就这样，丸户在一个完全可以自由幻想的虚拟世界中，给观众划下一道道现实的伤疤。这里的现实不仅指对观众造成的现实影响，也是指作品中颇具“现实感”的内容。虽然《白2》是在二次元世界中演绎的故事，却有着浓烈的现实色彩。不同于其他二次元作品中虚幻的校园，丸户将少许笔墨用来展现真实的校园与社会，观众能在部分内容中真实感受到升学、工作、交友、处理人际关系的压力。作品不止聚焦于爱情故事，在上述的刻画中更体现了主角从学生到社畜的成长经历。</p><p> “无论多么大的爱情,也不可能从社会逃出去,更是不能和社会脱轨。有了想法就突然坐上电车，逃避现实，然后大结局，这种故事怎能让人信赖他们之后的人生呢？”丸户史明是这么说的，也是这么做的。他确实在和纱TE里完成了一个颇具现实感的结局，而不是充满二次元幻想风味的爱情故事。</p><p>许多故事在叙述时总会按照遭遇挫折——受到鼓励——奋发振作的心路历程来讲述，这样一套叙事逻辑是经过市场检验的，也是不易翻车的，受观众欢迎的，但也正是最不符合现实的“童话”。因为不是所有挫折都能靠鼓励治愈，也不是所有努力都一定能获得满意的结局。这或许正是《白色相簿2》中想要表达的内容之一。而想用环境和角色的塑造讲好一个现实感十足的悲剧是相当困难的，想要做到逻辑自洽，就必然要在设计上下功夫。在这一点上，丸户史明用两百万字的文本量交出了一份满意的答卷。</p><p>打个比方的话，《白2》的部分内容就像是发生在二次元世界的《飘》一样，只是《飘》中二男一女的三角关系转变为了《白2》中的二女一男。</p><img src="https://picst.sunbangyan.cn/2023/11/22/ad4726f896f822d2bd1d917b3f9e9845.jpeg" alt="5" /><p>在叙事的过程中，《白2》对插叙和闪回的使用登峰造极。故意利用关键事件的缺失，让自以为上帝视角的观众并不能知晓故事的全貌。又在其后的发展中，或运用插叙的手段，或让脚本中的人物进行自我表述，填补线条上的空缺，串连起一个完整的故事。</p><p>在塑造人物的手法上，《白2》并未使用很多其他作品中简单的“贴标签”手法，区别于千篇一律的“扁形人物”，《白2》中的角色几乎全是立体的“圆形人物”。雪菜神性般的忍耐与包容有目共睹，但也借由剧情的发展凸显其身为“人”的可爱。在雪菜TE线中，观众也了解到了雪菜的心路历程和其为何对男主如此包容的真相，完成了对雪菜圣母形象的逻辑自洽。和纱的怠惰与对男主忠犬般的依赖是她的明面，而坚毅的情感和敢于断舍离的暗面也在“浮气”、“雪菜TE”线中得以表现。</p><p>无论是和纱还是雪菜，其角色画像都不是一条线路能完整表述的。这也印证了前文所说的“叙述思路”，因为其出色的叙事手法和对部分信息的刻意隐藏，单一线路中的故事只能让观众管中窥豹，只有完整体验整部作品，才能感受到角色与作品本真的魅力。当然，这也正是多线剧情向Galgame的魅力所在。哪怕不跳过选择段落的重复内容，你都能在重复的体验中发掘出全新的内容体验。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/03fd45d6166dd649dcebfebefae7ee0c.jpeg" alt="6" /><p>在终章中出场的另外三位角色也各有其特色，麻理没有和纱那样一走了之的决绝，也不因对男主的宠溺而像雪菜一样包容，令男主经历了从犹豫摇摆到坚定果断的成长。尤其是尾声狡猾的叙诡手法，让麻理线的含金量得以提高。对于小春来说，虽然我一开始对她与春希交往的感到突兀和诧异，但随着体验的深入，我逐渐理解了小春这一角色存在的意义。我们通常称小春为“小春希”，因为她的处事态度和逻辑与春希相似。小春的存在就像春希的一面镜子，让春希看到属于自己的那一面，让他能看到自己身上的优缺点，从而领悟到自己应该改变什么，应该坚定什么。千晶大魔王的存在则是男主经历的见证者，但她也在交往的过程中“假戏真做”，不觉萌生了情愫。也正如游戏中所说，麻理给予了“我”勇气，小春为“我”指出了正确的道路，千晶则教给了“我”答案。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/bfff5013d864987751fbe4d70166c31c.jpeg" alt="7" /><p>除了几位关键角色之外，哪怕是像柳原朋这样出场率不高半边缘角色，也演绎出令观众爱恨交织的多面体。一方面她对雪菜的捉弄令观众不满，另一方面，她又切实推进了主角关系的进展。最终也确实成为了雪菜的朋友之一。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/e38a4f0094ef5e7346e9369f04b874a8.jpeg" alt="8" /><p>可惜的是，白学名场面、“明明是我先来的”等内容，伴随着出圈也产生了解构的现象。诞生于机场的名场面原本是一个情感交织的复杂命题，是由矛盾所导致的苦难，是浪漫主义的具象化表现，也是一场角色内心冲突的真实写照。这些内容却在传播的解构中被消解淡化，只留下了一个经典的镜头，变为了一场戏谑揶揄的狂欢。“明明是我先来的”这句经典台词，在单拎出来时也显得像是怨妇的无理取闹，反而失去了原作中那种痛彻心扉与深入骨髓的悲痛情感。</p><p>《镜与灯：浪漫主义文论及批评传统》中指出，世界、作家、作品和读者是文学批评的四个要素。所有作品不得不依靠读者的阅读而真实地存在，否则就只能成为潜在的文本。所以，对《白2》内容的解构或许是出名破圈所带来的不可避免的必然后果，当然这样未必都是消极的，或许也会有更多玩家能借此机会接触到《白色相簿2》这样优秀的作品，转而成为这部神作的忠实拥趸。</p><img src="https://picst.sunbangyan.cn/2023/11/22/eb73fcbbe6ffc0731a9985852f3dc6a4.jpeg" alt="9" /><p>通过荡气回肠的剧情故事，现实感的描绘和丰满立体的角色塑造，《白色相簿2》成为了我心目中超越神作的存在。它已然列入我个人的ACG作品排行榜中第一的位置。在推完游戏后，我也产生了不想游玩其他作品的“脱宅”反应。在《白2》问世后，也有不少ACG作品想要重现“胃疼”的现象，例如颜艺社的《恋爱成双》。但它们都很难企及《白2》的高度。哪怕是丸户史明本人后来的作品《路人女主》、《契约之吻》，都再难与《白色相簿2》的高度并肩。或许这也和《白2》本身现实感的设定，以及Gal这一产业的日渐消沉相关吧。而《白2》十年来屹立于各项排行榜前三的辉煌本身，也成为了其超越时代的见证。</p><p>对浪漫主义者而言，作品就是第二自然世界，所以，我在这里也衷心祝福雪菜、和纱、春希、武也、依绪、曜子、朋、麻理、千晶、小春、孝宏等人，祝愿你们能幸福地在《白色相簿2》的世界里过完一生。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/55b092bc99ace691e704f40d7c74601a.jpeg" alt="10" /><p>在我推完序章部分时，刚好我所在的城市下起了今年的第一场雪。我也很久没有经历过这样令我沉迷的游戏了，想起来上一个令我这般着迷的Galgame可能还是代表夏天的Summer Pockets。或许季节也在冥冥之中赋予了我一层buff吧。在推完整部作品之后，我立刻提笔写下了这篇四千多字的评价，如果你看到这里并且觉得我的评价还算不错的话，请给个三连支持一下我吧！非常感谢。</p><hr><p class='p center logo large'>写在后面</p><p>又到了白色相簿的季节。在写文案的时候，看到着游戏里的CG、听见那一首首熟悉的BGM，好几次不禁潸然泪下。</p><p>因为是从文学视角的点评，所以仅展现了《白2》在剧情上的闪光点，并没有涉及游戏音乐、原画等方面的内容。引用了一些文学理论和美学相关著作的观点。本篇内容尽可能通俗易懂的浅显评价了《白色相簿2》的整体文字部分。 </p><p>本篇并未涉及党争相关内容，也没有讨论哪个结局合理哪个结局不合理或者谁是真结局，尽量保持主客观内容的均衡，我认为一千个人有一千个哈姆雷特。每个人都有不同的答案，如果读者有自己的想法也可以互相沟通，思维的碰撞才能闪耀出灵魂的火花。</p><p>其实关于《白色相簿2》可以谈论的内容很多，本篇内容中的小点也还能细致拆分出来详尽分析，例如悲剧美是如何在游戏中具体体现的，白2的整体叙事风格基调，或者是从空间叙事学角度进行分析（游戏本身并不是一个单纯的第一视角游戏，从男主配音这一特色就能看出，本期专栏主要还是对人物分析角度着墨）、以及对每个人物本身进行更细致入微的展开（例如几个角色家庭背景产生的影响，雪菜看似美好的家庭对她的影响、和纱成为怠惰女高的家庭原因）等等，但关于文字内容的大体分析到这里就暂且浅尝辄止了。</p><p>最后，感谢所有喜欢《白色相簿2》的人们，感谢丸户史明，感谢游玩过程中“IMay.TuzKi”和我的沟通交流，再一次感谢屏幕前的各位!</p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈——线性结构的应用之一</title>
      <link href="/posts/34532/"/>
      <url>/posts/34532/</url>
      
        <content type="html"><![CDATA[<p><strong>栈和队列是一种特殊的线性结构，是连续存储或离散存储的一种应用。</strong><br>此为链式队列。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一种可以实现“先进后出”的存储结构，类似于箱子。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul><li>静态栈</li><li>动态栈</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>出栈</li><li>压栈</li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ul><li>函数调用</li><li>中断</li><li>表达式求值</li><li>分配内存</li><li>缓冲处理</li><li>迷宫</li></ul><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    <span class="type">int</span> * m = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如静态变量p和m是在栈中分配，由操作系统自动分配和释放。而<code>(int *)malloc(100);</code>执行后，将在堆中分配一块100字节的内存，由程序员手动分配。<br><img src="https://picdl.sunbangyan.cn/2023/11/24/8b16547b47f71dd4d754e2e88f5e2a34.jpeg" alt="1" style="150%"/></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @version: 4.0  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-10-17 19:42:30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE, *PNODE;      <span class="comment">// 定义栈节点叫Stack_Node 和 pStack_Node 更好</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PNODE pTop;</span><br><span class="line">    PNODE pBottom;</span><br><span class="line">&#125;STACK, *PSTACK;    <span class="comment">// 定义保存栈节点地址的 栈指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(PSTACK)</span>;          <span class="comment">// 栈初始化，造出空栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(PSTACK, <span class="type">int</span> )</span>;    <span class="comment">// 压栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(PSTACK)</span>;      <span class="comment">// 遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(PSTACK pS)</span>;      <span class="comment">// 栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(PSTACK, <span class="type">int</span> *)</span>;    <span class="comment">// 出栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(PSTACK pS)</span>;      <span class="comment">// 清除栈</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    STACK s;    <span class="comment">// STACK 等价于 struct Stack</span></span><br><span class="line"><span class="comment">//  PSTACK S = (PSTACK)malloc(sizeof(PSTACK));  // 没必要，画蛇添足</span></span><br><span class="line"><span class="comment">//  PSTACK S = (PNODE)malloc(sizeof(NODE));     // 结构体类型不一样，不能转换</span></span><br><span class="line"><span class="comment">//  PSTACK S = NULL;    // 大错特错！</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 郝斌老师：</span></span><br><span class="line">    Init(&amp;s);</span><br><span class="line">    Push(&amp;s, <span class="number">1</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">2</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">3</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">4</span>);</span><br><span class="line">    Traverse(&amp;s);   <span class="comment">// 目的是便于输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上————没必要，画蛇添足。</span></span><br><span class="line"><span class="comment">/*  Me:</span></span><br><span class="line"><span class="comment">    Init(S);</span></span><br><span class="line"><span class="comment">    Push(S, 1);</span></span><br><span class="line"><span class="comment">    Push(S, 2);</span></span><br><span class="line"><span class="comment">    Traverse(S);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span>(Pop(&amp;s, &amp;val))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈成功！出栈的元素是：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈失败！\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Clear(&amp;s);</span><br><span class="line">    Traverse(&amp;s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Pop(&amp;s, &amp;val))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈成功！出栈的元素是：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈失败！\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">    pS-&gt;pTop = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));     <span class="comment">// 新建栈节点，头栈节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pS-&gt;pTop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pS-&gt;pBottom = pS-&gt;pTop;     <span class="comment">// 栈顶和栈底 都指向指针域为空的头栈节点</span></span><br><span class="line">        pS-&gt;pBottom-&gt;pNext = <span class="literal">NULL</span>;  <span class="comment">// 头栈节点的指针域为 NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(PSTACK pS, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));   <span class="comment">// 新建一个栈节点</span></span><br><span class="line">    </span><br><span class="line">    pNew-&gt;data = val;   <span class="comment">// 给栈节点中的数据域赋值</span></span><br><span class="line">    pNew-&gt;pNext = pS-&gt;pTop;     <span class="comment">// pS-pTop 不能改为 pS-pBottom</span></span><br><span class="line">                                <span class="comment">// 栈节点的指针域保存下一个节点的地址</span></span><br><span class="line">    pS-&gt;pTop = pNew;    <span class="comment">// 新的栈节点变为新的栈顶</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE p = pS-&gt;pTop;     <span class="comment">// 指针指向栈顶</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p != pS-&gt;pBottom) <span class="comment">// 是否遍历到栈底</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;   <span class="comment">// 下一个节点的地址，栈节点的指针域保存下一个节点的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pS-&gt;pTop == pS-&gt;pBottom) <span class="comment">// 栈顶和栈底都指向头栈节点时栈才为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把pS所指向的栈出栈一次，并把出栈的元素存入 pVal形参所指向的变量中，如果出栈失败，返回 false，否则返回 true</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(PSTACK pS, <span class="type">int</span>* pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Empty(pS))   <span class="comment">// pS 本身存放的就是S的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PNODE r = pS-&gt;pTop; <span class="comment">// 指针指向栈顶</span></span><br><span class="line">        *pVal = r-&gt;data;    <span class="comment">// 获取栈顶的数据域内的数据 </span></span><br><span class="line">        pS-&gt;pTop = r-&gt;pNext;<span class="comment">// 新的栈节点变为新的栈顶</span></span><br><span class="line">        <span class="built_in">free</span>(r);    <span class="comment">// 内存释放，否则容易造成内存泄漏。释放r所指向的原栈顶节点的内存</span></span><br><span class="line">        r = <span class="literal">NULL</span>;   <span class="comment">// 避免野指针，NULL 是拴狗的狗链子</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(PSTACK pS)</span>   <span class="comment">// 清空栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Empty(pS))   <span class="comment">// pS 本身存放的就是 S 的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PNODE p = pS-&gt;pTop; <span class="comment">// 指针指向栈顶</span></span><br><span class="line">        PNODE q = <span class="literal">NULL</span>;     <span class="comment">// 栈节点的地址临时保存在 q 中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p != pS-&gt;pBottom) <span class="comment">// 是否遍历到栈底</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            q = p-&gt;pNext;   <span class="comment">// 栈节点指针域(下一节点地址)临时保存在指针 q 中</span></span><br><span class="line">            <span class="built_in">free</span>(p);    <span class="comment">// 经过上步才能进行此步，否则直接 free，就找不到下一个节点地址了</span></span><br><span class="line">            p = q;      <span class="comment">// 临时保存在 q 中的下一节点地址赋值给 p，准备循环释放下一节点内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        pS-&gt;pTop = pS-&gt;pBottom; <span class="comment">// 栈顶和栈底都指向指针域为空的头栈节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列（链式队列）—— 线性结构的应用之一</title>
      <link href="/posts/7017/"/>
      <url>/posts/7017/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-10-27 17:18:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pNext</span>;</span><span class="comment">// int* pBase; 错误！</span></span><br><span class="line">&#125;NODE, *PNODE;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  PNODE pHead, pTail;<span class="comment">//pHead指向无用的头结点 pHead-&gt;pNext才指向队首元素, pTail指向队尾元素</span></span><br><span class="line">  </span><br><span class="line">public:</span><br><span class="line">  Queue();</span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> <span class="title function_">Traverse_Queue</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="title function_">Empty_Queue</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span>;</span><br><span class="line"><span class="comment">//bool Full_Queue();// 链式队列不会满！</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">En_Queue</span><span class="params">(<span class="type">int</span> val)</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="title function_">Out_Queue</span><span class="params">(<span class="type">int</span>&amp; val)</span>;<span class="comment">//使用引用更好；bool Out_Queue(int* pVal);</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Clear_Queue</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">  </span><br><span class="line">  ~Queue();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Queue Q;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    Q.En_Queue(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Q.Traverse_Queue();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>( Q.Out_Queue(val) )<span class="comment">//用引用代替&amp;val</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;出队成功，出队的元素是: &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;出队失败！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>( Q.Out_Queue(val) )<span class="comment">//用引用代替&amp;val</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;出队成功，出队的元素是: &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;出队失败！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  Q.Traverse_Queue();</span><br><span class="line">  </span><br><span class="line">  Q.Clear_Queue();</span><br><span class="line">  Q.Traverse_Queue();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue::Queue()</span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;pHead = this-&gt;pTail = new NODE;</span><br><span class="line">  this-&gt;pHead-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue::~Queue()</span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;Clear_Queue();</span><br><span class="line">  delete this-&gt;pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue::Traverse_Queue</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  PNODE pTemp = this-&gt;pHead-&gt;pNext;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(pTemp == nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空，无法遍历！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(pTemp != nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pTemp-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    pTemp = pTemp-&gt;pNext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Queue::Empty_Queue</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(this-&gt;pHead == this-&gt;pTail)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue::En_Queue</span><span class="params">(<span class="type">int</span> val)</span><span class="comment">//在类外必须指定成员函数的作用域Queue::</span></span><br><span class="line">&#123;</span><br><span class="line">  PNODE pNew = new NODE;</span><br><span class="line">  </span><br><span class="line">  pNew-&gt;data = val;</span><br><span class="line">  pNew-&gt;pNext = nullptr;<span class="comment">//使用nullptr而不是NULL，这是现代C++的做法</span></span><br><span class="line">  </span><br><span class="line">  this-&gt;pTail-&gt;pNext = pNew;<span class="comment">//用this指代当前对象的指针，增强可读性</span></span><br><span class="line">  this-&gt;pTail = pNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Queue::Out_Queue</span><span class="params">(<span class="type">int</span>&amp; val)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(this-&gt;Empty_Queue())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空，无法出队！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    PNODE pTemp = this-&gt;pHead-&gt;pNext;</span><br><span class="line">    val = pTemp-&gt;data;</span><br><span class="line">    </span><br><span class="line">    this-&gt;pHead-&gt;pNext = pTemp-&gt;pNext;<span class="comment">//this-&gt;pHead-&gt;pNext-&gt;pNext;</span></span><br><span class="line">    delete pTemp;<span class="comment">// 使用delete释放内存，而不是free(pTemp);</span></span><br><span class="line">    pTemp = nullptr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( nullptr == this-&gt;pHead-&gt;pNext )<span class="comment">//检查队列是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      this-&gt;pTail = this-&gt;pHead;</span><br><span class="line">      <span class="comment">//如果队列为空，则将 pTail 指针移回 pHead，</span></span><br><span class="line">      <span class="comment">//这是为了确保在队列变为空时， pTail 也要指向无用的头结点。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue::Clear_Queue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>( !this-&gt;Empty_Queue() )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    this-&gt;Out_Queue(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列（循环队列）—— 线性结构的应用之一</title>
      <link href="/posts/13537/"/>
      <url>/posts/13537/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-10-26 18:40:37</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在程序结束时，应该使用 free 函数来释放分配的内存，以防止内存泄漏。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//struct Queue* pBase;</span></span><br><span class="line">  <span class="type">int</span>* pBase;</span><br><span class="line">  <span class="type">int</span> front;</span><br><span class="line">  <span class="type">int</span> rear;</span><br><span class="line">&#125;QUEUE, *PQUEUE;<span class="comment">//PQUEUE == struct Queue*，即创建一个 QUEUE 类型的指针别名</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_Queue</span><span class="params">(PQUEUE pQ)</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">En_Queue</span><span class="params">(PQUEUE pQ, <span class="type">int</span> val)</span>;<span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Out_Queue</span><span class="params">(PQUEUE pQ, <span class="type">int</span>* pVal)</span>;<span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Full_Queue</span><span class="params">(PQUEUE pQ)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty_Queue</span><span class="params">(PQUEUE pQ)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse_Queue</span><span class="params">(PQUEUE pQ)</span>;<span class="comment">//遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  PQUEUE Q;<span class="comment">//在 Init_Queue 函数中，不再需要分配内存，因为 Q 是一个指向 QUEUE 结构的指针</span></span><br><span class="line">  Q = (PQUEUE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QUEUE));<span class="comment">// QUEUE == struct Queue</span></span><br><span class="line">  <span class="keyword">if</span> (Q == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  </span><br><span class="line">  Init_Queue(Q);</span><br><span class="line">  En_Queue(Q, <span class="number">1</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">2</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">3</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">4</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">5</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">6</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">7</span>);</span><br><span class="line">  Traverse_Queue(Q);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>( Out_Queue(Q, &amp;val) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队成功，出队的元素为：%d\n&quot;</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队失败！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Traverse_Queue(Q);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在程序结束时，应该使用 free 函数来释放分配的内存，以防止内存泄漏。</span></span><br><span class="line">  <span class="built_in">free</span>(Q);</span><br><span class="line">  <span class="built_in">free</span>(Q-&gt;pBase);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_Queue</span><span class="params">(PQUEUE pQ)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//QUEUE* pQ = (Queue)malloc(sizeof(QUEUE));//在 Init_Queue 函数中，不再需要分配内存，因为 Q 是一个指向 QUEUE 结构的指针。</span></span><br><span class="line">  pQ-&gt;pBase = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span>(pQ-&gt;pBase == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    pQ-&gt;front = <span class="number">0</span>;</span><br><span class="line">    pQ-&gt;rear = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">En_Queue</span><span class="params">(PQUEUE pQ, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>( Full_Queue(pQ) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    pQ-&gt;pBase[pQ-&gt;rear] = val;</span><br><span class="line">    pQ-&gt;rear = (pQ-&gt;rear + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Out_Queue</span><span class="params">(PQUEUE pQ, <span class="type">int</span>* pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>( Empty_Queue(pQ) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *pVal = pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">    pQ-&gt;front = (pQ-&gt;front + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty_Queue</span><span class="params">(PQUEUE pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(pQ-&gt;rear == pQ-&gt;front)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Full_Queue</span><span class="params">(PQUEUE pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>( (pQ-&gt;rear + <span class="number">1</span>) % <span class="number">6</span> == pQ-&gt;front )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse_Queue</span><span class="params">(PQUEUE pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = pQ-&gt;front;<span class="comment">//借助临时变量 i 来进行遍历</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i != pQ-&gt;rear)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pQ-&gt;pBase[i]);</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表</title>
      <link href="/posts/45748/"/>
      <url>/posts/45748/</url>
      
        <content type="html"><![CDATA[<p>涉及到链表的 创建、遍历、求长度、插入、删除、查找、排序。</p><h1 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h1><ul><li><strong>typedef</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;* PSTU, STU;        </span><br><span class="line"><span class="comment">//PSTU等价于struct Student *, STU等价于struct Student</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    STU st;        <span class="comment">//struct Student st;</span></span><br><span class="line">    PSTU ps = &amp;st;    <span class="comment">//struct Student* ps = &amp;st;</span></span><br><span class="line">    ps-&gt;sid = <span class="number">99</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ps-&gt;sid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>确定一个链表所需要的参数</strong><br>头指针</p></li><li><p><strong>每一个链表节点的数据类型该如何表示的问题</strong></p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>      //节点————每一个节点分为两部分，数据域和指针域</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;    <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span>      <span class="comment">//指针域————指向的是一个跟它本身数据类型一致、但是是另外一个节点</span></span><br><span class="line">&#125;NODE, *PNODE;    <span class="comment">//NODE 等价于struct Node，PNODE等价于struct Node *</span></span><br></pre></td></tr></table></figure><ul><li><strong>插入节点</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>  r = p-&gt;pNext; p-&gt;pNext = q;  q-&gt;pNext = r;</span><br><span class="line"><span class="comment">//q-&gt;pNext表示的是q指向的那个结构体变量中的pNext成员</span></span><br><span class="line"><span class="number">2.</span>  q-&gt;pNext = p-&gt;pNext;  p-&gt;pNext = q;</span><br></pre></td></tr></table></figure><ul><li><strong>删除节点</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(r);</span><br></pre></td></tr></table></figure><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-10-04 11:13:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不懂就画图！！！！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span>    <span class="comment">//指针域</span></span><br><span class="line">&#125;NODE, *PNODE;  <span class="comment">//NODE等价于struct Node    PNODE等价于struct Node *</span></span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">Create_List</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">//创建链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse_List</span><span class="params">(PNODE pHead)</span>;    <span class="comment">//遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Empty</span><span class="params">(PNODE pHead)</span>;         <span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length_List</span><span class="params">(PNODE pHead)</span>;       <span class="comment">//求链表长度</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_List</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> val)</span>;    <span class="comment">//在pHead所指向链表的第pos个节点的前面插入一个新的结点，该节点的值是val， 并且pos的值是从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete_List</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span>; <span class="comment">//删除链表第pos个节点，并将删除的结点的值存入pVal所指向的变量中,  并且pos的值是从1开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_List</span><span class="params">(PNODE)</span>;          <span class="comment">//选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_List_Bubble</span><span class="params">(PNODE)</span>;   <span class="comment">//冒泡排序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    PNODE pHead = <span class="literal">NULL</span>;     <span class="comment">//等价于 struct Node * pHead = NULL;</span></span><br><span class="line">    </span><br><span class="line">    pHead = Create_List();  <span class="comment">//函数功能：创建一个非循环单链表，并将该链表头节点的地址赋给null</span></span><br><span class="line">    Traverse_List(pHead);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  Insert_List(pHead, 4, 88);</span></span><br><span class="line"><span class="comment">//  Insert_List(pHead, 5, 55);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( Delete_List(pHead, <span class="number">4</span>, &amp;val) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功， 删除的元素为：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  if( Is_Empty(pHead) )</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      printf(&quot;链表为空！\n&quot;);</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  else</span></span><br><span class="line"><span class="comment">//      printf(&quot;链表不为空！\n&quot;);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  int len = Length_List(pHead);</span></span><br><span class="line"><span class="comment">//  printf(&quot;链表的长度是%d\n&quot;, len);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  Sort_List(pHead);</span></span><br><span class="line"><span class="comment">//  Traverse_List(pHead);</span></span><br><span class="line">    </span><br><span class="line">    Sort_List_Bubble(pHead);</span><br><span class="line">    Traverse_List(pHead);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    释放链表内存空间:</span></span><br><span class="line"><span class="comment">      首先，从链表的第一个节点开始，依次释放每个节点的内存空间。然后释放头节点的内存空间。这样就确保了整个链表的内存空间都被释放。</span></span><br><span class="line"><span class="comment">      需要注意的是，释放节点内存空间时，应先保存下一个节点的指针，然后再释放当前节点的内存空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PNODE temp = p;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pHead);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">Create_List</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;    <span class="comment">//用来存放有效节点的个数</span></span><br><span class="line">    <span class="type">int</span> val;    <span class="comment">//用来临时存放用户输入的结点的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配了一个不存放有效数据的头节点</span></span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));  <span class="comment">//返回的是节点本身的数据类型，所以是NODE，不是PNODE</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE pTail = pHead;    <span class="comment">//定义一个时刻指向尾节点的变量</span></span><br><span class="line">    pTail-&gt;pNext = <span class="literal">NULL</span>;    <span class="comment">//如果只输入一个数据时满足此情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入需要生成的链表节点个数：len = &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个节点的值：&quot;</span>, i+<span class="number">1</span>); </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">        </span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//临时节点</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == pNew)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pNew-&gt;data = val;       <span class="comment">//临时节点存放临时变量</span></span><br><span class="line">        pTail-&gt;pNext = pNew;    <span class="comment">//把新的节点挂到尾节点后</span></span><br><span class="line">        pNew-&gt;pNext = <span class="literal">NULL</span>;     <span class="comment">//新节点的下一个节点就为空了</span></span><br><span class="line">        pTail = pNew;           <span class="comment">//更新尾节点</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*  错误：每个节点都挂在了头结点之后！</span></span><br><span class="line"><span class="comment">        pNew-&gt;data = val;</span></span><br><span class="line"><span class="comment">        pHead-&gt;pNext = pNew;</span></span><br><span class="line"><span class="comment">        pNew-&gt;pNext = NULL;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse_List</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;     <span class="comment">//p可能为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;     <span class="comment">//表示函数执行完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Empty</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead-&gt;pNext == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length_List</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提到了C++重载、泛型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_List</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line">    <span class="type">int</span> len = Length_List(pHead);</span><br><span class="line">    PNODE p, q;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, p=pHead-&gt;pNext;i&lt;len<span class="number">-1</span>;i++, p=p-&gt;pNext)    <span class="comment">//i=0：第一个元素的下标；p=pHead-&gt;pNext：第一个有效元素的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>, q=p-&gt;pNext;j&lt;len;j++, q=q-&gt;pNext)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data)       <span class="comment">//类似于数组中的：a[i] &gt; a[j]</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = p-&gt;data;            <span class="comment">//类似于数组中的：t = a[i];</span></span><br><span class="line">                p-&gt;data = q-&gt;data;      <span class="comment">//类似于数组中的：a[i] = a[j];</span></span><br><span class="line">                q-&gt;data = t;            <span class="comment">//类似于数组中的：a[j] = t;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_List_Bubble</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line">    <span class="type">int</span> len = Length_List(pHead);</span><br><span class="line">    PNODE p,q;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,p=pHead-&gt;pNext;i&lt;len<span class="number">-1</span>;i++,p=p-&gt;pNext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>,q=pHead-&gt;pNext;j&lt;len<span class="number">-1</span>-i;j++,q=q-&gt;pNext)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;data &gt; q-&gt;pNext-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                t = q-&gt;data;</span><br><span class="line">                q-&gt;data = q-&gt;pNext-&gt;data;</span><br><span class="line">                q-&gt;pNext-&gt;data = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在pHead所指向链表的第pos个节点的前面插入一个新的结点，该节点的值是val， 并且pos的值是从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_List</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">NULL</span>!=p &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;pNext; </span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span>==p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果程序能执行到这一行说明p已经指向了第pos-1个结点,但第pos-1个节点是否存在无所谓</span></span><br><span class="line">    <span class="comment">//分配新的结点</span></span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pNew)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pNew-&gt;data = val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将新的结点存入p节点的后面</span></span><br><span class="line">    PNODE q = p-&gt;pNext;</span><br><span class="line">    p-&gt;pNext = pNew;</span><br><span class="line">    pNew-&gt;pNext = q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//健壮性非常好</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete_List</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">NULL</span>!=p &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span>==p-&gt;pNext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果程序能执行到这一行说明p已经指向了第pos-1个结点，并且第pos个节点是存在的</span></span><br><span class="line">    PNODE q = p-&gt;pNext;</span><br><span class="line">    *pVal = q-&gt;data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除p后面的结点</span></span><br><span class="line">    p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line">    <span class="built_in">free</span>(q);        <span class="comment">//删除p后面的结点</span></span><br><span class="line">    q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态 链式二叉树</title>
      <link href="/posts/23318/"/>
      <url>/posts/23318/</url>
      
        <content type="html"><![CDATA[<p>此为静态的链式二叉树。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *       A</span></span><br><span class="line"><span class="comment"> *   B       C</span></span><br><span class="line"><span class="comment"> *        D</span></span><br><span class="line"><span class="comment"> *            E</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">pLchild</span>;</span> <span class="comment">// 左子树指针域 p是指针 L是左孩子 R是右孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">pRchild</span>;</span> <span class="comment">// 右子树指针域</span></span><br><span class="line">&#125;BTNODE, *PBTNODE;</span><br><span class="line"></span><br><span class="line">PBTNODE <span class="title function_">CreateBTree</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 创建二叉树，并返回二叉树根节点地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span>;   <span class="comment">//先序遍历二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span>;    <span class="comment">//中序遍历二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span>;  <span class="comment">//后续遍历二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PBTNODE pT = CreateBTree();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;先序遍历二叉树：\n&quot;</span>);</span><br><span class="line">    PreTraverseBTree(pT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历二叉树：\n&quot;</span>);</span><br><span class="line">    InTraverseBTree(pT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;后序遍历二叉树：\n&quot;</span>);</span><br><span class="line">    PostTraverseBTree(pT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PBTNODE <span class="title function_">CreateBTree</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建5个节点</span></span><br><span class="line">    PBTNODE pA = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pB = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pC = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pD = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pE = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给5个节点分配数据</span></span><br><span class="line">    pA-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    pB-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    pC-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    pD-&gt;data = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    pE-&gt;data = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设立各个节点之间的关系</span></span><br><span class="line">    pA-&gt;pLchild = pB;</span><br><span class="line">    pA-&gt;pRchild = pC;</span><br><span class="line">    pB-&gt;pLchild = pB-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pC-&gt;pLchild = pD;</span><br><span class="line">    pC-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pD-&gt;pLchild = <span class="literal">NULL</span>;</span><br><span class="line">    pD-&gt;pRchild = pE;</span><br><span class="line">    pE-&gt;pLchild = pE-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pA; <span class="comment">// 返回二叉树根节点地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span> <span class="comment">// 先序遍历二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pT-&gt;pLchild可以代表整个左子树</span></span><br><span class="line">    <span class="comment">// pT-&gt;pRchild可以代表整个右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> != pT ) <span class="comment">// 根节点地址不为空时才创建二叉树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pT-&gt;data);         <span class="comment">// 先序遍历根节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pLchild )<span class="comment">// 根节点左子树不为空时才遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            PreTraverseBTree(pT-&gt;pLchild); <span class="comment">// 先序遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pRchild )<span class="comment">// 根节点右子树不为空时才遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            PreTraverseBTree(pT-&gt;pRchild);  <span class="comment">// 先序遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span> <span class="comment">// 中序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> != pT )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pLchild )</span><br><span class="line">        &#123;</span><br><span class="line">            InTraverseBTree(pT-&gt;pLchild); <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pT-&gt;data);         <span class="comment">// 中序遍历根节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pRchild )</span><br><span class="line">        &#123;</span><br><span class="line">            InTraverseBTree(pT-&gt;pRchild); <span class="comment">// 中序遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span> <span class="comment">// 后序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> != pT )</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pLchild )</span><br><span class="line">        &#123;</span><br><span class="line">            PostTraverseBTree(pT-&gt;pLchild);  <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pRchild )</span><br><span class="line">        &#123;</span><br><span class="line">            PostTraverseBTree(pT-&gt;pRchild);  <span class="comment">// 后序遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pT-&gt;data);            <span class="comment">// 后序遍历根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>萌新九宫格之首的全新解读：里界小CL——假如逝去之人不再归来</title>
      <link href="/posts/64630/"/>
      <url>/posts/64630/</url>
      
        <content type="html"><![CDATA[<p>原文出处（已征得转载同意）：<a href="https://mp.weixin.qq.com/s/QlwaFMw-WqiQiyoNZ-ogTg">萌新九宫格之首的全新解读：里界小CL——假如逝去之人不再归来</a>，破军歌姬 Galgame批评 2023-11-08 11:00</p><p>（虽然这个gal我并没有玩过吧，但是作者的这篇文章让我想起了Clannad，已经看好多年了……）</p><hr><p>当挚爱之人逝去时，空留人世之人要如何摆脱内心的伤痛呢？clannad这部作品给我们的答案是去帮助别人，然后别人也会帮助你，甚至最后世界都会来帮助你。clannad确实是一个美好的童话故事，可以通过人们的善意，让心爱之人起死回生。然而现实世界里是没有救世的光玉存在的，能够治愈人类的，只有人类自己。<br><img src="https://picss.sunbangyan.cn/2023/11/12/edc97536768ec9f21c5df8ab9c7d003e.jpg" alt="Clannad" style="zoom:70%"/></p><p>让我意识到这一点的，是《若能与你再次相见》这部作品。这部作品又被誉为萌新九宫格之首，是galgame吧最推荐萌新入坑的游戏之一。说起入坑，我自然就想到了我的gal入坑作clannad，CL我当时看得非常感动，感叹有情人终成眷属。然而随着年龄的增长，我渐渐觉得CL的结局有些超现实了，如果现实中和朋也类似的人，真的遭遇了与他相似的惨剧，那么那些没有被光玉拯救的人又应该怎么办呢？如今，若能与你再次相见这部作品，就给出了一个非常现实的答案。<br><img src="https://picss.sunbangyan.cn/2023/11/12/a990becccf9ba34260ef09cb04685221.jpg" alt="1" /></p><hr><p>在若能与你再次相见中，男主角大崎陆持有的超自然道具，是一个被诅咒的怀表。使用这块怀表，虽然可以回到过去，但无法改变已经发生过的事，只能再次看着事情朝自己不愿看到的方向发展。赠予陆怀表的人是他的初恋古川涟，涟姐在赠予男主怀表后没多久就去世了。陆无法释怀涟姐逝去带来的伤痛，把希望都寄托在了怀表身上，虽然涟姐说过，怀表并不能改变既定的过去，但万一自己能成功呢？于是男主便像一只受了伤的候鸟一般，踏上了一场寻求救赎的旅途。<br><img src="https://picst.sunbangyan.cn/2023/11/12/0b9a111b715b9f3edf7b20294b4235b2.png" alt="2" /><br>男主放弃学业，一边打日结工挣旅游经费，一边到处用怀表逆转时空帮助别人。男主试图提前做出应对措施，让别人的困难在过去就不会发生，可是一次也没有成功。只能不依靠怀表，在困难发生后再帮助别人解决。男主只在一个城市待三个月，三个月过后就会去下一个城市旅行。这样的生活过了5年，5年后的男主来到了一个南方城市。在这里他遇到了一位境遇很像涟姐的少女泉诗乃，男主自然而然的被诗乃吸引，与她交谈甚欢。但因为诗乃也患有绝症，所以即使她和男主相处的很好，一个多月后也还是撒手人寰了，男主再一次感受到了重要之人逝去时的悲痛。这一次治愈男主的，不是怀表超自然的力量，而是诗乃的闺蜜岩出山未喜。男主先帮助未喜解决了她的烦恼，同时也解开了未喜哥哥笃史的心结，最后未喜再用她的爱去治愈男主，让男主有了新的生活目标，从而放下过去，走向未来。<br><img src="https://picdm.sunbangyan.cn/2023/11/12/1866e3c154ba07451d581cb7c2824530.png" alt="3" /><br><img src="https://picdl.sunbangyan.cn/2023/11/12/3ad41faa896eb10812c9ac28b8476099.png" alt="4" /></p><hr><p>岩出山未喜路线的人设，和cl中伊吹风子路线的人设很像：</p><p>冈崎直幸和古川涟都对男主角造成过伤害，所以冈崎直幸约等于古川涟；</p><p>泉诗乃和古河渚没有伤害男主的本意，但她们的逝去同样也对男主造成了伤害，所以泉诗乃约等于古河渚；</p><p>伊吹公子和岩出山笃史都是被男主解开对妹妹的心结后，才安心追逐自己的幸福，所以伊吹公子约等于岩出山笃史；</p><p>冈崎朋也和大崎陆虽然都是依靠帮助他人来逃避自己受到的痛苦，但他们确实也实实在在地帮助了很多人，所以冈崎朋也约等于大崎陆；</p><p>伊吹风子和岩出山未喜都得到了男主很大的帮助，并且她们也想要去回报和治愈男主了。所以伊吹风子约等于岩出山未喜。<br><img src="https://picdm.sunbangyan.cn/2023/11/12/482936b0f1690d33412e1cb60bae91ad.jpg" alt="5" style="zoom:70%"/><br>在岩出山未喜的路线中，男主与未喜同甘共苦，拼命帮未喜解决了她的家庭问题。解决问题时同样使用了怀表，怀表自然也没有奏效。那时，帮助未喜解决困难的心情大过了想要给涟姐证明怀表有用的心情，于是男主通过自己的力量成功帮助了未喜。那之后，他终于意识到了自己只不过是在通过怀表去逃避失去涟姐的伤痛罢了，人不能一直活在过去，逝者已逝，生者如斯。如今他终于可以走出涟姐和诗乃的逝去给自己带来的阴影了。因为他现在他要给自己新的爱人未喜带去幸福，过去的阴影已经被未喜的光芒照亮了。<br><img src="https://picst.sunbangyan.cn/2023/11/12/5bf6102d462df2458e043df6c59a6794.png" alt="6" /><br>在cl的as路线中，朋也同样先后失去了妻子和女儿。剧情发展到那种地步，满屏的绝望感真的很让人窒息，这让我时常在想，如果没有光玉，那能支撑朋也走完往后漫长人生路的动力，究竟还有什么？经历过多次重创的朋也，还能够得到救赎吗？岩出山未喜的路线给我提供了一种可能性：就算朋也再次自暴自弃，他的朋友们也不会放弃他，因为他的朋友们都曾得到过朋也的帮助。而朋也对伊吹风子有再生之德，她更加不会放弃朋也，一定会想尽办法去治愈他。毕竟在原作的AS路线里，风子就对朋也说过，难过的时候随时都可以来找她。爱人者人恒爱之，为众人报薪者，不可使其冻毙于风雪。如果自己想要得到救赎，那就去帮助别人，这样自己也能够得到救赎。这或许就是《clannad》和《若能与你再次相见》这两部作品想要传递的思想吧。<br><img src="https://picdm.sunbangyan.cn/2023/11/12/31f2ea6ea1442e3fc5951fe602354660.png" alt="7" /></p><hr><p>祝愿身陷囹圄的人们也能迎来属于自己的光。即使自己也身处阴影之中，也要把人推向光明。光明之处的朋友越多，自己离光明也就越近，谁说站在光里的才算英雄！感谢各位的观看，如果本期杂谈让你有所触动的话，推荐去游玩原作，一定会获得一场不错的体验。最后就用key社的另一位女主神北小毬的幸福螺旋理论来结束这篇杂谈吧：“如果你能幸福，我会很开心，看到别人幸福的样子，自己也会觉得幸福，我幸福的话，你也会很幸福，一直一直循环下去，最后啊，就会变成幸福螺旋了。”<br><img src="https://picdm.sunbangyan.cn/2023/11/12/fa27485e99e1489c17c2994fa53018b5.png" alt="8" /></p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序—选择排序</title>
      <link href="/posts/61129/"/>
      <url>/posts/61129/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://www.runoob.com/w3cnote/selection-sort.html">1.2 选择排序 | 菜鸟教程</a><br>数组、链表的基本操作都涉及到排序，排序有很多种，根据情况选择合适的算法即可。<br>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><h1 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h1><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="psc" style="zoom"/><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>就是每一次从未排序的所有元素中，“选出”最小（或最大）的，放在首位，然后递推其余未排序的元素，每一次都选出余下最小的。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="http://acm.zzuli.edu.cn/problem.php?cid=1908&pid=8">ZZULIOJ-Contest 1908-I: 混乱的成绩表</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Zero 是一名学习委员，他负责很多有关学习上的任务，今天辅导员给了他一张成绩单，这个成绩单是按学号排序的，但是它是成绩单，应该按成绩排序。Zero 作为一个 acmer，对排序还算了解，但他想考考你，你能完成这个任务吗？</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个正整数 n，代表成绩单上学生的人数(n &lt;= 2000)</span><br><span class="line">接下来 n 行，每行两个整数 ID 和 x，ID是学生的编号(递增给出），x 是学生成绩 (0 &lt;= x &lt;= 100)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出按成绩排名的成绩单，成绩越高，排名越靠前，相同成绩的人 ID 较小的排名在前</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 68</span><br><span class="line">2 68</span><br><span class="line">3 90</span><br><span class="line">4 91</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 91</span><br><span class="line">3 90</span><br><span class="line">1 68</span><br><span class="line">2 68</span><br></pre></td></tr></table></figure><h2 id="结构体代码-选择排序"><a href="#结构体代码-选择排序" class="headerlink" title="结构体代码 选择排序"></a>结构体代码 选择排序</h2><p><strong>考察点：结构体、排序</strong><br>很明显本题让我们对成绩排序，但难点在于每个人的成绩和学号是绑定在一起的，这个时候我们就有两种选择：</p><ul><li>两个数组，排序时一起交换这两数组的值</li><li>开一个结构体，排序时交换结构体的值</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id, soc;    <span class="comment">// 学号 成绩</span></span><br><span class="line">&#125;a[<span class="number">2001</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_select</span><span class="params">(<span class="keyword">struct</span> Student a[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i].id, &amp;a[i].soc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Sort_select(a, n);  <span class="comment">//调用函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a[i].id, a[i].soc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序的实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_select</span><span class="params">(<span class="keyword">struct</span> Student a[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">0</span>;   <span class="comment">// 是否需要排序，0 代表不需要，1 代表需要</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(a[i].soc &lt; a[j].soc)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;   <span class="comment">// 成绩较高的在前</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i].soc == a[j].soc &amp;&amp; a[i].id &gt; a[j].id)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;   <span class="comment">// 相同成绩，编号较小的在前</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">// 交换</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">t</span> =</span> a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组代码-选择排序"><a href="#数组代码-选择排序" class="headerlink" title="数组代码 选择排序"></a>数组代码 选择排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id[<span class="number">2001</span>], sco[<span class="number">2001</span>];    <span class="comment">// 1.为什么放外面？</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_select</span><span class="params">(<span class="type">int</span> n)</span>;    <span class="comment">// 2.函数定义为什么只有n？</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;id[i], &amp;sco[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Sort_select(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, id[i], sco[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序的实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_select</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 是否需要排序，0 代表不需要，1 代表需要</span></span><br><span class="line">            <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(sco[i] &lt; sco[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;   <span class="comment">// 成绩较高在前</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sco[i] == sco[j] &amp;&amp; sco[i] &gt; sco[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;   <span class="comment">// 相同成绩，编号较小的在前</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag)        <span class="comment">// 交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = id[i];</span><br><span class="line">                id[i] = id[j];</span><br><span class="line">                id[j] = t;</span><br><span class="line">                t = sco[i];</span><br><span class="line">                sco[i] = sco[j];</span><br><span class="line">                sco[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><h3 id="1-为什么数组放外面？"><a href="#1-为什么数组放外面？" class="headerlink" title="1. 为什么数组放外面？"></a>1. 为什么数组放外面？</h3><p>将数组定义放在main函数之外更好，因为这样可以使得<strong>数组在整个程序中都可见</strong>，而不仅仅是在main函数中可见。这样可以使得代码<strong>更加清晰易懂</strong>。如果数组定义在main函数内部，那么它的<strong>作用域</strong>就只在main函数内部，而在main函数外部就无法访问该数组。<br>此外，如果数组定义在main函数内部，那么它的内存分配在<strong>栈区</strong>内，而栈区的内存是比较小的。因此，如果数组比较大，就会出现<strong>爆出</strong>的问题，程序无法访问内存就会出错。相对的，如果数组定义在main函数外部，那么它的内存分配在<strong>数据区</strong>内，<strong>数据区的内存较大，所以开数组开在数据区&#x2F;main函数外面，就不易出现这样的问题。</strong></p><h3 id="2-数组中函数定义为什么只有n？"><a href="#2-数组中函数定义为什么只有n？" class="headerlink" title="2. 数组中函数定义为什么只有n？"></a>2. 数组中函数定义为什么只有n？</h3><p>因为数组在外面定义呀！<br>整个程序都可以访问，这样函数只需要一个数组长度的参数即可。</p><h3 id="3-为什么设立标志数flag？"><a href="#3-为什么设立标志数flag？" class="headerlink" title="3. 为什么设立标志数flag？"></a>3. 为什么设立标志数flag？</h3><p>因为题目要求<strong>成绩越高，排名越靠前</strong>，<strong>相同成绩的人 ID 较小的排名在前</strong>，有两处都需要排序，如果不设立标志数，这两处都需要排序，代码会重复。<br>设立flag是为了<strong>减少重复代码，增强可读性</strong>，满足flag就if语句进行交换即可。</p><h3 id="4-为什么结构体里交换只交换成绩而数组里成绩和序号都交换？"><a href="#4-为什么结构体里交换只交换成绩而数组里成绩和序号都交换？" class="headerlink" title="4. 为什么结构体里交换只交换成绩而数组里成绩和序号都交换？"></a>4. 为什么结构体里交换只交换成绩而数组里成绩和序号都交换？</h3><p>因为结构体是捆绑在一起的，学号和成绩一一对应。<br>而数组里不是，二者没有关系，只交换成绩序号全乱了。</p><hr><p><del>下集预告：冒泡排序（托更bushi）</del></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 排序和查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拖更计划（bushi)</title>
      <link href="/posts/35809/"/>
      <url>/posts/35809/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>记录以下后续想要写的内容，当成备忘录罢了。</strong><br>“总有一天，每个人会和这个故事告别，走向不同的方向，独属于你自己的下一页。但是那样就好，累了的话就停下脚步，怀念的话就回来看看这个故事也一直都在。且行且看，尽力而为，不要害怕，不要后悔。”<br><del>另外我发现，在vc和typora里[TOC]会直接生成目录，但在blog里只显示“[TOC]”的文字……</del></p><h1 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h1><h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2><p>这东西第一次听，简单查了一下，应该是一种规范，主题文档的语言应该还是HTML？</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p><a href="https://www.bilibili.com/video/av271280711/">[自制双语字幕] 计算机教育缺失的一课(2020) - 第1讲 - 课程概览与 shell</a><br>hexo clean和Linux这类的命令最初应该都是shell相关吧，涉及到命令应该都离不开shell</p><h2 id="cmd-powershell"><a href="#cmd-powershell" class="headerlink" title="cmd &#x2F; powershell"></a>cmd &#x2F; powershell</h2><p>这俩东西我也不了解，但很多操作都是通过这俩完成的，还有跟shell、bash有什么关系、区别……</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>作业……</p><h2 id="十大排序"><a href="#十大排序" class="headerlink" title="十大排序"></a>十大排序</h2><p><a href="https://www.runoob.com/w3cnote/sort-algorithm-summary.html">排序算法总结 | 菜鸟教程</a><br><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">1.0 十大经典排序算法 | 菜鸟教程</a><br>冒泡、选择、插入、选择、希尔、归并、快速、堆、计数、桶、基数排序。<br>我就学了选择和冒泡。</p><h2 id="十大编程算法"><a href="#十大编程算法" class="headerlink" title="十大编程算法"></a>十大编程算法</h2><p><a href="https://www.runoob.com/w3cnote/the-friendship-algorithm-the-big-bang-theory.html">十大编程算法助程序员走上高手之路 | 菜鸟教程</a></p><h1 id="English"><a href="#English" class="headerlink" title="English"></a>English</h1><p><a href="https://www.runoob.com/w3cnote/common-english-terminology-in-programming.html">编程常用英语词汇 | 菜鸟教程</a></p><h1 id="ACGN"><a href="#ACGN" class="headerlink" title="ACGN"></a>ACGN</h1><h2 id="Lovelive-虹咲"><a href="#Lovelive-虹咲" class="headerlink" title="Lovelive 虹咲"></a>Lovelive 虹咲</h2><h2 id="少女歌剧"><a href="#少女歌剧" class="headerlink" title="少女歌剧"></a>少女歌剧</h2><h1 id="生活日常"><a href="#生活日常" class="headerlink" title="生活日常"></a>生活日常</h1>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归档（拖更√） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归—汉诺塔</title>
      <link href="/posts/53020/"/>
      <url>/posts/53020/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/av6159200?p=57">57 _ 递归8 _ 汉诺塔_1_哔哩哔哩</a><br>趁热打铁，记录下来，后续有什么再补充。</p><h1 id="问题引入："><a href="#问题引入：" class="headerlink" title="问题引入："></a>问题引入：</h1><img src="https://picdl.sunbangyan.cn/2023/11/07/9d9308fa088968e70158787c10947a68.jpg" alt="递归汉诺塔3" style="zoom:70%"/><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><img src="https://picdl.sunbangyan.cn/2023/11/07/17ec6792727493ca736a229f19d637b9.jpg" alt="递归_汉诺塔" style="zoom:70%"/>主要是运用递归的思想。将规模为n的问题转为为规模为n-1的问题，直到可以一步解决。<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">如果是1个盘子</span><br><span class="line"><span class="code">    直接将A柱子上的盘子移到C上</span></span><br><span class="line"><span class="code">否则</span></span><br><span class="line"><span class="code">    先将A柱子上的n-1个盘子借助C移到B</span></span><br><span class="line"><span class="code">    直接将A柱子上编号为n的盘子移到C</span></span><br><span class="line"><span class="code">    最后将B柱子上的n-1个盘子借助A移到C</span></span><br></pre></td></tr></table></figure><h1 id="C版本："><a href="#C版本：" class="headerlink" title="C版本："></a>C版本：</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-11-7 22:12:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//依次表示 要移动的盘子个数、盘子所在柱子、借助的柱子、目标柱子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hannuota</span><span class="params">( <span class="type">int</span> n, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义三个柱子 和 要移动的盘子个数</span></span><br><span class="line"><span class="type">char</span> ch1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> ch2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="type">char</span> ch3 = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入要移动的盘子个数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">Hannuota(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hannuota</span><span class="params">( <span class="type">int</span> n, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( n == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;将编号为%d的盘子从%c直接移到%c上\n&quot;</span>, n, A, C);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Hannuota( n - <span class="number">1</span>, A, C, B );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;将编号为%d的盘子从%c直接移到%c上\n&quot;</span>, n, A, C);</span><br><span class="line">Hannuota( n - <span class="number">1</span>, B, A, C );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><ul><li><code>void Hannuota( int n, char A, char B, char C );</code><br>在这里，A、B、C仅仅是参数名字，并不是代表从A借助B移到C，因为递归过程中会出现从B借助A移到C的情况。</li></ul><p><strong>郝斌老师：</strong></p><ul><li>一次要想看懂是不可能的，必须下去多练多看，慢慢的就会感觉跟1+1一样简单了。</li><li>要不停地去想为什么，真的是这样写的吗，别人告诉我的一定正确吗，有没有更好的方法，必须多问为什么，去思考。<img src="https://picss.sunbangyan.cn/2023/11/07/e9b3379325464b31ab56aa0ed0e75544.jpg" alt="递归汉诺塔4" style="zoom:70%"/></li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇总】学习教程</title>
      <link href="/posts/64685/"/>
      <url>/posts/64685/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基础语言"><a href="#基础语言" class="headerlink" title="基础语言"></a>基础语言</h1><h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/">C# 文档 - 入门、教程、参考。 | Microsoft Learn</a></p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p><a href="https://www.bilibili.com/video/av271280711/">[自制双语字幕] 计算机教育缺失的一课(2020) - 第1讲 - 课程概览与 shell</a></p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><p><a href="https://www.bilibili.com/video/BV1qh411p7Sa/?vd_source=200eb9ec89309b331e61b367cc247a68">C++ 教程 - 油管大佬The Cherno C++ 教程</a></p><p><a href="https://www.bilibili.com/video/BV1Dd4y1R7VS/?vd_source=200eb9ec89309b331e61b367cc247a68">【中字精译】《为游戏编程学习C++》 C++入门教程</a></p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p><a href="https://zhuanlan.zhihu.com/p/344558356">【C++】标准模板库（STL）：超快入门！算法竞赛必看！- 知乎</a> —— 可惜大佬不更了······</p><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><h2 id="unity"><a href="#unity" class="headerlink" title="unity"></a>unity</h2><p><a href="https://docs.unity3d.com/Manual/index.html">英文 - Unity User Manual 2022.3</a><br><a href="https://docs.unity.cn/cn/2019.4/Manual/ManualVersions.html">中文 - Unity 手册</a></p><p><a href="https://gitee.com/chutianshu1981/AwesomeUnityTutorial">AwesomeUnityTutorial: 精选官方高质量教程作为入门学习内容</a><br><a href="https://space.bilibili.com/43644141/channel/series">白熊游戏-chutianbo视频专辑</a></p><h1 id="408"><a href="#408" class="headerlink" title="408"></a>408</h1><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p><a href="https://www.programmercarl.com/">代码随想录</a><br><a href="https://www.bilibili.com/video/av6159200/">【郝斌】-数据结构入门_哔哩哔哩</a><br><a href="https://www.bilibili.com/video/av92191094/">王道计算机考研 数据结构_哔哩哔哩</a><br><a href="https://www.bilibili.com/video/av974498314/">【小金鱼】2023王道数据结构课后算法题解析（第二章线性表）</a><br><a href="https://www.bilibili.com/video/av462193433/">【小金鱼】2023王道数据结构课后编程题解析（第三章栈和队列）</a><br><a href="https://www.bilibili.com/video/av632298013/">【小金鱼】2023王道数据结构课后编程题解析 (第5、6、7、8章)</a></p>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归档（拖更√） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验四  常用类和集合框架</title>
      <link href="/posts/50615/"/>
      <url>/posts/50615/</url>
      
        <content type="html"><![CDATA[<p>完成作业罢了。</p><h1 id="一、目的与任务"><a href="#一、目的与任务" class="headerlink" title="一、目的与任务"></a>一、目的与任务</h1><p>理解并掌握String类、StringBuffer类；掌握字符串与其他数据类型的转换掌握Math类的使用；了解和掌握集合框架；掌握Java Application命令行参数的使用。</p><h1 id="二、内容、要求与安排方式"><a href="#二、内容、要求与安排方式" class="headerlink" title="二、内容、要求与安排方式"></a>二、内容、要求与安排方式</h1><p>（1）编写程序，当以年-月-日的格式输入一个日期时，输出该年是否为闰年，该月有几天，该日是星期几。<br>（2）设计一个Student类，该类中包括学生的姓名和成绩。创建Student类的5个对象，如下所示：<br>姓名成绩<br>刘德华90<br>张学友80<br>刘杰65<br>章子怡100<br>周迅60<br>将以上5个对象放入LinkedList中，完成如下操作和统计：</p><ul><li>输出LinkedList中的对象个数。</li><li>删除姓名为“刘杰”的学生信息，并输出LinkedList中现有学生信息。</li><li>将姓名为“刘德华”的学生成绩改为95。</li><li>输出成绩不及格的学生姓名。</li></ul><p>（3）现有以下三个email地址”<a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#x67;&#115;&#x61;&#110;&#64;&#x73;&#111;&#104;&#x75;&#46;&#99;&#111;&#109;">&#x7a;&#104;&#x61;&#x6e;&#x67;&#115;&#x61;&#110;&#64;&#x73;&#111;&#104;&#x75;&#46;&#99;&#111;&#109;</a>”、”<a href="mailto:&#108;&#x69;&#x73;&#x69;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;">&#108;&#x69;&#x73;&#x69;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a>”、”<a href="mailto:&#x77;&#97;&#110;&#103;&#x77;&#x75;&#64;&#x73;&#105;&#110;&#x61;&#46;&#99;&#111;&#109;">&#x77;&#97;&#110;&#103;&#x77;&#x75;&#64;&#x73;&#105;&#110;&#x61;&#46;&#99;&#111;&#109;</a>”。需要把email中的用户部分和邮件地址部分分离（即将@前后部分分离），分离后以键值对应的方式存入HashMap中，并遍历输出。<br>（4）现有一段文本如下：“I&#x2F;have&#x2F;a&#x2F;dream&#x2F;今天&#x2F;天气&#x2F;晴朗&#x2F;万里&#x2F;无云&#x2F;I&#x2F;have&#x2F;a&#x2F;good&#x2F;idea&#x2F;今天&#x2F;天气&#x2F;不错”。试用HashMap实现对文本中出现的单词词频进行统计，并对统计结果进行输出显示，如“I：2”，表示单词“I”在文本中出现了两次。</p><h1 id="第（1）题"><a href="#第（1）题" class="headerlink" title="第（1）题"></a>第（1）题</h1><p>（1）编写程序，当以年-月-日的格式输入一个日期时，输出该年是否为闰年，该月有几天，该日是星期几。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这些行引入了程序所需的库，包括SimpleDateFormat（用于日期格式化）、Date（日期对象）和Calendar（日期操作）。</span></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateInfo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请以年-月-日的格式输入日期，例如：2023-10-31&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputDate</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> dateFormat.parse(inputDate);</span><br><span class="line">            <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">            calendar.setTime(date);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> calendar.get(Calendar.YEAR);</span><br><span class="line">            <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 月份从0开始，需要加1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否为闰年</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLeapYear</span> <span class="operator">=</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该月的天数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">daysInMonth</span> <span class="operator">=</span> calendar.getActualMaximum(Calendar.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该日是星期几</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK);</span><br><span class="line"></span><br><span class="line">            String[] dayOfWeekNames = &#123;<span class="string">&quot;星期日&quot;</span>, <span class="string">&quot;星期一&quot;</span>, <span class="string">&quot;星期二&quot;</span>, <span class="string">&quot;星期三&quot;</span>, <span class="string">&quot;星期四&quot;</span>, <span class="string">&quot;星期五&quot;</span>, <span class="string">&quot;星期六&quot;</span>&#125;;</span><br><span class="line">            <span class="type">String</span> <span class="variable">dayOfWeekName</span> <span class="operator">=</span> dayOfWeekNames[dayOfWeek - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            System.out.println(year + <span class="string">&quot;年是否为闰年: &quot;</span> + (isLeapYear ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;不是&quot;</span>));</span><br><span class="line">            System.out.println(month + <span class="string">&quot;月有 &quot;</span> + daysInMonth + <span class="string">&quot; 天&quot;</span>);</span><br><span class="line">            System.out.println(inputDate + <span class="string">&quot; 是 &quot;</span> + dayOfWeekName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;日期格式无效，请使用 yyyy-MM-dd 格式&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="概括程序"><a href="#概括程序" class="headerlink" title="概括程序"></a>概括程序</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">它接受用户输入的日期，然后根据输入的日期执行以下操作：</span><br><span class="line"></span><br><span class="line">1.判断输入的年份是否为闰年。</span><br><span class="line">2.获取输入月份的天数。</span><br><span class="line">3.确定输入的日期是星期几。</span><br><span class="line">此外，程序还包括了异常处理，以便在用户提供无效日期格式时提供错误消息。以下是对程序的概括：</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 使用 Scanner 从用户输入中获取日期。</span><br><span class="line"><span class="bullet">*</span> 使用 SimpleDateFormat 解析用户输入的日期。</span><br><span class="line"><span class="bullet">*</span> 使用 Calendar 类获取日期的年份、月份、日期等信息。</span><br><span class="line"></span><br><span class="line">根据计算，判断年份是否为闰年。</span><br><span class="line">使用 getActualMaximum 方法获取月份的天数。</span><br><span class="line">使用数组来存储星期的名称，然后根据计算的星期值找到相应的名称。</span><br><span class="line">输出结果，包括年份是否为闰年、月份的天数和输入日期的星期。</span><br><span class="line">这个程序是一个很好的示例，展示了如何使用Java处理日期和用户输入，以及如何实施异常处理来提高程序的健壮性。</span><br></pre></td></tr></table></figure><h2 id="java库是什么，怎么知道该用哪个库？"><a href="#java库是什么，怎么知道该用哪个库？" class="headerlink" title="java库是什么，怎么知道该用哪个库？"></a>java库是什么，怎么知道该用哪个库？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Java库（Java libraries）是Java编程语言提供的预定义类和方法的集合，用于执行各种任务和操作。这些库被设计为通用工具，以便开发者可以轻松地处理常见任务，而无需从头开始编写所有代码。Java库包括了各种用途的类和方法，例如日期处理、文件操作、网络通信、图形界面、数据结构、数据库连接等。</span><br><span class="line"></span><br><span class="line">在Java编程中，您可以通过导入库中的类来使用库中的功能。以下是一些常见的Java库和用途：</span><br><span class="line"></span><br><span class="line">java.util： 提供了用于数据结构（如集合、列表、队列、堆栈）、日期和时间处理的类。</span><br><span class="line">java.io： 用于文件输入输出的类，允许您读取和写入文件。</span><br><span class="line">java.net： 用于网络通信的类，包括Socket、URL等，可用于创建网络应用程序。</span><br><span class="line">java.awt和javax.swing： 用于创建图形用户界面（GUI）的类和组件。</span><br><span class="line">java.sql： 用于数据库连接和执行SQL查询的类。</span><br><span class="line">java.lang： 包含Java的基本类，如String、Object、Math等，这些类无需显式导入，可以直接使用。</span><br><span class="line">java.nio： 提供了新I/O系统，用于高性能的文件和网络I/O操作。</span><br><span class="line">java.util.concurrent： 用于并发编程的类，如线程池、锁等。</span><br><span class="line"></span><br><span class="line">根据您的任务和需求，选择合适的库来简化编程工作。通常，可以在Java文档中找到每个库和类的详细信息，以帮助了解它们的功能和用法。同时，IDE（如IntelliJ IDEA）通常会提供自动导入库的功能，以简化库的使用。</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br></pre></td></tr></table></figure><p>这一行创建了一个 SimpleDateFormat 对象，用于将输入的日期字符串解析为日期对象。”yyyy-MM-dd” 是日期格式的模式，它表示年-月-日的格式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> dateFormat.parse(inputDate);</span><br></pre></td></tr></table></figure><p>在 try 块中，程序尝试将输入的日期字符串解析为 Date 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.setTime(date);</span><br></pre></td></tr></table></figure><p>这里创建了一个 Calendar 对象，用于执行日期操作。calendar.setTime(date) 设置日历对象的日期为解析后的日期对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> calendar.get(Calendar.YEAR);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 月份从0开始，需要加1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br></pre></td></tr></table></figure><p>这些代码行从 Calendar 对象中提取年、月和日的信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isLeapYear</span> <span class="operator">=</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这一行判断输入的年份是否为闰年。它根据闰年的规则进行判断，如果符合规则，则 isLeapYear 变量为 true，否则为 false。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">daysInMonth</span> <span class="operator">=</span> calendar.getActualMaximum(Calendar.DAY_OF_MONTH);</span><br></pre></td></tr></table></figure><p>这一行获取了输入日期所在月份的天数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK);</span><br></pre></td></tr></table></figure><p>这一行获取了输入日期是星期几，其中星期日是1，星期一是2，以此类推。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] dayOfWeekNames = &#123;<span class="string">&quot;星期日&quot;</span>, <span class="string">&quot;星期一&quot;</span>, <span class="string">&quot;星期二&quot;</span>, <span class="string">&quot;星期三&quot;</span>, <span class="string">&quot;星期四&quot;</span>, <span class="string">&quot;星期五&quot;</span>, <span class="string">&quot;星期六&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">dayOfWeekName</span> <span class="operator">=</span> dayOfWeekNames[dayOfWeek - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这些代码用于将星期数字转换为星期的文本名称，例如将数字1转换为”星期日”。<br>最后，程序将结果输出到控制台，包括年份是否为闰年、月份的天数和输入日期的星期。</p><h2 id="第（2）题"><a href="#第（2）题" class="headerlink" title="第（2）题"></a>第（2）题</h2><p>（2）设计一个Student类，该类中包括学生的姓名和成绩。创建Student类的5个对象，如下所示：<br>姓名成绩<br>刘德华90<br>张学友80<br>刘杰65<br>章子怡100<br>周迅60<br>将以上5个对象放入LinkedList中，完成如下操作和统计：</p><ul><li>输出LinkedList中的对象个数。</li><li>删除姓名为“刘杰”的学生信息，并输出LinkedList中现有学生信息。</li><li>将姓名为“刘德华”的学生成绩改为95。</li><li>输出成绩不及格的学生姓名。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentManagement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个LinkedList并添加5个Student对象</span></span><br><span class="line">        LinkedList&lt;Student&gt; studentList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Student&gt;();</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;刘德华&quot;</span>, <span class="number">90</span>));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张学友&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;刘杰&quot;</span>, <span class="number">65</span>));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;章子怡&quot;</span>, <span class="number">100</span>));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周迅&quot;</span>, <span class="number">60</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出LinkedList中的对象个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedList中的对象个数: &quot;</span> + studentList.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除姓名为“刘杰”的学生信息</span></span><br><span class="line">        Iterator&lt;Student&gt; iterator = studentList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (student.getName().equals(<span class="string">&quot;刘杰&quot;</span>)) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出LinkedList中现有学生信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除“刘杰”后的学生信息:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + student.getName() + <span class="string">&quot;, 成绩: &quot;</span> + student.getScore());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将姓名为“刘德华”的学生成绩改为95</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getName().equals(<span class="string">&quot;刘德华&quot;</span>)) &#123;</span><br><span class="line">                student.setScore(<span class="number">95</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出成绩不及格的学生姓名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;成绩不及格的学生姓名:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getScore() &lt; <span class="number">60</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;姓名: &quot;</span> + student.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第（3）题"><a href="#第（3）题" class="headerlink" title="第（3）题"></a>第（3）题</h2><p>（3）现有以下三个email地址”<a href="mailto:&#x7a;&#104;&#97;&#110;&#103;&#x73;&#97;&#110;&#64;&#x73;&#111;&#104;&#117;&#x2e;&#x63;&#111;&#109;">&#x7a;&#104;&#97;&#110;&#103;&#x73;&#97;&#110;&#64;&#x73;&#111;&#104;&#117;&#x2e;&#x63;&#111;&#109;</a>”、”<a href="mailto:&#108;&#105;&#115;&#105;&#64;&#49;&#x36;&#x33;&#46;&#99;&#111;&#109;">&#108;&#105;&#115;&#105;&#64;&#49;&#x36;&#x33;&#46;&#99;&#111;&#109;</a>”、”<a href="mailto:&#119;&#97;&#x6e;&#x67;&#x77;&#x75;&#64;&#x73;&#105;&#x6e;&#97;&#x2e;&#99;&#111;&#x6d;">&#119;&#97;&#x6e;&#x67;&#x77;&#x75;&#64;&#x73;&#105;&#x6e;&#97;&#x2e;&#99;&#111;&#x6d;</a>”。需要把email中的用户部分和邮件地址部分分离（即将@前后部分分离），分离后以键值对应的方式存入HashMap中，并遍历输出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProject</span>: Lab_4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsPackage</span>: EmailParser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Shiel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> 2023/10/31 13:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailParser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个HashMap来存储email地址的用户部分和邮件地址部分</span></span><br><span class="line">        HashMap&lt;String, String&gt; emailMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加email地址到HashMap</span></span><br><span class="line">        emailMap.put(<span class="string">&quot;zhangsan@sohu.com&quot;</span>, <span class="string">&quot;用户部分: zhangsan, 邮件地址部分: sohu.com&quot;</span>);</span><br><span class="line">        emailMap.put(<span class="string">&quot;lisi@163.com&quot;</span>, <span class="string">&quot;用户部分: lisi, 邮件地址部分: 163.com&quot;</span>);</span><br><span class="line">        emailMap.put(<span class="string">&quot;wangwu@sina.com&quot;</span>, <span class="string">&quot;用户部分: wangwu, 邮件地址部分: sina.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历HashMap并输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (String email : emailMap.keySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> emailMap.get(email);</span><br><span class="line">            System.out.println(email + <span class="string">&quot; -&gt; &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第（4）题"><a href="#第（4）题" class="headerlink" title="第（4）题"></a>第（4）题</h2><p>（4）现有一段文本如下：“I&#x2F;have&#x2F;a&#x2F;dream&#x2F;今天&#x2F;天气&#x2F;晴朗&#x2F;万里&#x2F;无云&#x2F;I&#x2F;have&#x2F;a&#x2F;good&#x2F;idea&#x2F;今天&#x2F;天气&#x2F;不错”。试用HashMap实现对文本中出现的单词词频进行统计，并对统计结果进行输出显示，如“I：2”，表示单词“I”在文本中出现了两次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProject</span>: Lab_4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsPackage</span>: WordFrequency</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Shiel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> 2023/10/31 13:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordFrequency</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;I/have/a/dream/今天/天气/晴朗/万里/无云/I/have/a/good/idea/今天/天气/不错&quot;</span>;</span><br><span class="line">        String[] words = text.split(<span class="string">&quot;/&quot;</span>); <span class="comment">// 使用斜杠分割文本</span></span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Integer&gt; wordFrequencyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">// 如果单词已经在HashMap中存在，增加词频；否则，将词频设置为1</span></span><br><span class="line">            <span class="keyword">if</span> (wordFrequencyMap.containsKey(word)) &#123;</span><br><span class="line">                wordFrequencyMap.put(word, wordFrequencyMap.get(word) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wordFrequencyMap.put(word, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历HashMap并输出统计结果</span></span><br><span class="line">        <span class="keyword">for</span> (String word : wordFrequencyMap.keySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> wordFrequencyMap.get(word);</span><br><span class="line">            System.out.println(word + <span class="string">&quot;：&quot;</span> + frequency);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/posts/42877/"/>
      <url>/posts/42877/</url>
      
        <content type="html"><![CDATA[<p><strong>观前提示</strong>：以下内容均为<a href="https://zh.moegirl.org.cn/%E5%A4%A9%E7%8E%8B%E5%AF%BA%E7%92%83%E5%A5%88">天王寺科技</a>所属。<del>与本人无任何联系。</del><br><del><strong>下集预告</strong>：十大排序——选择排序</del></p><h1 id="参考网站："><a href="#参考网站：" class="headerlink" title="参考网站："></a>参考网站：</h1><p><a href="https://www.programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录-二分查找</a><br><a href="https://www.runoob.com/w3cnote/the-friendship-algorithm-the-big-bang-theory.html">十大编程算法助程序员走上高手之路 | 菜鸟教程</a><br><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找 - 力扣（LeetCode）</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在引入二分查找之前，先来想一个问题：在一个有序、无重复数组中 <strong>（想一想，为什么要求有序且无重复元素？）</strong>，给一个目标值，要求定义一个函数返回此目标值在数组中的下标。<br>可能你脑海中第一印象是，遍历数组，依次比较目标值是否与每一个元素相等，相等就返回下标。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> length, <span class="type">int</span> target )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( target == a[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><p>这种写法遍历每一个元素，太浪费时间，需要额外的内存，但易理解，那么使用二分不失为一种好方法：<br><strong>二分查找</strong>算法是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，</p><ul><li>如果中间元素正好是要查找的元素，则搜索过程结束；</li><li>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。</li><li>如果在某一步骤数组 为空则代表找不到。<br>这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(log n) 。</li></ul><h1 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h1><ul><li>数组元素必须有序</li><li>数组中不能有重复元素，必须保证返回值唯一</li></ul><h1 id="详解："><a href="#详解：" class="headerlink" title="详解："></a>详解：</h1><p>二分搜索也称为二分查找或折半查找，它充分利用了元素间的次序关系，采用分治策略，<br>可在最坏的情况下用 O(log n)完成搜索任务。它的基本思想是，将 n 个元素分成数量大致相同<br>的两部分，取 a[n&#x2F;2]与欲查找的 x 作比较，如果 x&#x3D;&#x3D;a[n&#x2F;2]则找到 x，算法终止。如果 x＜a[n&#x2F;2]，<br>则我们只要在数组 a 的左半部继续搜索 x（这里假设数组元素呈升序排列）。如果 x＞a[n&#x2F;2]，<br>则我们只要在数组 a 的右半部继续搜索 x。<br>二分搜索过程可以描述为以下递归过程：<br>若待搜区间为空，返回-1；<br>否则<br>mid &#x3D; (low+high)&#x2F;2;<br>若 x 等于 a[mid]，搜索成功，返回 mid；<br>若 x 小于 a[mid]，在左半区间搜索；<br>若 x 大于 a[mid]，在右半区间搜索； </p><h1 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h1><h2 id="1、左闭右闭："><a href="#1、左闭右闭：" class="headerlink" title="1、左闭右闭："></a>1、左闭右闭：</h2><img src="https://picss.sunbangyan.cn/2023/11/07/363a51df2f28492697e54ff56c6d351f.png" alt="二分查找1" /><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> length, <span class="type">int</span> target )</span>&#123;  <span class="comment">//传入数组首地址、长度、待搜索目标值</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = length<span class="number">-1</span>;                   <span class="comment">//因为左闭右闭，所以数组下标为[0, length - 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( left &lt;= right )</span><br><span class="line">        &#123;     <span class="comment">//因为左闭右闭，所以是 &lt;= ，left = right 是允许的</span></span><br><span class="line"><span class="type">int</span> middle = left + (right - left) / <span class="number">2</span>;     <span class="comment">//防止middle长度越界</span></span><br><span class="line"><span class="keyword">if</span>( target &lt; a[middle] )&#123;       <span class="comment">//目标值在middle左边</span></span><br><span class="line">right = middle - <span class="number">1</span>;     <span class="comment">//更新右边界</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( target &gt; a[middle] )&#123;</span><br><span class="line">left = middle + <span class="number">1</span>;        <span class="comment">//更新左边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> middle;          <span class="comment">//即target=a[middle]，说明查找成功，则返回目标值下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">//未找到目标值，返回 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、左闭右开："><a href="#2、左闭右开：" class="headerlink" title="2、左闭右开："></a>2、左闭右开：</h2><img src="https://picdm.sunbangyan.cn/2023/11/07/a19c7cac17b1d9150056163d351f7188.png" alt="二分查找2" /><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> length, <span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = length;         <span class="comment">//因为左闭右开，所以数组下标为[0, length)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt; right )      <span class="comment">//因为左闭右开，所以是 &lt; ，而left = right是不允许的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> middle = left + ( right - left ) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( target &lt; a[middle] )&#123;</span><br><span class="line">            right = middle;         <span class="comment">//更新右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( target &gt; a[middle] )&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;      <span class="comment">//更新左边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;         <span class="comment">//说明查找成功，返回下标值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;       <span class="comment">//未找到目标值，返回 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="要注意的问题"><a href="#要注意的问题" class="headerlink" title="要注意的问题"></a>要注意的问题</h1><h2 id="为什么分为左闭右闭和左闭右开？"><a href="#为什么分为左闭右闭和左闭右开？" class="headerlink" title="为什么分为左闭右闭和左闭右开？"></a>为什么分为左闭右闭和左闭右开？</h2><p>我也不知道，反正就是这么规定的，记住就行了，其实也就是两种情况罢了。<br>每一种情况必须牢记到底是二分的哪种情况，是[ 左闭右闭 ]，还是[ 左闭右开 )，不然程序你是看不懂的，更不要说写了。</p><h2 id="区间的定义"><a href="#区间的定义" class="headerlink" title="区间的定义"></a>区间的定义</h2><ul><li><strong>左闭右闭时，为什么left&lt;&#x3D; right？左闭右开时，为什么left &lt; right？</strong><br>首先，target 所在的区间即为 left 和 right 之间。把它当成数学的区间看待，那么此区间必须是有意义的。<br><strong>不论哪种情况，right最大所能取到的值都不能越界、区间都要有意义。</strong><br>左闭右闭：<br>left &lt;&#x3D; right是有意义的，因为[left, right]是一个有效区间，可以取到。</li><li><strong>左闭右开 以此类推</strong>。</li></ul><h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><ul><li>**左闭右闭时，为什么target &lt;&#x3D; a[middle]时，right &#x3D; middle - 1？而左闭右开却不是？**<br>还是区间是否有效的问题。<br>target &lt; a[middle] 时，right &#x3D; middle - 1：因为是闭区间[ ]，右边界是可以取到的；而 &lt; 说明target不在此区间，我们要更新查找的空间，即在此区间的左区间，即 middle - 1。如果是middle，那更新了个寂寞……<br>target &gt; a[middle] 时，right &#x3D; middle + 1：由上面分析可知，这次要更新的是右区间了，即middle + 1。</li><li><strong>左闭右开</strong><br>这种情况，是[ )了，右区间是取不到的，更新时就要注意了，动手在纸上画画吧！</li></ul><hr><p>好了，你已经学会二分了，快去敲代码试试吧！</p><h1 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">( vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target )</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right )&#123;</span><br><span class="line">          <span class="type">int</span> middle = left + ( right - left ) / <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span>( target &lt; nums[middle] )&#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; nums[middle] )&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">( vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target )</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( left &lt; right )&#123;</span><br><span class="line">          <span class="type">int</span> middle = left + ( right - left ) / <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span>( target &lt; nums[middle] )&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; nums[middle] )&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 排序和查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续存储数组的算法演示</title>
      <link href="/posts/35130/"/>
      <url>/posts/35130/</url>
      
        <content type="html"><![CDATA[<p>郝斌老师数据结构视频学习记录。<br>涉及到数组的初始化、插入、删除、查找、翻转、排序等。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. 讲数组是为了讲泛型：</span></span><br><span class="line"><span class="comment">    存储不一样，操作就不一样；</span></span><br><span class="line"><span class="comment">    而泛型达到的效果是：存储不一样，但操作一样</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  2. 试数，画图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span><span class="comment">//包含了malloc函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">//包含了exit函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>* pBase;     <span class="comment">//存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> len;        <span class="comment">//数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> cnt;        <span class="comment">//当前数组有效元素的个数</span></span><br><span class="line">&#125;;                  <span class="comment">//分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> len)</span>;   <span class="comment">//初始化数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>;    <span class="comment">//获取下标</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_empty</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>;    <span class="comment">//判断数组是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_full</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>;     <span class="comment">//判断数组是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Append_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>;     <span class="comment">//追加</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> pos, <span class="type">int</span> val)</span>;    <span class="comment">//插入,pos从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span>;     <span class="comment">//删除</span></span><br><span class="line"><span class="comment">//如果用int，无法判断是否删除成功。bool不能返回删除的值，所以只能用指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Inversion_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>;   <span class="comment">//翻转，倒置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>;        <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span> <span class="title">arr</span>;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    </span><br><span class="line">    Init_arr(&amp;arr, <span class="number">6</span>);</span><br><span class="line">    Show_arr(&amp;arr);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">1</span>);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">10</span>);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">-3</span>);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">6</span>);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">88</span>);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">11</span>);</span><br><span class="line">    </span><br><span class="line">    Get_arr(&amp;arr, <span class="number">4</span>);</span><br><span class="line">    Insert_arr(&amp;arr, <span class="number">6</span>, <span class="number">99</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把val的地址发给pVal,在函数内部可以通过它修改val的值</span></span><br><span class="line">    <span class="keyword">if</span>( Delete_arr(&amp;arr, <span class="number">4</span>, &amp;val) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除的元素是：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    if( Append_arr(&amp;arr, 7) )&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;追加成功！\n&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;追加失败\n&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Show_arr(&amp;arr);</span><br><span class="line">    Inversion_arr(&amp;arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;倒置之后的数组内容是：\n&quot;</span>);</span><br><span class="line">    Show_arr(&amp;arr);</span><br><span class="line">    Sort_arr(&amp;arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组内容是:\n&quot;</span>);</span><br><span class="line">    Show_arr(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* len);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pArr-&gt;pBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态分配内存失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);   <span class="comment">//终止整个程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pArr-&gt;len = len;</span><br><span class="line">        pArr-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;     <span class="comment">//表示此函数终止了，增强可读性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Is_empty(pArr) )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取下标失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;cnt; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pArr-&gt;pBase[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d的数组下标为：&quot;</span>, val);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_empty</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == pArr-&gt;cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_full</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pArr-&gt;cnt == pArr-&gt;len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>&#123;<span class="comment">//此处的pArr来自arr，即结构体变量地址</span></span><br><span class="line">    <span class="keyword">if</span>(Is_empty(pArr))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//*pArr错误，此处应该接收结构体变量的地址，而pArr已经是了，不需要加*</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组为空!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pArr-&gt;pBase[i]);</span><br><span class="line">            <span class="comment">//pArr[i],(*pArr[i])错误，因为都不是数组名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Append_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="comment">//满时返回false</span></span><br><span class="line">    <span class="keyword">if</span>( Is_full(pArr) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//不满时追加</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//是cnt，不是cnt+1，不是cnt-1————试数，下标与数组关系</span></span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;cnt] = val;</span><br><span class="line">        (pArr-&gt;cnt)++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos的值从1开始，即插入后的次序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> pos, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Is_full(pArr))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos&gt;pArr-&gt;cnt+<span class="number">1</span>)<span class="comment">//pos不能为负，不能大于有效个数+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i的值-不用记，试数，画图就行了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pArr-&gt;cnt<span class="number">-1</span>; i&gt;=pos<span class="number">-1</span>; i--)&#123;</span><br><span class="line">        pArr-&gt;pBase[i+<span class="number">1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;pBase[pos<span class="number">-1</span>] = val;</span><br><span class="line">    (pArr-&gt;cnt)++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete_arr</span><span class="params">(<span class="keyword">struct</span> Arr * pArr, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Is_empty(pArr))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos&gt;pArr-&gt;cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    *pVal = pArr-&gt;pBase[pos<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos; i&lt;pArr-&gt;cnt; i++)&#123;</span><br><span class="line">        pArr-&gt;pBase[i<span class="number">-1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;cnt--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inversion_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;cnt/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[pArr-&gt;cnt<span class="number">-1</span>-i];</span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;cnt<span class="number">-1</span>-i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;cnt<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;pArr-&gt;cnt; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pArr-&gt;pBase[i] &gt; pArr-&gt;pBase[j])&#123;</span><br><span class="line">                t = pArr-&gt;pBase[i];</span><br><span class="line">                pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">                pArr-&gt;pBase[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>其中Inversion_arr翻转数组可以使用折半方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Inversion_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;cnt/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[pArr-&gt;cnt<span class="number">-1</span>-i];</span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;cnt<span class="number">-1</span>-i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于下面这种方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Inversion_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = pArr-&gt;cnt<span class="number">-1</span>, t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">        pArr-&gt;pBase[j] = t;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法并不是最优解，因为它需要使用额外的空间来存储输入的数组，即使是在原地翻转数组的情况下，交换的操作次数也更多。<br>而第一种方法更简洁的方法在不使用额外空间的情况下原地翻转数组，而且只需要一次遍历，每次将首尾元素进行交换，从而实现原地翻转数组。</p><p>下面再看查找数组，相信你已经猜到了，当然是二分啦！</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Get_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Is_empty(pArr) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取下标失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pArr-&gt;cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pArr-&gt;pBase[i] == val)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d的数组下标为：&quot;</span>, val);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方法是最笨、但也是最容易理解的方法，但是效率太低了。<br>那么就对它使用二分吧：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种：左闭右闭</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = pArr-&gt;cnt<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; pArr-&gt;pBase[middle])&#123;</span><br><span class="line">            right = middle<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; pArr-&gt;pBase[middle])&#123;</span><br><span class="line">            left = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种：左闭右开</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_arr_2</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = pArr-&gt;cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; pArr-&gt;pBase[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; pArr-&gt;pBase[middle])&#123;</span><br><span class="line">            left = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一颠（2）</title>
      <link href="/posts/14317/"/>
      <url>/posts/14317/</url>
      
        <content type="html"><![CDATA[<p><em><del>本系列全新命名：每日一癫 喵</del></em><br><em><del>激情赶稿！动力满满喵</del></em></p><hr><p>首先我不是米娅粉，但她真的很可爱。我对米娅确实没有什么幻想，毕竟我不是lovelive粉。但是该说不说的，米娅，真的可爱死了，<br>我真的不是lovelive粉。有一说一，我也确实说不喜欢米娅。因为这个企划确实是挺好看的，我就不是lovelive粉，但是怎么说，一看到她，心里就痒痒的，类似一种原始冲动，就像看到影视剧里看到多年未见的老友的重逢，一段崭新情缘的开端一样，激发人向美向善最淳朴的一面。就像登上山峰，目睹潮汐那般自然，仿佛冥冥之中自有天意就是一种朦胧的感觉，像伟大的革命友谊一样，令人憧憬，要是能和我牵个手就更好了，毕竟我不是米娅粉。</p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.wwfoOjPFvYg9Gg-QMZLFsAAAAA?pid=ImgDet&rs=1" alt="曲绘" title="曲绘" style="zoom: 60%;" /><p><a href="https://music.163.com/song?id=1960852861&userid=310905058">stars we chase——内田秀</a><br>TV动画《Love Live! 虹咲学园校园偶像同好会 第二季》第9集插曲</p><blockquote><ul><li><em>哪有二次元会听英文歌啊</em></li><li><em>Let’s restart it, you and me Walking on that new story 米娅唱完solo，打开岚珠心结以后，是栞子抱上了岚珠，米娅却只能在边上看着，真令人感慨，流水的CP，永恒的love triangle。</em></li><li><em>如果是萌p的话一切都合理起来了。</em></li><li><em>米娅饱含深情唱完stars we chase；岚珠：栞子是我唯一的朋友。</em></li><li><em>美国大帅哥表白中国直女，我为什么会做这样的梦？</em></li></ul></blockquote><p><strong>╯ 　乀<br>ヘ　  へ<br>　 ′<br>　 ﹀<br>步也挺好吗？</strong></p><hr><p>Ps: <strong>wyy</strong>你不要太过分了，最开始不需要vip的时候我就下载了，结果今天一听就只能试听了。你要说最开始就是vip我还能勉强接受变为试听，你然而中途变为vip，那我之前下载的全听不了了…</p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 发电 </tag>
            
            <tag> ACGN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/posts/22648/"/>
      <url>/posts/22648/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="markdown的使用说明"><a href="#markdown的使用说明" class="headerlink" title="markdown的使用说明"></a>markdown的使用说明</h1><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><blockquote><p>语法：# (一级标题)  ## (二级标题)  ### (三级标题) ……</p></blockquote><blockquote><p>代码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;# 这是一级标题</span><br><span class="line">&gt;## 这是二级标题</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:  </p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2></blockquote><blockquote><p>快捷键:</p><ul><li>Ctrl+数字1~6可以快速将选中的文本调成对应级别的标题</li><li>Ctrl+0可以快速将选中的文本调成普通文本</li><li>Ctrl+加号&#x2F;减号对标题级别进行加减</li></ul></blockquote><h2 id="二、段落"><a href="#二、段落" class="headerlink" title="二、段落"></a>二、段落</h2><h3 id="1、换行"><a href="#1、换行" class="headerlink" title="1、换行"></a>1、换行</h3><blockquote><p>代码:  </p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是一个段落</span><br><span class="line">&gt;这是一个段落</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果: </p><p>这是一个段落<br>这是一个段落</p></blockquote><h3 id="2、分割线"><a href="#2、分割线" class="headerlink" title="2、分割线"></a>2、分割线</h3><blockquote><p>语法:  —或者***+回车</p></blockquote><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;---或者<span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><hr></blockquote><h2 id="三、文字显示"><a href="#三、文字显示" class="headerlink" title="三、文字显示"></a>三、文字显示</h2><h3 id="1、字体"><a href="#1、字体" class="headerlink" title="1、字体"></a>1、字体</h3><blockquote><p>语法:</p><ul><li>粗体:  用一对双星号包裹</li><li>删除线:  用一对双飘号包裹</li><li>下划线:  用一对u标签包裹</li><li>斜体:  用一对单星号包裹</li><li>高亮:  用一对双等号包裹</li></ul></blockquote><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;<span class="strong">**这是粗体**</span></span><br><span class="line">&gt;~~这是删除线~~</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>这是下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line">&gt;<span class="emphasis">*这是斜体*</span></span><br><span class="line">&gt;==这是高亮==</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br><strong>这是粗体</strong><br><del>这是删除线</del><br><u>这是下划线</u><br><em>这是斜体</em><br>&#x3D;&#x3D;这是高亮&#x3D;&#x3D;</p></blockquote><blockquote><p>快捷键:</p><ul><li>加粗:  Ctrl+B</li><li>删除线:  Shift+Alt+5</li><li>下划线:  Ctrl+U</li><li>斜体:  Ctrl+I</li></ul></blockquote><h3 id="2、上下标"><a href="#2、上下标" class="headerlink" title="2、上下标"></a>2、上下标</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;x^2^</span><br><span class="line">&gt;H~2~O</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>x^2^<br>H<del>2</del>O</p></blockquote><h2 id="四、列表"><a href="#四、列表" class="headerlink" title="四、列表"></a>四、列表</h2><h3 id="1、无序列表"><a href="#1、无序列表" class="headerlink" title="1、无序列表"></a>1、无序列表</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;<span class="emphasis">*/-/+ +空格</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>1.只有同一级别:</p><ul><li>苹果</li><li>香蕉</li><li>橘子</li></ul><p>2.子集类:</p><ul><li>一级分类</li><li>二级分类 <ul><li>三级分类</li></ul></li></ul></blockquote><blockquote><p>快捷键:  Ctrl+Shift+]</p></blockquote><h3 id="2、有序列表"><a href="#2、有序列表" class="headerlink" title="2、有序列表"></a>2、有序列表</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;数字+.+空格</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><ol><li>第一个标题</li><li>第二个标题</li><li>第三个标题</li></ol><ul><li>子内容1<ul><li>子内容2</li></ul></li></ul><ol start="4"><li>第四个标题</li></ol></blockquote><blockquote><p>快捷键:  Ctrl+Shift+[</p></blockquote><h3 id="3、任务列表"><a href="#3、任务列表" class="headerlink" title="3、任务列表"></a>3、任务列表</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;- [ ] 吃早餐</span><br><span class="line">&gt;- [x] 背单词</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><ul><li><input disabled="" type="checkbox"> 吃早餐</li><li><input checked="" disabled="" type="checkbox"> 背单词</li></ul></blockquote><h2 id="五、区块显示"><a href="#五、区块显示" class="headerlink" title="五、区块显示"></a>五、区块显示</h2><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;&gt;+回车</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><blockquote><p>这是最外层区块</p></blockquote><blockquote><blockquote><p>这是内层区块</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>这是最内层区块</p></blockquote></blockquote></blockquote></blockquote><h2 id="六、代码显示"><a href="#六、代码显示" class="headerlink" title="六、代码显示"></a>六、代码显示</h2><h3 id="1、行内代码"><a href="#1、行内代码" class="headerlink" title="1、行内代码"></a>1、行内代码</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;<span class="code">`int a=0;`</span>（说明：`位于Esc下面）</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br><code>int a=0;</code></p></blockquote><blockquote><p>快捷键:  Ctrl+Shift+&#96;</p></blockquote><h3 id="2、代码块"><a href="#2、代码块" class="headerlink" title="2、代码块"></a>2、代码块</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;<span class="code">```js/java/c#/text</span></span><br><span class="line"><span class="code">&gt;内容</span></span><br><span class="line"><span class="code">&gt;```</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>快捷键:  Ctrl+Shift+K</p></blockquote><h2 id="七、链接"><a href="#七、链接" class="headerlink" title="七、链接"></a>七、链接</h2><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;www.baidu.com</span><br><span class="line">&gt;[<span class="string">百度一下</span>](<span class="link">https://www.baidu.com</span>)</span><br><span class="line">&gt;[<span class="string">百度一下</span>](<span class="link">https://www.baidu.com &quot;https://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br><a href="http://www.baidu.com/">www.baidu.com</a><br><a href="https://www.baidu.com/">百度一下</a><br><a href="https://www.baidu.com/" title="https://www.baidu.com">百度一下</a></p></blockquote><blockquote><p>快捷键:  Ctrl+K</p></blockquote><h2 id="八、脚注"><a href="#八、脚注" class="headerlink" title="八、脚注"></a>八、脚注</h2><blockquote><p>说明:  对文本进行解释说明。</p></blockquote><blockquote><p>代码: </p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;[^文本]</span><br><span class="line">&gt;[^文本]:解释说明</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>这是一个技术<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%E6%A1%86%E6%9E%B6%E3%80%82">^①</a></p></blockquote><h2 id="九、图片插入"><a href="#九、图片插入" class="headerlink" title="九、图片插入"></a>九、图片插入</h2><blockquote><p>代码:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;![不显示的文字](图片路径 &quot;图片标题&quot;)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br><img src="D:\001-changyong\001-xuexiwenjian\壁纸.webp" alt="This is a picture"></p><p>(注：效果路径为C:\Users\asus\Pictures\Saved Pictures\Snipaste_2020-09-03_13-19-11.png。在其他电脑上可能不显示。)</p></blockquote><blockquote><p>快捷键:  Ctrl+Shift+I</p></blockquote><h2 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h2><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;|  1   |  2   |  3   |</span><br><span class="line">&gt;| :--- | :--: | ---: |</span><br><span class="line">&gt;|  4   |  5   |  6   |</span><br><span class="line">&gt;|  7   |  8   |  9   |</span><br><span class="line">&gt;|  10  |  11  |  12  |</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><table><thead><tr><th>1</th><th align="center">2</th><th align="right">3</th></tr></thead><tbody><tr><td>4</td><td align="center">5</td><td align="right">6</td></tr><tr><td>7</td><td align="center">8</td><td align="right">9</td></tr><tr><td>10</td><td align="center">11</td><td align="right">12</td></tr></tbody></table></blockquote><blockquote><p>快捷键:  Ctrl+T</p></blockquote><h2 id="十一、流程图"><a href="#十一、流程图" class="headerlink" title="十一、流程图"></a>十一、流程图</h2><h3 id="1、横向流程图"><a href="#1、横向流程图" class="headerlink" title="1、横向流程图"></a>1、横向流程图</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph LR</span></span><br><span class="line"><span class="code">A[方形]==&gt;B(圆角)</span></span><br><span class="line"><span class="code">B==&gt;C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">C--&gt;|a=1|D[结果1]</span></span><br><span class="line"><span class="code">C--&gt;|a=2|E[结果2]</span></span><br><span class="line"><span class="code">F[横向流程图]</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;graph LR</span><br><span class="line">&gt;A[方形]==&gt;B(圆角)</span><br><span class="line">&gt;B==&gt;C&#123;条件a&#125;</span><br><span class="line">&gt;C--&gt;|a=1|D[结果1]</span><br><span class="line">&gt;C--&gt;|a=2|E[结果2]</span><br><span class="line">&gt;F[横向流程图]</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、竖向流程图"><a href="#2、竖向流程图" class="headerlink" title="2、竖向流程图"></a>2、竖向流程图</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph TD</span></span><br><span class="line"><span class="code">A[方形]==&gt;B(圆角)</span></span><br><span class="line"><span class="code">B==&gt;C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">C--&gt;|a=1|D[结果1]</span></span><br><span class="line"><span class="code">C--&gt;|a=2|E[结果2]</span></span><br><span class="line"><span class="code">F[竖向流程图]</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;graph TD</span><br><span class="line">&gt;A[方形]==&gt;B(圆角)</span><br><span class="line">&gt;B==&gt;C&#123;条件a&#125;</span><br><span class="line">&gt;C--&gt;|a=1|D[结果1]</span><br><span class="line">&gt;C--&gt;|a=2|E[结果2]</span><br><span class="line">&gt;F[竖向流程图]</span><br></pre></td></tr></table></figure></blockquote><h2 id="十二、表情符号"><a href="#十二、表情符号" class="headerlink" title="十二、表情符号"></a>十二、表情符号</h2><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;:happy:、:cry:、:man:</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>:happy:、 :cry:、 :man:</p></blockquote><h2 id="十三、数学公式的输入"><a href="#十三、数学公式的输入" class="headerlink" title="十三、数学公式的输入"></a>十三、数学公式的输入</h2><h3 id="1、公式的插入"><a href="#1、公式的插入" class="headerlink" title="1、公式的插入"></a>1、公式的插入</h3><h4 id="①行中公式"><a href="#①行中公式" class="headerlink" title="①行中公式"></a>①行中公式</h4><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$公式$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$公式$</p></blockquote><h4 id="②独立公式"><a href="#②独立公式" class="headerlink" title="②独立公式"></a>②独立公式</h4><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$$</span><br><span class="line">&gt;公式</span><br><span class="line">&gt;$$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$$<br>公式<br>$$</p></blockquote><h3 id="2、上下标-1"><a href="#2、上下标-1" class="headerlink" title="2、上下标"></a>2、上下标</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$x^&#123;y^z&#125;=(1+e^x)^&#123;-2xy^w&#125;$</span><br><span class="line">&gt;$\sideset&#123;^1<span class="emphasis">_2&#125;&#123;^3_</span>4&#125;&#123;\underset&#123;6&#125;\bigotimes&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$x^{y^z}&#x3D;(1+e^x)^{-2xy^w}$<br>$\sideset{^1_2}{^3_4}{\underset{6}\bigotimes}$</p></blockquote><h3 id="3、括号和分隔符"><a href="#3、括号和分隔符" class="headerlink" title="3、括号和分隔符"></a>3、括号和分隔符</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\langle\quad\rangle\quad\lceil\quad\rceil\quad\lfloor\quad\rfloor\quad\lbrace\quad\rbrace\quad\lVert\quad\rVert$</span><br><span class="line">&gt;$f(x,y,z)=3y^2z\left(3+\dfrac&#123;7x+5&#125;&#123;1+y^2&#125;\right)$</span><br><span class="line">&gt;$\left.\dfrac&#123;\mathrm&#123;d&#125;u&#125;&#123;\mathrm&#123;d&#125;x&#125;\right|<span class="emphasis">_&#123;x=0&#125;$</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\langle\quad\rangle\quad\lceil\quad\rceil\quad\lfloor\quad\rfloor\quad\lbrace\quad\rbrace\quad\lVert\quad\rVert$<br>$f(x,y,z)&#x3D;3y^2z\left(3+\dfrac{7x+5}{1+y^2}\right)$<br>$\left.\dfrac{\mathrm{d}u}{\mathrm{d}x}\right|_{x&#x3D;0}$</p></blockquote><h3 id="4、分数"><a href="#4、分数" class="headerlink" title="4、分数"></a>4、分数</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\frac&#123;a&#125;&#123;b&#125;\quad\dfrac&#123;a&#125;&#123;b&#125;\quad &#123;a\over b&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\frac{a}{b}\quad\dfrac{a}{b}\quad {a\over b}$</p></blockquote><h3 id="5、开方"><a href="#5、开方" class="headerlink" title="5、开方"></a>5、开方</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\sqrt[根指数,省略时为2]&#123;被开方数&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\sqrt{2}\quad\sqrt[3]{2}$</p></blockquote><h3 id="6、省略号"><a href="#6、省略号" class="headerlink" title="6、省略号"></a>6、省略号</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\cdots\quad\ldots\quad\vdots\quad\ddots$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\cdots\quad\ldots\quad\vdots\quad\ddots$</p></blockquote><h3 id="7、矢量和均值"><a href="#7、矢量和均值" class="headerlink" title="7、矢量和均值"></a>7、矢量和均值</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\overrightarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\overleftarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\overleftrightarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\underrightarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\underleftarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\underleftrightarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\overline&#123;v&#125;=\bar&#123;v&#125;\quad\underline&#123;v&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\overrightarrow{E(\vec{r})}\quad\overleftarrow{E(\vec{r})}\quad\overleftrightarrow{E(\vec{r})}\quad\underrightarrow{E(\vec{r})}\quad\underleftarrow{E(\vec{r})}\quad\underleftrightarrow{E(\vec{r})}\quad\overline{v}&#x3D;\bar{v}\quad\underline{v}$</p></blockquote><h3 id="8、积分"><a href="#8、积分" class="headerlink" title="8、积分"></a>8、积分</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$$</span><br><span class="line">&gt;\iint\limits<span class="emphasis">_D\left(\dfrac&#123;\partial Q&#125;&#123;\partial x&#125;-\dfrac&#123;\partial P&#125;&#123;\partial y&#125;\right)&#123;\rm d&#125;x&#123;\rm d&#125;y=\oint\limits_</span>LP&#123;\rm d&#125;x+Q&#123;\rm d&#125;y</span><br><span class="line">&gt;$$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$$<br>\iint\limits_D\left(\dfrac{\partial Q}{\partial x}-\dfrac{\partial P}{\partial y}\right){\rm d}x{\rm d}y&#x3D;\oint\limits_LP{\rm d}x+Q{\rm d}y<br>$$</p></blockquote><h3 id="9、极限"><a href="#9、极限" class="headerlink" title="9、极限"></a>9、极限</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\lim\limits<span class="emphasis">_&#123;n\to\infin&#125;(1+\dfrac&#123;1&#125;&#123;n&#125;)^n=e$</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\lim\limits_{n\to\infin}(1+\dfrac{1}{n})^n&#x3D;e$</p></blockquote><h3 id="10、累加、累乘及交集、并集"><a href="#10、累加、累乘及交集、并集" class="headerlink" title="10、累加、累乘及交集、并集"></a>10、累加、累乘及交集、并集</h3><blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\sum\limits<span class="emphasis">_&#123;i=1&#125;^n\dfrac&#123;1&#125;&#123;n^2&#125;\quad and\quad\prod\limits_</span>&#123;i=1&#125;^n\dfrac&#123;1&#125;&#123;n^2&#125;\quad and\quad\bigcup\limits<span class="emphasis">_&#123;i=1&#125;^n\dfrac&#123;1&#125;&#123;n^2&#125;\quad and\quad\bigcap\limits_</span>&#123;i=1&#125;^n\dfrac&#123;1&#125;&#123;n^2&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\sum\limits_{i&#x3D;1}^n\dfrac{1}{n^2}\quad and\quad\prod\limits_{i&#x3D;1}^n\dfrac{1}{n^2}\quad and\quad\bigcup\limits_{i&#x3D;1}^n\dfrac{1}{n^2}\quad and\quad\bigcap\limits_{i&#x3D;1}^n\dfrac{1}{n^2}$</p></blockquote><h3 id="11、希腊字母"><a href="#11、希腊字母" class="headerlink" title="11、希腊字母"></a>11、希腊字母</h3><table><thead><tr><th>语法</th><th>字母</th><th>语法</th><th>字母</th><th>语法</th><th>字母</th></tr></thead><tbody><tr><td>\Alpha(\alpha)</td><td>$\Alpha(\alpha)$</td><td>\Beta(\beta)</td><td>$\Beta(\beta)$</td><td>\Gamma(\gamma)</td><td>$\Gamma(\gamma)$</td></tr><tr><td>\Epsilon(\epsilon)\varepsilon</td><td>$\Epsilon(\epsilon)\varepsilon$</td><td>\Zeta(\zeta)</td><td>$\Zeta(\zeta)$</td><td>\Eta(\eta)</td><td>$\Eta(\eta)$</td></tr><tr><td>\Iota(\iota)</td><td>$\Iota(\iota)$</td><td>\Kappa(\kappa)\varkappa</td><td>$\Kappa(\kappa)\varkappa$</td><td>\Lambda(\lambda)</td><td>$\Lambda(\lambda)$</td></tr><tr><td>\Nu(\nu)</td><td>$\Nu(\nu)$</td><td>\Xi(\xi)</td><td>$\Xi(\xi)$</td><td>\Omicron(\omicron)</td><td>$\Omicron(\omicron)$</td></tr><tr><td>\Rho(\rho)\varrho</td><td>$\Rho(\rho)\varrho$</td><td>\Sigma(\sigma)\varsigma</td><td>$\Sigma(\sigma)\varsigma$</td><td>\Tau(\tau)</td><td>$\Tau(\tau)$</td></tr><tr><td>\Phi(\phi)\varphi</td><td>$\Phi(\phi)\varphi$</td><td>\Chi(\chi)</td><td>$\Chi(\chi)$</td><td>\Psi(\psi)</td><td>$\Psi(\psi)$</td></tr><tr><td>\Delta(\delta)</td><td>$\Delta(\delta)$</td><td>\Theta(\theta)\vartheta</td><td>$\Theta(\theta)\vartheta$</td><td>\Mu(\mu)</td><td>$\Mu(\mu)$</td></tr><tr><td>\Pi(\pi)\varpi</td><td>$\Pi(\pi)\varpi$</td><td>\Omega(\omega)</td><td>$\Omega(\omega)$</td><td>\upsilon</td><td>$\upsilon$</td></tr><tr><td>\ell</td><td>$\ell$</td><td>\eth</td><td>$\eth$</td><td>\hbar</td><td>$\hbar$</td></tr><tr><td>\hslash</td><td>$\hslash$</td><td>\mho</td><td>$\mho$</td><td>\partial</td><td>$\partial$</td></tr></tbody></table><h3 id="12、特殊字符"><a href="#12、特殊字符" class="headerlink" title="12、特殊字符"></a>12、特殊字符</h3><h4 id="①说明"><a href="#①说明" class="headerlink" title="①说明"></a>①说明</h4><blockquote><p>可以在字符前使用<code>\large</code>或<code>\small</code>以显示更大或更小的字符。${\LARGE A}{\Large A}{\large A}A{\small A}$</p></blockquote><h4 id="②关系运算符"><a href="#②关系运算符" class="headerlink" title="②关系运算符"></a>②关系运算符</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\pm(\mp)</td><td>$\pm(\mp)$</td><td>\times</td><td>$\times$</td><td>\div</td><td>$\div$</td></tr><tr><td>\nmid</td><td>$\nmid$</td><td>\cdot</td><td>$\cdot$</td><td>\mid</td><td>$\mid$</td></tr><tr><td>\bigodot</td><td>$\bigodot$</td><td>\bigotimes</td><td>$\bigotimes$</td><td>\bigoplus</td><td>$\bigoplus$</td></tr><tr><td>\ge</td><td>$\ge$</td><td>\le</td><td>$\le$</td><td>\ll</td><td>$\ll$</td></tr><tr><td>\geqslant</td><td>$\geqslant$</td><td>\leqslant</td><td>$\leqslant$</td><td>\neq</td><td>$\neq$</td></tr><tr><td>\approx</td><td>$\approx$</td><td>\xlongequal{文本}</td><td>$\xlongequal{文本}$</td><td>\triangleq</td><td>$\triangleq$</td></tr><tr><td>\sim</td><td>$\sim$</td><td>\doteq</td><td>$\doteq$</td><td>\equiv</td><td>$\equiv$</td></tr><tr><td>\cong</td><td>$\cong$</td><td>\propto</td><td>$\propto$</td><td>\parallel(\</td><td>)</td></tr><tr><td>\prec</td><td>$\prec$</td><td>\pmod{2}</td><td>$\pmod{2}$</td><td>\bmod</td><td>$\bmod{2}$</td></tr></tbody></table><h4 id="③集合运算符"><a href="#③集合运算符" class="headerlink" title="③集合运算符"></a>③集合运算符</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\emptyset</td><td>$\emptyset$</td><td>\varnothing</td><td>$\varnothing$</td><td></td><td></td></tr><tr><td>\subset</td><td>$\subset$</td><td>\subseteq</td><td>$\subseteq$</td><td>\subsetneq</td><td>$\subsetneq$</td></tr><tr><td>\supset</td><td>$\supset$</td><td>\supseteq</td><td>$\supseteq$</td><td>\supsetneq</td><td>$\supsetneq$</td></tr><tr><td>\bigcap</td><td>$\bigcap$</td><td>\bigcup</td><td>$\bigcup$</td><td>\setminus</td><td>$\setminus$</td></tr><tr><td>\bigvee</td><td>$\bigvee$</td><td>\bigwedge</td><td>$\bigwedge$</td><td></td><td></td></tr><tr><td>\in</td><td>$\in$</td><td>\notin</td><td>$\notin$</td><td>\ni</td><td>$\ni$</td></tr></tbody></table><h4 id="④三角运算符"><a href="#④三角运算符" class="headerlink" title="④三角运算符"></a>④三角运算符</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\circ</td><td>$\circ$</td><td>\bot</td><td>$\bot$</td><td>\angle</td><td>$\angle$</td></tr><tr><td>\degree</td><td>$\degree$</td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="⑤微积分运算符"><a href="#⑤微积分运算符" class="headerlink" title="⑤微积分运算符"></a>⑤微积分运算符</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\int</td><td>$\int$</td><td>\iint</td><td>$\iint$</td><td>\iiint</td><td>$\iiint$</td></tr><tr><td>\oint</td><td>$\oint$</td><td>\oiint</td><td>$\oiint$</td><td>\prime(‘)</td><td>$\prime$</td></tr><tr><td>\lim</td><td>$\lim$</td><td>\infin</td><td>$\infin$</td><td>\nabla</td><td>$\nabla$</td></tr><tr><td>\grad</td><td>$\grad$</td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="⑥逻辑运算符"><a href="#⑥逻辑运算符" class="headerlink" title="⑥逻辑运算符"></a>⑥逻辑运算符</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\because</td><td>$\because$</td><td>\therefore</td><td>$\therefore$</td><td></td><td></td></tr><tr><td>\forall</td><td>$\forall$</td><td>\exist</td><td>$\exist$</td><td></td><td></td></tr><tr><td>\not&gt;</td><td>$\not&gt;$</td><td>\not&lt;</td><td>$\not&lt;$</td><td></td><td></td></tr><tr><td>\land</td><td>$\land$</td><td>\lor</td><td>$\lor$</td><td>\lnot</td><td>$\lnot$</td></tr><tr><td>\top</td><td>$\top$</td><td>\vdash</td><td>$\vdash$</td><td>\vDash</td><td>$\vDash$</td></tr></tbody></table><h4 id="⑦带帽符号"><a href="#⑦带帽符号" class="headerlink" title="⑦带帽符号"></a>⑦带帽符号</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\hat{xy}</td><td>$\hat{xy}$</td><td>\widehat{xyz}</td><td>$\widehat{xyz}$</td></tr><tr><td>\tilde{xy}</td><td>$\tilde{xy}$</td><td>\widetilde{xyz}</td><td>$\widetilde{xyz}$</td></tr><tr><td>\check{x}</td><td>$\check{x}$</td><td>\breve{y}</td><td>$\breve{y}$</td></tr><tr><td>\grave{x}</td><td>$\grave{x}$</td><td>\acute{y}</td><td>$\acute{y}$</td></tr><tr><td>\dot{x}</td><td>$\dot{x}$</td><td>\ddot{x}</td><td>$\ddot{x}$</td></tr><tr><td>\overparen{xy}</td><td>$\overparen{xy}$</td><td></td><td></td></tr></tbody></table><h4 id="⑧选取符号"><a href="#⑧选取符号" class="headerlink" title="⑧选取符号"></a>⑧选取符号</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\fbox{a+b+c+d}</td><td>$\fbox{a+b+c+d}$</td><td></td><td></td></tr><tr><td>\overbrace{xx\cdots x}^{10个x}</td><td>$\overbrace{xx\cdots x}^{10个x}$</td><td>\underbrace{xx\cdots x}_{10个x}</td><td>$\underbrace{xx\cdots x}_{10个x}$</td></tr></tbody></table><h4 id="⑨箭头符号"><a href="#⑨箭头符号" class="headerlink" title="⑨箭头符号"></a>⑨箭头符号</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\leftarrow</td><td>$\leftarrow$</td><td>\rightarrow</td><td>$\rightarrow$</td><td>\leftrightarrow</td><td>$\leftrightarrow$</td></tr><tr><td>\longleftarrow</td><td>$\longleftarrow$</td><td>\longrightarrow</td><td>$\longrightarrow$</td><td>\longleftrightarrow</td><td>$\longleftrightarrow$</td></tr><tr><td>\Leftarrow</td><td>$\Leftarrow$</td><td>\Rightarrow</td><td>$\Rightarrow$</td><td>\Leftrightarrow</td><td>$\Leftrightarrow$</td></tr><tr><td>\Longleftarrow</td><td>$\Longleftarrow$</td><td>\Longrightarrow</td><td>$\Longrightarrow$</td><td>\Longleftrightarrow</td><td>$\Longleftrightarrow$</td></tr><tr><td>\uparrow</td><td>$\uparrow$</td><td>\downarrow</td><td>$\downarrow$</td><td>\updownarrow</td><td>$\updownarrow$</td></tr><tr><td>\Uparrow</td><td>$\Uparrow$</td><td>\Downarrow</td><td>$\Downarrow$</td><td>\Updownarrow</td><td>$\Updownarrow$</td></tr><tr><td>\to</td><td>$\to$</td><td>\swarrow</td><td>$\swarrow$</td><td>\nearrow</td><td>$\nearrow$</td></tr><tr><td>\gets</td><td>$\gets$</td><td>\searrow</td><td>$\searrow$</td><td>\nwarrow</td><td>$\nwarrow$</td></tr><tr><td>\mapsto</td><td>$\mapsto$</td><td>\rightrightarrows</td><td>$\rightrightarrows$</td><td></td><td></td></tr></tbody></table><h4 id="⑩空格"><a href="#⑩空格" class="headerlink" title="⑩空格"></a>⑩空格</h4><table><thead><tr><th>输入</th><th>效果</th><th>输入</th><th>效果</th><th>输入</th><th>效果</th></tr></thead><tbody><tr><td>\!</td><td>$</td><td>!</td><td>$</td><td>默认</td><td>$</td></tr><tr><td>,</td><td>$</td><td>,</td><td>$</td><td>;(\ )</td><td>$</td></tr></tbody></table><h3 id="13、字体"><a href="#13、字体" class="headerlink" title="13、字体"></a>13、字体</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$&#123;\字体&#123;需要转换的字符&#125;&#125;$</span><br></pre></td></tr></table></figure></blockquote><table><thead><tr><th>输入</th><th>说明</th><th>显示</th><th>输入</th><th>说明</th><th>显示</th></tr></thead><tbody><tr><td>\rm</td><td>罗马体</td><td>${\rm{Sample}}$</td><td>\cal</td><td>花体</td><td>${\cal{Sample}}$</td></tr><tr><td>\it</td><td>意大利体</td><td>${\it{Sample}}$</td><td>\Bbb</td><td>黑板粗体</td><td>${\Bbb{Sample}}$</td></tr><tr><td>\bf</td><td>粗体</td><td>${\bf{Sample}}$</td><td>\mit</td><td>数学斜体</td><td>${\mit{Sample}}$</td></tr><tr><td>\sf</td><td>等线体</td><td>${\sf{Sample}}$</td><td>\scr</td><td>手写体</td><td>${\scr{Sample}}$</td></tr><tr><td>\tt</td><td>打字机体</td><td>${\tt{Sample}}$</td><td>\frak</td><td>旧德式字体</td><td>${\frak{Sample}}$</td></tr></tbody></table><h3 id="14、大括号和行标"><a href="#14、大括号和行标" class="headerlink" title="14、大括号和行标"></a>14、大括号和行标</h3><blockquote><p>说明:  使用<code>\left</code>和<code>\right</code>来创建自动匹配高度的<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>、<code>.</code>。在每个公式末尾使用<code>\tag&#123;行标&#125;</code>来实现行标。</p></blockquote><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$$</span><br><span class="line">&gt;f\left(</span><br><span class="line">&gt;\left[</span><br><span class="line">&gt;\dfrac&#123;1+\&#123;x,y\&#125;&#125;&#123;\left(\dfrac&#123;x&#125;&#123;y&#125;+\dfrac&#123;y&#125;&#123;x&#125;\right)(u+1)&#125;+a</span><br><span class="line">&gt;\right]</span><br><span class="line">&gt;^&#123;\dfrac&#123;3&#125;&#123;2&#125;&#125;</span><br><span class="line">&gt;\right)</span><br><span class="line">&gt;\tag&#123;行标&#125;</span><br><span class="line">&gt;$$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$$<br>f\left(\left[\dfrac{1+{x,y}}{\left(\dfrac{x}{y}+\dfrac{y}{x}\right)(u+1)}+a\right]^{\dfrac{3}{2}}\right)\tag{行标}<br>$$</p></blockquote><blockquote><p>说明:如果你想将行内显示的分隔符也变大,也可以使用<code>\middle</code>命令</p></blockquote><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$$</span><br><span class="line">&gt;\left\langle q\middle\|\dfrac&#123;\dfrac&#123;x&#125;&#123;y&#125;&#125;&#123;\dfrac&#123;u&#125;&#123;v&#125;&#125;\middle|p\right\rangle</span><br><span class="line">&gt;$$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$$<br>\left\langle q\middle|\dfrac{\dfrac{x}{y}}{\dfrac{u}{v}}\middle|p\right\rangle<br>$$</p></blockquote><h3 id="15、其他命令"><a href="#15、其他命令" class="headerlink" title="15、其他命令"></a>15、其他命令</h3><h4 id="①注释文字"><a href="#①注释文字" class="headerlink" title="①注释文字"></a>①注释文字</h4><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\text&#123;文字&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$$<br>f(n)&#x3D;\begin{cases}n&#x2F;2,&amp;\text{if $n$ is even}\3n+1,&amp;\text{if $n$ is odd}\end{cases}<br>$$</p></blockquote><h4 id="③文字颜色"><a href="#③文字颜色" class="headerlink" title="③文字颜色"></a>③文字颜色</h4><blockquote><ul><li>适用新旧浏览器<br> 代码:</li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\color&#123;颜色&#125;&#123;文字&#125;$</span><br></pre></td></tr></table></figure></blockquote><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>black</td><td>$\color{black}{color}$</td><td>grey</td><td>$\color{grey}{color}$</td><td>silver</td><td>$\color{silver}{color}$</td></tr><tr><td>white</td><td>$\color{white}{color}$</td><td>maroon</td><td>$\color{maroon}{color}$</td><td>red</td><td>$\color{red}{color}$</td></tr><tr><td>yellow</td><td>$\color{yellow}{color}$</td><td>lime</td><td>$\color{lime}{color}$</td><td>olive</td><td>$\color{olive}{color}$</td></tr><tr><td>green</td><td>$\color{green}{color}$</td><td>teal</td><td>$\color{teal}{color}$</td><td>auqa</td><td>$\color{auqa}{color}$</td></tr><tr><td>blue</td><td>$\color{blue}{color}$</td><td>navy</td><td>$\color{navy}{color}$</td><td>purple</td><td>$\color{purple}{color}$</td></tr><tr><td>fuchsia</td><td>$\color{fuchsia}{color}$</td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><ul><li>适用新版浏览器<br> 代码:</li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\color&#123;#rgb&#125;&#123;文字&#125;$    (注:其中r、g、b可以输入0~9和a~f来分别表示红色、绿色和蓝色的纯度)</span><br></pre></td></tr></table></figure></blockquote><table><thead><tr><th>输入</th><th>输出</th><th>输入</th><th>输出</th><th>输入</th><th>输出</th><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>#000</td><td>$\color</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107/"/>
      <url>/posts/16107/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发癫日常（1）（Blog测试√）</title>
      <link href="/posts/38068/"/>
      <url>/posts/38068/</url>
      
        <content type="html"><![CDATA[<h1 id="其实我只是想测试一下Blog喵"><a href="#其实我只是想测试一下Blog喵" class="headerlink" title="其实我只是想测试一下Blog喵~"></a>其实我只是想测试一下Blog喵~</h1><hr><h2 id="和泉老师-😍😍😍"><a href="#和泉老师-😍😍😍" class="headerlink" title="和泉老师~~~😍😍😍"></a>和泉老师~~~😍😍😍</h2><p><strong>2023.9.10</strong></p><p>今天是教师节，转我一百块，我将对和泉老师狠狠发癫🥵🥵🥵</p><p>和泉老师手把手帮你脱单，不脱单和泉老师退你八十，当然你也可以直接给我转20，因为对于你，我也没有十成的把握。</p><p>看见和泉老师哪有不疯的，硬撑罢了🥰🥰🥰🥰</p><img src="https://picdm.sunbangyan.cn/2023/11/07/7299c9d2d8507783f09e99326f427889.webp" title="和泉老师" style="zoom:40%"/><h2 id="和泉老师"><a href="#和泉老师" class="headerlink" title="和泉老师~~~~"></a>和泉老师~~~~</h2><p>🥰🤩😍😋🥵😈</p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 发电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog参考网站</title>
      <link href="/posts/7133/"/>
      <url>/posts/7133/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>空_无</strong></p><p><strong>Front-matter</strong> 常用模板。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">date:</span> </span><br><span class="line"><span class="attr">tags:</span>           <span class="comment"># []</span></span><br><span class="line"><span class="attr">categories:</span>     <span class="comment"># 汉字</span></span><br><span class="line"><span class="attr">cover:</span>          <span class="comment"># 直链</span></span><br><span class="line"><span class="attr">sticky:</span>         <span class="comment"># 数值越大，置顶的优先级越大</span></span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="number">0</span><span class="string">.</span> <span class="string">帖子模板</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-11-26 18:16:30</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">blog</span>, <span class="string">hexo</span>]</span><br><span class="line"><span class="attr">categories:</span> <span class="string">参考教程</span></span><br><span class="line"><span class="attr">sticky:</span> <span class="number">11</span>      </span><br><span class="line"><span class="attr">cover:</span> <span class="string">https://picdm.sunbangyan.cn/2023/11/26/57686fecffe37727fba38e311aaf330d.jpeg</span></span><br></pre></td></tr></table></figure><hr><h1 id="感叹"><a href="#感叹" class="headerlink" title="感叹"></a>感叹</h1><p>互联网教程一点都不适合小白，唉。</p><h1 id="Blog参考"><a href="#Blog参考" class="headerlink" title="Blog参考"></a>Blog参考</h1><h2 id="搭建参考网站"><a href="#搭建参考网站" class="headerlink" title="搭建参考网站"></a>搭建参考网站</h2><p><a href="https://hscyber.github.io/posts/1fb16b0c/">基于Hexo与Github搭建静态个人博客网站 Huangs’s Notes</a></p><h2 id="主题配置：安知鱼"><a href="#主题配置：安知鱼" class="headerlink" title="主题配置：安知鱼"></a>主题配置：安知鱼</h2><p><a href="https://docs.anheyu.com/">安知鱼主题官方文档 | 一个简洁、美丽的静态hexo主题</a></p><hr><h1 id="后续功能"><a href="#后续功能" class="headerlink" title="后续功能"></a>后续功能</h1><h2 id="撰写及发布"><a href="#撰写及发布" class="headerlink" title="撰写及发布"></a>撰写及发布</h2><p><strong>Tip:：一定要先把本地化搞好！</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;mypost&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>创建一个新的md文件，并在&#x2F;source&#x2F;_posts&#x2F;路径下找到对应的,md文件撰写自己的笔记了，撰写完成后，在命令行执行生成并发布，即完成了上传。但是通常延迟才能看到效果，也可以直接使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>并打开本地站点预览结果并调试，默认 <a href="http://localhost:4000/">http://localhost:4000/</a></p><p>成功会出现以下提示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">INFO  Have a <span class="built_in">nice</span> day</span><br></pre></td></tr></table></figure><p>关闭预览使用以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl c</span><br></pre></td></tr></table></figure><p>改主题用这两个命令:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><h2 id="hexo-魔改教程（1）-图床"><a href="#hexo-魔改教程（1）-图床" class="headerlink" title="hexo 魔改教程（1）| 图床"></a>hexo 魔改教程（1）| 图床</h2><p><a href="https://pics.sunbangyan.cn/">SunPics - 基于EasyImage的开源免费图床</a></p><h2 id="hexo-魔改教程（2）-评论"><a href="#hexo-魔改教程（2）-评论" class="headerlink" title="hexo 魔改教程（2）| 评论"></a>hexo 魔改教程（2）| 评论</h2><p><a href="https://docs.anheyu.com/advanced/#%E8%AF%84%E8%AE%BA">进阶配置 | 安知鱼主题官方文档</a><br><a href="https://twikoo.js.org/frontend.html">前端部署 | Twikoo 文档</a><br><a href="https://waline.js.org/guide/get-started/#vercel-%E9%83%A8%E7%BD%B2-%E6%9C%8D%E5%8A%A1%E7%AB%AF">快速上手 | Waline</a><br><a href="https://waline.js.org/guide/deploy/vercel.html#%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2">Vercel 部署 | Waline</a><br><a href="https://vercel.com/akari2333s-projects">Dashboard – Vercel</a><br><a href="https://valine.js.org/">Valine 一款快速、简洁且高效的无后端评论系统。</a></p><h2 id="hexo魔改教程（3）-加密插件"><a href="#hexo魔改教程（3）-加密插件" class="headerlink" title="hexo魔改教程（3）| 加密插件"></a>hexo魔改教程（3）| 加密插件</h2><p>开源地址：<a href="https://github.com/D0n9X1n/hexo-blog-encrypt">D0n9X1n&#x2F;hexo-blog-encrypt: Yet, just another hexo plugin for security.</a><br>参考blog：<a href="https://www.fomal.cc/posts/2d7ac914.html">博客魔改教程总结(三) | Fomalhaut🥝</a></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">作为日记加密</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2016-03-30 21:12:21</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">XXXXX</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">请输入密码查看.</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">这里需要密码.</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">blink</span> <span class="comment"># default / blink / shrink / flip / up / surge / wave / xray</span></span><br><span class="line"><span class="attr">wrong_pass_message:</span> <span class="string">密码错误</span></span><br><span class="line"><span class="attr">wrong_hash_message:</span> <span class="string">此文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br></pre></td></tr></table></figure><h2 id="hexo-魔改教程（4）-优化文章永久链接为数字编号"><a href="#hexo-魔改教程（4）-优化文章永久链接为数字编号" class="headerlink" title="hexo 魔改教程（4）| 优化文章永久链接为数字编号"></a>hexo 魔改教程（4）| 优化文章永久链接为数字编号</h2><p>参考：<a href="https://cloud.tencent.com/developer/article/1662763">Hexo博客进阶教程（一）| 优化文章永久链接为数字编号</a></p><h2 id="hexo-魔改教程（5）-Hexo-中较为优雅的插入思维导图"><a href="#hexo-魔改教程（5）-Hexo-中较为优雅的插入思维导图" class="headerlink" title="hexo 魔改教程（5）|  Hexo 中较为优雅的插入思维导图"></a>hexo 魔改教程（5）|  Hexo 中较为优雅的插入思维导图</h2><p><a href="https://zhangmaimai.com/2021/02/23/hexo-mindmap-plugin/">如何在 Hexo 中较为优雅的插入思维导图？hexo-markmap 演示 | 张麦麦的博客</a><br><a href="https://github.com/maxchang3/hexo-markmap/tree/main">在 hexo 博客中插入思维导图。</a></p><h2 id="图床-PicGo-GitHub"><a href="#图床-PicGo-GitHub" class="headerlink" title="图床 PicGo + GitHub"></a>图床 PicGo + GitHub</h2><p><em>2024&#x2F;1&#x2F;9</em></p><p>挺好用的感觉</p><blockquote><ul><li><em><a href="https://wlcheng.cc/posts/github_picture_bed/">Github 图床 PicGo 使用 - Wlcheng’s Life</a></em></li><li><em><a href="https://www.sunshuyi.vip/posts/48451/">exo+Next（2）PicGo图床搭建H | 我的小站</a></em></li><li><em><a href="https://zhuanlan.zhihu.com/p/489236769">使用Github+picGo搭建图床，保姆级教程来了 - 知乎</a></em></li><li><em><a href="https://zhuanlan.zhihu.com/p/353775844">如何利用 Github 搭建自己的免费图床？ - 知乎</a></em></li></ul></blockquote><p><strong>vscode 快捷方式：</strong></p><blockquote><p>Ctrl + Alt + u：从剪切板上传<br>Ctrl + Alt + e：从资源管理器上传<br>Ctrl + Alt + o：从输入框上传</p></blockquote><hr><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><h2 id="Error-Spawn-failed"><a href="#Error-Spawn-failed" class="headerlink" title="Error: Spawn failed"></a>Error: Spawn failed</h2><p><a href="http://dinghaoblog.cn/2021/09/10/%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99%E6%97%B6%E5%87%BA%E7%8E%B0Error-Spawn-failed/">hexo d部署网站时出现错误Error: Spawn failed(生成失败) | DinGHao’s BLOG</a></p><p>这个错误的大致意思是不能够进入远端部署的网址，同时生成失败。以下解决方法只适用于已正确配置SSH的情况下。<br>解决方法:<br> <strong>1.更换网络，用稳定的网络，避免因网络不流畅而导致部署超时。</strong><br> <strong>2.如果未关闭用hexo s命令打开的本地网页，到浏览器中关闭刚刚打开的网页。</strong><br> <strong>3.重新使用三件套hexo clean，hexo g，hexo d。</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>其中<code>hexo g</code>和<code>hexo d</code>指令可以直接使用<code>hexo g -d</code>这一条指令代替，效果是一样的。<br>如果对hexo的指令不熟悉可以查看Hexo官方文档。<br>最后完成部署的结果如下:<code>INFO Deploy done: git</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空无</title>
      <link href="/posts/26849/"/>
      <url>/posts/26849/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 空_无 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空_无 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
