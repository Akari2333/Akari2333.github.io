<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【计算机内存体系】理解计算机内存，从位、字节到字，以及寻址的双重视角</title>
      <link href="/posts/15160/"/>
      <url>/posts/15160/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【空_无】语录001</title>
      <link href="/posts/46612/"/>
      <url>/posts/46612/</url>
      
        <content type="html"><![CDATA[<h1 id="烧鸡老师："><a href="#烧鸡老师：" class="headerlink" title="烧鸡老师："></a>烧鸡老师：</h1><blockquote><p>我始终相信还是会有那么一段主题，它是雅俗共赏的，它是所有人都会面对的现实，也是所有人的憧憬向往的点。所以最后你会发现千人律者篇的故事灵感有一些现实的影子，它来源于现实当中、生活当中我们都会遇到的社会现象，比方说网络暴力，比方说群体极化。<br><em>“看吧，这个剧场的所有人都是这样，这个世界的所有人都是这样，盲目、冲动、自私、悲哀，不知道自己想要什么，不知道自己该做什么，只是任凭他人摆布，当一个可悲的演员，一个愚蠢的人偶。人心的卑劣，远比灾难更可怕。这样的世界，从一开始就不存在真正的救赎！”</em><br>它是一种证明，在经历这个故事的时候，我们曾经产生过某种感情，而现在 我们能发现一个毫无关联的陌生人正在体会与我们当初一样的情绪。这其中 不仅仅有感动，还有理解和共鸣。也是在这时，我们渐渐明白了，我们所追求的那种雅俗共赏的事物到底是什么。<strong>正因为生活并不美好，所以我们才渴望美好。如果人性就是有两面，如果善恶一定并存的话，那既然生活的残酷无处不在，那始终也会希望有一种声音，它能不断地去捍卫这种对美好的向往和憧憬。</strong>它会由琪亚娜带给玩家，再由玩家带给更多的人 永远存在。<strong>这不切实际，但我们期望如此。</strong><br><strong>我们还是希望在这个故事最后，玩家喜欢的不仅仅是这个故事，或者说制作这个故事的团队。他们最应该喜欢的 还是陪同这个故事一直走到了现在的自己，可能是曾经努力去做过某件事情，又或者是说 因为这个游戏 结识了一段重要的关系或者感情，或者 在这段时间里面做出了某个重要的抉择。它们一定会和这个故事一起 成为生命中被刻写下的部分。</strong><br><strong>今天的自己有没有变得比昨天更好，明天的自己会不会变得比今天更好，就像我今天坐在这里，在镜头前讲下这个故事，它只是一个普普通通的 随处可见的故事。总有一天，每个人会和这个故事告别，走向不同的方向，独属于你自己的下一页。但是那样就好，累了的话就停下脚步，怀念的话就回来看看 这个故事也一直都在。且行且看，尽力而为，不要害怕，不要后悔。就像 崩坏三的slogan“为世界上所有的美好而战”一样，我们每个人都是在哭声中来到这个世界，但是却要笑着走向未来。</strong></p></blockquote><p>是啊——</p><ul><li>“今天的自己有没有变得比昨天更好，明天的自己会不会变得比今天更好”</li><li>“总有一天，每个人会和这个故事告别，走向不同的方向，独属于你自己的下一页。但是那样就好，累了的话就停下脚步，怀念的话就回来看看 这个故事也一直都在。且行且看，尽力而为，不要害怕，不要后悔。”</li></ul><h1 id="Shiel"><a href="#Shiel" class="headerlink" title="Shiel"></a>Shiel</h1><ul><li><p>我现在只需要 <strong>坚持</strong> 就行了：<strong>且行且看，尽力而为，不要害怕，不要后悔</strong>。<br>既然已经找到了自己的方向，那就一直走下去——我不是超人，我只是一个随处可见的的普通人，不过只是一个喜欢 <strong>ACGN</strong>、<strong>数码科技</strong>、<strong>文学历史</strong> 的死宅罢了。</p></li><li><p>就像 <strong>老哥</strong> 说的：<br><em><strong>没有那么多天赋异禀，努力也是一种天赋。</strong></em></p></li></ul><img src="https://picss.sunbangyan.cn/2023/11/28/cd9a58012975da248ef85cedc01272d4.jpeg" alt="0" />]]></content>
      
      
      <categories>
          
          <category> 空_无 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空_无 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序——快速排序</title>
      <link href="/posts/38023/"/>
      <url>/posts/38023/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>参考：<br><del>（不会真的有人不知道<a href="www.runoob.com">菜鸟教程</a>吧？哈哈）</del><br><a href="https://www.runoob.com/w3cnote/quick-sort-2.html">1.6 快速排序 | 菜鸟教程</a><br><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">1.0 十大经典排序算法 | 菜鸟教程</a></p><hr><p><strong>此快速排序对数据的要求是不能有 重复元素 ！！！</strong></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Shiel"><a href="#Shiel" class="headerlink" title="Shiel"></a>Shiel</h2><h3 id="1-5种常用的排序"><a href="#1-5种常用的排序" class="headerlink" title="1. 5种常用的排序"></a>1. 5种常用的排序</h3><p><em>均假定为升序</em><br><img src="https://picdl.sunbangyan.cn/2023/11/27/ac0144c6a79892daac91ac8e06c2cd6a.jpeg" alt="4种排序" style="zoom:35%"/></p><ol><li><p>冒泡排序</p><blockquote><ul><li>第 1 个和第 2 个比，第 2 个跟第 3 个比，第 3 个跟第 4 个比，···，第 n-1 个和第 n 个比，每次把大的数放后面</li><li>第1轮比完之后，前n个数的最大数字就到后面了。</li><li>之后<strong>递归</strong>：前 n-1 项、前 n-2 项、···前 2 项</li><li>排序完成</li></ul></blockquote></li><li><p>插入排序</p><blockquote><ul><li>把第 2 个数据插入到第 1 个处，保证前 2 个数据有序</li><li>把第 3 个数据插入到前 2 个处，保证前 3 个数据有序</li><li>·····</li><li>把第 n 个数据插入到前 n-1 个处，保证前 n 个数据有序</li></ul></blockquote></li><li><p>选择排序</p><blockquote><ul><li>在所有数据中按照某种算法选择一个数值，如果是升序，选择是最小的——第 1 个就是最小值</li><li>再从后面的 n-2 项中，选择一个次最小值，跟第 2 个数字互换——第 2 个数字变成次最小值</li><li>······</li><li>完成排序</li></ul></blockquote></li><li><p>快速排序</p><blockquote><ul><li>快排名字起的很好，快排快排，说明速度是很快的，快排也比较复杂，很经典的排序算法。</li></ul></blockquote></li><li><p>归并排序</p><blockquote><ul><li>两个两个排，先使两个两个有序</li><li>四个四个排，再使四个四个有序</li><li>八个八个排，再使八个八个有序</li><li>······</li></ul></blockquote></li></ol><h3 id="2-排序和查找的关系"><a href="#2-排序和查找的关系" class="headerlink" title="2. 排序和查找的关系"></a>2. 排序和查找的关系</h3><p><strong>排序</strong>是查找的前提。</p><h3 id="3-排序时重点关注的"><a href="#3-排序时重点关注的" class="headerlink" title="3. 排序时重点关注的"></a>3. 排序时重点关注的</h3><blockquote><ol><li>时间</li><li>空间</li><li>稳定性——每次排序之后不改变原来数据的相对位置就是稳定的</li></ol><blockquote><ul><li>甲 60、乙 39、丙 60、丁 89</li><li>即每次排序之后甲仍然在丙前面就是稳定的</li></ul></blockquote></blockquote><h2 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。<br>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。<br>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。<br>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p><blockquote><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p></blockquote><img src="https://picst.sunbangyan.cn/2023/11/27/6224978fb91ed66ebd428a58b8561861.jpeg" alt="sort 1" /><p>点击以下图片查看大图</p><img src="https://picdm.sunbangyan.cn/2023/11/27/16264631af11a2c7e776cc2ff9905256.jpeg" alt="sort 2" /><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><h2 id="Shiel-1"><a href="#Shiel-1" class="headerlink" title="Shiel"></a>Shiel</h2><h3 id="伪算法"><a href="#伪算法" class="headerlink" title="伪算法"></a>伪算法</h3><blockquote><ol><li>先找到某一个元素的确切位置（指排序后的正确的位置），即 中间点，从此中间点分成两半</li><li>对中间点左边再找 新的中间点 的确切位置</li><li>对中间点右边再找 新的中间点 的确切位置</li></ol></blockquote><ul><li>即：<br>假定是第一个元素（未排序之前），把第一个元素的确切的位置找到，这样左边是一半，右边是一半。</li></ul><h3 id="图片演示"><a href="#图片演示" class="headerlink" title="图片演示"></a>图片演示</h3><p><del>字太丑了</del></p><img src="https://picss.sunbangyan.cn/2023/11/27/4bcfc72d7e48a54302585e14cd199ffc.jpeg" alt="一步完成" style="zoom:30%"/><img src="https://picst.sunbangyan.cn/2023/11/27/9d93efbc9fd8194db4be8a4fb6d0107a.jpeg" alt="分步进行" style="zoom:40%"/><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-后来分成的左边一半和右边一半怎么办？"><a href="#1-后来分成的左边一半和右边一半怎么办？" class="headerlink" title="1. 后来分成的左边一半和右边一半怎么办？"></a>1. 后来分成的左边一半和右边一半怎么办？</h4><blockquote><p>按照同样的算法，把第一个元素的确切的位置给找到，又把左边一半分成两半，那左边一半怎么排？再找到第一个，继续分······<br>即 <strong>递归思想</strong> 和 <strong>分治思想</strong> 的应用，需要 <strong>递归</strong>。</p></blockquote><h4 id="2-此算法最关键的问题是？"><a href="#2-此算法最关键的问题是？" class="headerlink" title="2. 此算法最关键的问题是？"></a>2. 此算法最关键的问题是？</h4><blockquote><p>如何找到某一个元素的确切的位置。<br>只有找到了，这个元素的位置才能固定住，才能进行分治和递归，不然根本没办法进行。</p></blockquote><h4 id="3-如何找某一个元素确切的位置？"><a href="#3-如何找某一个元素确切的位置？" class="headerlink" title="3. 如何找某一个元素确切的位置？"></a>3. 如何找某一个元素确切的位置？</h4><p>快排分很多种，这里讲的是比较快的一种。</p><blockquote><ol><li>定义一个临时变量 val，将第 1 个元素的值赋给 val</li><li>定义两个指针 low 和 high（参数），low 指针保存第 1 个元素的地址，high 指针保存 最后一个 元素的地址。</li><li>把 l 往右移，h 往左移</li><li>当 l 和 h 重合时的位置即第 1 个元素的位置</li></ol></blockquote><h4 id="4-l-和-h-怎么移？"><a href="#4-l-和-h-怎么移？" class="headerlink" title="4. l 和 h 怎么移？"></a>4. l 和 h 怎么移？</h4><blockquote><p>5 2 6 8 4 3 7</p></blockquote><p>假定升序，<strong>最终的效果是 val 左边都是比 val 小的，val 右边都是比 val 大的！</strong></p><h4 id="5-l-和-h-移动时涉及到的操作"><a href="#5-l-和-h-移动时涉及到的操作" class="headerlink" title="5. l 和 h 移动时涉及到的操作"></a>5. l 和 h 移动时涉及到的操作</h4><p>首先需要明白这里涉及到两个操作：<strong>赋值</strong> 和 <strong>移动</strong>。</p><ul><li>赋值<blockquote><p>即把当前指向 h(l) 元素赋给 l(h)<br>什么时候才需要赋值？</p><blockquote><p>当此元素的位置错乱时才赋值，即此元素位置放错了：</p><ol><li>val 右半部分应该是比 val 大的，那么当 出现比 val 小的元素就赋给左边 l 位置处的 a[low]</li><li>val 左半部分应该是比 val 小的，那么当 出现比 val 大的元素就赋给右边 h 位置处的 a[high]</li></ol></blockquote></blockquote></li><li>移动<blockquote><p>即把指向 h (l) 的指针往 左移(右移)<br>什么时候才需要移指针？</p><blockquote><p>当此元素的位置正确时就移动呀！即此元素的位置是正确的，那就去看下一个元素的位置是否正确</p><ol><li>val 右半部分应该是比 val 大的，那么当 出现比 val 大的元素时说明此元素位置正确，就把 h 往左移，直到找到比 val 小的元素——进行赋值操作</li><li>val 左半部分应该是比 val 小的，那么当 出现比 val 小的元素时说明此元素位置正确，就把 l 往右移，直到找到比 val 大的元素——进行赋值操作</li></ol></blockquote></blockquote></li></ul><h4 id="6-移动时会出现的情况"><a href="#6-移动时会出现的情况" class="headerlink" title="6. 移动时会出现的情况"></a>6. 移动时会出现的情况</h4><p>由排列组合知会有 4 种情况：</p><blockquote><ol><li>val 右半部分：a[high] &gt; val</li><li>val 右半部分：a[high] &lt; val</li><li>val 左半部分：a[low] &gt; val</li><li>val 右半部分：a[low] &lt; val</li></ol></blockquote><p>现在你知道这 4 种情况应该怎么做了。</p><h4 id="7-一轮排序后就结束了吗？"><a href="#7-一轮排序后就结束了吗？" class="headerlink" title="7. 一轮排序后就结束了吗？"></a>7. 一轮排序后就结束了吗？</h4><blockquote><p>经过一轮排序函后只能确定第一个元素的下标，其它元素依然是无效的！<br>因为一轮排序只是对第一个元素操作，虽然已经比较复杂了，但只有第一个元素确定位置了。</p></blockquote><h2 id="菜鸟教程-1"><a href="#菜鸟教程-1" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><h3 id="伪算法-1"><a href="#伪算法-1" class="headerlink" title="伪算法"></a>伪算法</h3><blockquote><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol></blockquote><h3 id="图片演示-1"><a href="#图片演示-1" class="headerlink" title="图片演示"></a>图片演示</h3><p>菜鸟教程：<br>  <img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="菜鸟教程"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>测试用例</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">5 2 6 8 4 3 7</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure><hr><h2 id="Shiel-2"><a href="#Shiel-2" class="headerlink" title="Shiel"></a>Shiel</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: 快速排序</span></span><br><span class="line"><span class="comment">    * @version: 1.0</span></span><br><span class="line"><span class="comment">    * @author: @Shiel</span></span><br><span class="line"><span class="comment">    * @date: 2023-11-27 08:40:26</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_Quick</span><span class="params">( <span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> high )</span>;   <span class="comment">// 快排</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span><span class="params">( <span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> high)</span>;    <span class="comment">// 查找并返回 L=H 的位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">7</span>] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span> ,<span class="number">7</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    Sort_Quick(a, <span class="number">0</span>, <span class="number">6</span>);    <span class="comment">// 第二个元素表示第一个元素的下标，第三个参数表示最后一个元素的下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_Quick</span><span class="params">( <span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> high )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos;    <span class="comment">// 中间点 L=H 时的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( low &lt; high )    <span class="comment">// 只有 low&lt;high 时才继续进行</span></span><br><span class="line">    &#123;</span><br><span class="line">        pos = FindPos(a, low, high);    <span class="comment">// 获取中间点 L=H 的位置</span></span><br><span class="line">        Sort_Quick(a, low, pos - <span class="number">1</span>);    <span class="comment">// 中间点左半部递归</span></span><br><span class="line">        Sort_Quick(a, pos + <span class="number">1</span>, high);   <span class="comment">// 中间点右半部递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span><span class="params">( <span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> high )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = a[low];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 首先从右边 high 开始向左进行查找</span></span><br><span class="line">        <span class="keyword">while</span>( low &lt; high &amp;&amp; a[high] &gt; val )    <span class="comment">// high 指向的元素大于val，high左移</span></span><br><span class="line">        &#123;</span><br><span class="line">            high--;    <span class="comment">// a[high]&gt;val，不需要赋值，则high左移</span></span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = a[high];   <span class="comment">// 即a[high]&lt;val的情况，此时将a[high]赋给a[low]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再从左边 low 开始向右进行查找</span></span><br><span class="line">        <span class="keyword">while</span>( low &lt; high &amp;&amp; a[low] &lt; val )     <span class="comment">// low指向的元素小于val，low右移</span></span><br><span class="line">        &#123;</span><br><span class="line">            low++;      <span class="comment">// a[low]&lt;val，不需要赋值，则low右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        a[high] = a[low];   <span class="comment">// 即a[low]&gt;val的情况，此时将a[low]赋值给a[high]</span></span><br><span class="line">    &#125; <span class="comment">//终止循环之后 L和H 一定是相等的</span></span><br><span class="line">    </span><br><span class="line">    a[low] = val;   <span class="comment">// L=H，此时将val的值赋给 a[low]和a[high] 是一样的</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> high;    <span class="comment">// 返回下标，等价于 return low;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="菜鸟教程-2"><a href="#菜鸟教程-2" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//严蔚敏《数据结构》标准分割函数</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">Paritition1</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> pivot = A[low];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     A[low] = A[high];</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     A[high] = A[low];</span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="type">int</span> pivot = <span class="built_in">Paritition1</span>(A, low, high);</span><br><span class="line">     <span class="built_in">QuickSort</span>(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">QuickSort</span>(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">&#125; Range;</span><br><span class="line"></span><br><span class="line">Range <span class="title function_">new_Range</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.end = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 避免len等于负值时引发段錯誤（Segment Fault）</span></span><br><span class="line">    <span class="comment">// r[]模板列表,p为數量,r[p++]为push,r[--p]为pop且取得元素</span></span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = new_Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> mid = arr[(range.start + range.end) / <span class="number">2</span>]; <span class="comment">// 选取中间点为基准点</span></span><br><span class="line">        <span class="type">int</span> left = range.start, right = range.end;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) ++left;   <span class="comment">// 检测基准点左侧是否符合要求</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; mid) --right; <span class="comment">//检测基准点右侧是否符合要求</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;               <span class="comment">// 移动指针以继续</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class="line">        <span class="keyword">if</span> (range.end &gt; left) r[p++] = new_Range(left, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-递归法"><a href="#C-递归法" class="headerlink" title="C &amp; 递归法"></a>C &amp; 递归法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = arr[end];</span><br><span class="line">    <span class="type">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">            right--;</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="keyword">if</span> (left)</span><br><span class="line">        quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-函数法"><a href="#C-函数法" class="headerlink" title="C++ &amp; 函数法"></a>C++ &amp; 函数法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a,a + n);<span class="comment">// 排序a[0]-a[n-1]的所有数.</span></span><br></pre></td></tr></table></figure><h3 id="C-迭代法"><a href="#C-迭代法" class="headerlink" title="C++ &amp; 迭代法"></a>C++ &amp; 迭代法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考：http://www.dutor.net/index.php/2011/04/recursive-iterative-quick-sort/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">    <span class="built_in">Range</span>(<span class="type">int</span> s = <span class="number">0</span>, <span class="type">int</span> e = <span class="number">0</span>) &#123;</span><br><span class="line">        start = s, end = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)、&quot;大於&quot;(&gt;)、&quot;不小於&quot;(&gt;=)的運算子功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">const</span> <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 避免len等於負值時宣告堆疊陣列當機</span></span><br><span class="line">    <span class="comment">// r[]模擬堆疊,p為數量,r[p++]為push,r[--p]為pop且取得元素</span></span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = <span class="built_in">Range</span>(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        T mid = arr[range.end];</span><br><span class="line">        <span class="type">int</span> left = range.start, right = range.end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= arr[range.end])</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[left], arr[range.end]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left++;</span><br><span class="line">        r[p++] = <span class="built_in">Range</span>(range.start, left - <span class="number">1</span>);</span><br><span class="line">        r[p++] = <span class="built_in">Range</span>(left + <span class="number">1</span>, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-递归法-1"><a href="#C-递归法-1" class="headerlink" title="C++ &amp; 递归法"></a>C++ &amp; 递归法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort_recursive</span><span class="params">(T arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    T mid = arr[end];</span><br><span class="line">    <span class="type">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换</span></span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right) <span class="comment">//试图在左侧找到一个比枢纽元更大的元素</span></span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right) <span class="comment">//试图在右侧找到一个比枢纽元更小的元素</span></span><br><span class="line">            right--;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[right]); <span class="comment">//交换元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[left], arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)、&quot;大於&quot;(&gt;)、&quot;不小於&quot;(&gt;=)的運算子功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quick_sort_recursive</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考地址:<br><a href="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md">https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md</a><br><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F</a></p></blockquote><h3 id="C-3"><a href="#C-3" class="headerlink" title="C#"></a>C#</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序（目标数组，数组的起始位置，数组的终止位置）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span>(<span class="params"><span class="built_in">int</span>[] array, <span class="built_in">int</span> left = <span class="number">0</span>, <span class="built_in">int</span> right = <span class="number">-1</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (right.Equals(<span class="number">-1</span>)) right = array.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> keyValuePosition;   <span class="comment">//记录关键值的下标</span></span><br><span class="line">        <span class="comment">//当传递的目标数组含有两个以上的元素时，进行递归调用。（即：当传递的目标数组只含有一个元素时，此趟排序结束）</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            keyValuePosition = Partion(array, left, right);  <span class="comment">//获取关键值的下标（快排的核心）</span></span><br><span class="line">            QuickSort(array, left, keyValuePosition - <span class="number">1</span>);    <span class="comment">//递归调用，快排划分出来的左区间</span></span><br><span class="line">            QuickSort(array, keyValuePosition + <span class="number">1</span>, right);   <span class="comment">//递归调用，快排划分出来的右区间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Exception: &#123;0&#125;&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span>快速排序的核心部分：确定关键值在数组中的位置，以此将数组划分成左右两区间，关键值游离在外。（返回关键值应在数组中的下标）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Partion</span>(<span class="params"><span class="built_in">int</span>[] array, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> leftIndex = left;        <span class="comment">//记录目标数组的起始位置（后续动态的左侧下标）</span></span><br><span class="line">    <span class="built_in">int</span> rightIndex = right;      <span class="comment">//记录目标数组的结束位置（后续动态的右侧下标）</span></span><br><span class="line">    <span class="built_in">int</span> keyValue = array[left];  <span class="comment">//数组的第一个元素作为关键值</span></span><br><span class="line">    <span class="built_in">int</span> temp;</span><br><span class="line">    <span class="comment">//当 （左侧动态下标 == 右侧动态下标） 时跳出循环</span></span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt; rightIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt; rightIndex &amp;&amp; array[leftIndex] &lt;= keyValue)  <span class="comment">//左侧动态下标逐渐增加，直至找到大于keyValue的下标</span></span><br><span class="line">        &#123;</span><br><span class="line">            leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt; rightIndex &amp;&amp; array[rightIndex] &gt; keyValue)  <span class="comment">//右侧动态下标逐渐减小，直至找到小于或等于keyValue的下标</span></span><br><span class="line">        &#123;</span><br><span class="line">            rightIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftIndex &lt; rightIndex)  <span class="comment">//如果leftIndex &lt; rightIndex，则交换左右动态下标所指定的值；当leftIndex==rightIndex时，跳出整个循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = array[leftIndex];</span><br><span class="line">            array[leftIndex] = array[rightIndex];</span><br><span class="line">            array[rightIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当左右两个动态下标相等时（即：左右下标指向同一个位置），此时便可以确定keyValue的准确位置</span></span><br><span class="line">    temp = keyValue;</span><br><span class="line">    <span class="keyword">if</span> (temp &lt; array[rightIndex])   <span class="comment">//当keyValue &lt; 左右下标同时指向的值，将keyValue与rightIndex - 1指向的值交换，并返回rightIndex - 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        array[left] = array[rightIndex - <span class="number">1</span>];</span><br><span class="line">        array[rightIndex - <span class="number">1</span>] = temp;</span><br><span class="line">        <span class="keyword">return</span> rightIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//当keyValue &gt;= 左右下标同时指向的值，将keyValue与rightIndex指向的值交换，并返回rightIndex</span></span><br><span class="line">    &#123;</span><br><span class="line">        array[left] = array[rightIndex];</span><br><span class="line">        array[rightIndex] = temp;</span><br><span class="line">        <span class="keyword">return</span> rightIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 十大排序 </tag>
            
            <tag> 排序和查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念</title>
      <link href="/posts/2927/"/>
      <url>/posts/2927/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="此文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f11e2390ae592920925c02c79a9c47622432f4a296a4c59d37223332f032219b">736781c5d5a180c06a8755ec471d75bf153439610fd4b85e8e467f777b0bb7eecc1a1fad71f9227845061a97b8c1e43c88a19194ddc4a8e09a626e0c3e26bbfddd4786747cc9cf4ed2957a75f82d827688aa52a78ca6a612825593b62b8f520fc12327390e0fdbc4847b90e6e2bfcea178c791e0b5f8720236014e74869889b9d997eb2b482802ad88b03e15089f8095bde5d922229d4e9313678b71d7003a1c4d6d602a9db65aa8bfd4c80564f8cb1f4dcfa8ff524c405a8d227bf883d3e8ba175201745bd1596f128123caa231445b8e2a56ebe6d749e2c32a3002251bf2773bdcb92a42a5276b47e323ef06e954f38f3ef3f688b772353c7c4ceac5ba1d8d6acb6423701b72a474cdf14b07b67c1067fba7221a01607c4556cb5c0c2ef5195270bdc91d91396a3a20cde2c096180762c1e37d9411f9d34225f34be841ca1eea9593143bff058079059fba6b95d0ac48ac9a9d0144af76b718c08fd5129c60b6d47b670f33e16f6bdeb463035b3d6a8a7c394d4fb06628e724bcf458885894845d3129a9e1e3a4bdae284322f8a8ee6f0cd0929b03d4a04995a397503990ee0630f0a5a6787b4d15311a2aae6cb291e0fe261ea2921c053fd500e39ba4186d5fc2e25ee8746f6d6737a5fa4592ea9d75e1f90c24f6a031a04f2f9a84976161b09761cc14041b32edfdd595db45796989181b2dbb893377ed30c4075132bd9fd98d5ecdbb826e8a66c52e483d903156fd6fda039827d3e3f900e3a32e7782939dd48f54520826256c30e76f62ddcfc921d8d827068d1aebb4ed4750bca96c570af83d788dd8f5b20da374126107a01d839b701a97345ab3e32f15f19f30a522dd4bd50d78ab835c5d7366e99f7bc6f0fa7a47725acecaebaa24322f45602e5cd52bd7651465a2c167166e65169cd9ddfe0cfdd5e0588024cc8fc570411d597fc6e566b4d4244fb366e5f6946d30a4c95bc090c4ad5710efb37f3e029d1e8ca5178780b31ee07061f8552975c6243bff9a0d3c8fab546575883454808c8c0684480e2dfbdfc5b4298f6d0ad1f1e53240ef7c64f77b10c26d20ffb440891eb57b7aa15428861f31f6113f995e692a943ffc9b51fffa0579b05f1c408ea5ab45cddda318568975b0ab17a4bb7d14a36df94f2c1020fba5e705afcebdd2601af4117aa4efd753369a83e5b3f592011e48429939b6cfa7e0f8d006de75576197264381893ac88544a42b4b36be8939354423146eda7b923a305b500a3e3e9247e5a54423d604590d0fba2df1035ed0db708d3f88bffde12581c466a1ce8527f1253128bcf1b8e7f3581b946a39f11fde4df79260f146de3a7130cba381fe592d575f6066f0a975545c6d1754508ba508b80d61d918730001fe15bf691f72746fe8fc24c366c55ab672e5851c4a4e3a927c399340c4763489f1c1a6328674898dd664fe94c26eb813706caaf5b42c9121f769d5e60ef655cb511afc78361f63aa4fff6e3d5e4df3b6fc7159b9613bd9716299e4068eed0d648711451a2ed4d9b84ab32540948616ab1d91e8b2ee52e57a7c777f72ecedcfe512c805061da5b812d20ef28363a49839556d22d83640f4ceaffe36a3bc363d5625ef9eb673f16720f62834cd0dd821fa2745a7fc3ca10ce97352c35a34f7d0480b059eec9d1ce2696bb6ff4d1d0b1b03078ed8d2d6b3a07afcc04e070ac11ca76ad3163c5f2f6d91844039b052b37b7b70092aa06af1d8f9cf8caa621938db773c3c24195f488fd148d9cc2a3eed6bce020673312c6a2694ffdeaff83f7b78345f2b9b4f6ee0b468f6b9d802950d269cdb72d7caa1f4c216cf320c267596b81450617e3ca1c0c752ff869a8391f6189c1520c411fd998e7a39f35eabf2b40870d5b5cbb92fb79ee84d7f158ace09b9d89e9a2073cb18c58c4c01bfddceb2c4c698b61e3b1a716d8b60ed93aa2cfdb3141c1f3d48d843fb732558053252edfa7c718a8b31eaffe3f3ea69dd2a3c2f5bcbe7b5f646f2914ce9015e5ebc6b59f51844dc0fae80e67a4b3039f815962d30bc3e0608a1109161d9f1e61fb03a18a7d61626d44a1e6bf0a9d67a7f84ae4940041ae926196b9c280ab670ea8eeaac34adf2d827b8f0520a2595abff5e310e3f37c6a024039eceebdd607940bf01b1eb4a7b52933d5a1d6cfbdce0f14a7f40931c4316929a6510bb19416a387b5dc03e66658a549d318c54fc5467bb22e0a479c6046c3903556ea091c1b6e0a93066d03700c69412385429426420f09f93bbe9c2e7ef7ff9a5ae0354246d33f205712fceee3766e289d064424d1eae01704cb0cd9bae2a106354b51891bdbc850ead551a3f25e480169141bf7018a55a7f9ef4e0f41793f683cfad12ecef311724f9422674455fd930351f6be9b7c4c7d4ba2e694368eb14e11d6f0a406805ef2e5a5106e44e2189cd44f9b1bbc7e093e86b04b70e147ce31874086fb933909d4f05933312e7aea2120e3ea7457d0c73d76fe103c5c5730b1d65677483243d42f983afaff333fdd3e3c96c80db28885ad83fb9b5424ba42bc924594c7a631bc0de96fcf9c7dda1e6d5b5e3213ead291a392b27055d0e0b1463e678418a13f54e1d68fbb9db35a44e4e12f7e6545882df5b57ee654a6e5f31592a9545b84a408228fa0e5e3b98ceb49e90c7bdf22f56964a2e786de9a682463d219e9625254f43175216dd53c28faabbe72488acad9432f9bcd50f2b317ca7a01f319cb781d5394d5e8f42c22e1bb78be8f3b7df0a88808fdf52f023ce776e5138aa10be032c9498e3b5ee669fb1f8526deb25b3b50ded959196abf16d2103043bd4f2c142b2b7654801aa88942357db797e16028e173175aed2396b02a097111f9eb1a9fd2d0e3a624c81bf64ea728bd14bcb3671b22f3134fabf98dfe9a41b4a78573de1d3054b95ac9f89dc3c8f05f9b2ca84d2729f81c01b3d79fda74e314988ef16debc97c3bd5054cd86d2c13028f441f4bc52e513aab2d5c597bbfc7af7f619f57e6f9eeb4fdf4ea3ee9963dd68a9fa1257809f834bdf0fcdd41e76ac6254747fd468f8c3404e369fdfa9386863a8a7eb955e3f77338903d85dfbb3f4017ce69cf8c5d1a6568ca976566621a0008b9e37a38e7d85ee34b720516bd5f8fc259c95b4dcd1d100dc0086f20ab4f2fea11935f9d099627ddd2499dbdc1235563cff470e849ed515e98d44e206ecd9ec64282c69fcd514ca25e6235493be6bfe8fca2a0613b0e9a4e4e8cf977b4168d67b8f1a10c2903913c4947d02ddbfd630aefb9a851c897723be1a2b9f92a3667428cd0a71f580a0ab2185b5c45eaa8ebe8e26772e75eca0cbac22da8a569dd91a70abdc56acb39cb4fc17a723ad17a84d955a12331ea22816a94c5a67cd674b88b04c9121fdb77324dfbedee4744bf0cce9405793cd0ae76d9eaa18e06efa3f4059989a75db0c07732757f1e97fdde47051a1952186ab2ee047dcb4565095a87c125e024ce55940f94499a6f3717ecda1fdf4cd8dc329eb890988aba5f5bcb3f9ba2f98f99f6d247649c920761543bb0e6ee86d8418ad06ef044dde8784ca2028fbc09859e7bbd68f2e55c3eb33248fe53de5a6fc13116b212f70f70b7bfd2179ed28d09d8cad86546cf5392b0f07267db0473e161b86ea4b460dc7e4b916deae0120268f181402c9dc70150dec3be3aa7355488633949fdde25417a9cd748f0559aa7820b9698b3537e566a75b46b1c8fc27c954024797386d69221bfcdc0153f3b90442dd3dc9f3af2b019db70175a00d71d6c6b3d3ae7959cb715648f5795eaec1c4a6083eb33df27ee9b857f38407aecdd182736768c468dcba789bf536408f5d5fcad465eb421a082ecd37258c4f8961faabea78279c82444735212dd622b3f798cc378d0c8ebb8c0c4e87ec724e7672cc1083c5709dba6f0de2a8a74e14493dad5967af0e9a0277f8bbc84b7a43de5f0afc6cf9d2f54314c68b720128d388fdaee3d76c87f4e3bb1b654549f3d4beeabf50dc0925f17e9306e0ba248014113501b14a8c49e12c7eb02b83cb7376b17f26fb00949fb24ab63445cbe7d1ebcfed9832ca7c75adb7992095255b66d3a1b745f17f6cd3ee159def63381d7e41180c495a55bdeff92d068492e4eb684d58cf6184c368fa9a0d31debb7a427184cc19324092ac5618d9140d501bb87c3262d47f5626a3c714e7729398003ef680aedc916a716085d38eef99c2adb244b0ce19c228a73cee9c91bfa81a31439e9973bd69ab53497439c4fda90989bf004be70bab032a7379832dbf54e37cb6ba9762ef99eb56136e77b74886c41f6260e73a4c0928ef99f25549e69a3f7ebcca4fa0b9bc20833214d86bd2cc8cbbdb9c701c2f5193f2820b6b004b01bdd5720dd18dca1c9ea428dbfc6be3469f38e615d0657430bcaf4dc3d635a96e0778aa8bde76766073cd607cdcf440b85809c1a730fdfbcaf7396b517d0d69e13197cbac56cec420681df394ddf03eedb05be1b03ec6fbe66cb62fa5f1acb8ba51433355ff6fa5374e3605080fad33998c109dc56ec287dd7c5558f68c92c4698a238b4c4dacaa228ac697034604e03a287e4aeb6798f31a57af0ad05df5bb321507eb2f4ee5589a73786db3291633a14e31ae3f1db0a8dcd1bffde0127ffcbf541fab543a6dbba5ece65ab9bebc552ed072e14edd1f49ceacf7cdbe8e4f0a1f06515a8ffa35eccf7d225d686352b93dcf3127b7bb6f7e443e92dcaf21c84984f7687709b7d872ef7fc2eeded79e24950fd361f3357b64cc2431e86bd13d9efb859249729d392ae0eb729ff275f0dbb5bca1d89d3ae43bc051a58406c61ca08887effc563e6b4fa505e08e29b08c6b6763adb8417e048d50cab362bcf56a34d3e46927f6274d007bad9683673d4c546971c62e998f59d42219f529f5ea721c0224870b1e81e5e749c2492529732c5d8ba6cdc98479f9cf56104b1ededcf07a31ac8c02d8a477596ffb327b2b4333578a74996424a3b8f115d470e780bc1819e628d3f68c778c2619efdb98a5cf9b0c8021054355fb81d6cce26af37019a574b2d14b9af368df6cfed6a36229aaada6fc9072f1cf2fd691f7f21f0096ecd1c4d648a033690709191c511a10d441c41c362954cbd321822c04978ba2b614098bfba4df0c9ce46d15f558de1a1a23a8e488d7443796c03f74ad5065bbfe5c382f643a4d7242a0bdcbc5a3519b0972bfcdbbb43ff7a00852f37fca7f556ed0141f1896f8c91dbdbdd24016064843916f55f0e9a197b9a079448f39b4d42053c7c73cfc2cbaf204b47b8fde0fcbb64efdad4087e1d7461afb08490cbaf64d430bee1c36940dec43a68c831da15e8fb3bb8242951abdec878b64c4e274bc6678b1442f4f5954a558d583c9d2605c40a4cef0a8ef24dbc56b901fd112e533f05a2c951580df7944835d95faecaf33b18fdff03401aa1b5d7556e0ca9a5696acebf2f9b59fdc730dc4556e293058d800ddebf281697d54374b3cb63b4658e4756ddcefd250206bff2a232fcfe871a9df718cc2b0cbb8ecf97d051eab4309f8fdac06624ff3561d16f0eb3b7c565d42b85d1fa5a6300d76fde9361e5a32759300c5b38ddfdc268f08d3a63921dc29cd379288ef24e512e01c31c8d1f54f7e8dfd63618adb9c70a4194e1232d55a4bd468232fbb869e784fea448aa77e1fd0df6cc5a29e64f799cb2c4972095e5cc7500bb0320ac62415ae962779ff3a3b62debfc842263f4a46c211491d67a3448a20532f3a670d84d1452283e0826444e9ffc9bebe25a468cac4b8d737cef26eb7a16f24bd79dfd20d6c62f89ac6a9d006829e01231429c12499068f55fbd0187601212048ac667892659948de07971abc14e6497380f30997e5d2c1f7f506e823c6e725a4a43b2d224734d89fd9fce45f9ae1be1db9b946ee08692d0b1d67630d9fc12ce6957482d3094245fa8bfbac968a8fe7cc784a888babc456ede61b22c32c78c1970484afe6a8bef46cd6aa78a368249de741727d516b17b21c0116238347838ae957a6d9c72eabcf913ed9984deb281398fc48b1aa2a45aeaf8209cf8f60173d2bdd3f2b2ca61688cd07050b46c50daa2e53a67df0c1a5b7a82382bfe5a67a8df18231ab66f3d057c42514d4770f1acc249a5085a26ed519c064d3bc6a719bab3d9099548a9113fb45bc63933cfcdd4ef9a1a78bee523e0559e37ea0fadc0d5f86252abb5722c8a2a9b265241101955015cce7b982743882f5ad47cb8d778389d3935e2d8d135ff523e00151ec2672f2dcc04543cacefb567cde7ef9cf459650dbef44e376ac8494c2f5e1e99b8a4a6877c4e67c7a277fe68fd2cb44c489edcfc36cba041290ce511f1d56ef90e5346a570d46db950283a6fc286c30982f539526b246e78f46e1932a645afc2e1600176e9a5a12b6fc387951c3312da9e1cfc92411de0ea13d5fe7af99934c87a98e82c615949b1f915ba820790720980bba487cfec274ca9e175477b9841af218781d9a734e5578b60f2a7214aba4ee994f6322cefc57f0b680c4d30adceebabd56de6707abc7e73d2cefc16ee90ff80b470a31a57d809fe6c2ab519d0cf7949725a56ed6703202eb6ee72e8c5a0da139ab6ad6843d59fc97d535ba42e752bbc330501e0a1bbc4b4fd1b37a21917896238904428f57620c1eeeafc0338998692ff1e62c7d8d148d6ab2e0afc5f785979ffe1b970194c507a4d1e4ef9a11d5030446e3e789ddbb699c28ccd51fe4f926be6368e395a942e4b83ec0ac0c5e52a132e402de7660872affc3e2c067f9c05ca742871f99b9309fb3dccc05eff27e54d659bd8ff802d317947a40b09f04d5cf282073d5eccb7fb6f524225252f79385edad8f74ab7b02d179fa47e7c806097a04a3a6ace57ce2e16481b73a86ae21b41b73b35322200721ecd2608cfa2753f74d20d288bab739011e5d77a8ab447ce61394e2f02c87c407b3751f7c25443dfe2d0f0bf4a01ef68e4cc42b83cbf55f9652eb2e75cf75d3c6c06a58f66a06c7b50faa137181a925ef91d308991872a8d7afa3a4f227f1905c82088cb5d5073195ad480ea248620d3d11cb65ab9d7e7cbca75a7213b94a3e3eb892348f95011119b1837ef518435460070cc7bbbe3926900a78411d3be2685bda38dceceb31c617c42f473ee5881d3e00a3d550a44c7931f4d78b4fd90806fb2ae79cb3f8aa5b446cce9903a88de20fca8df23dc73b526623a7635101803a36448f8f19c91a1014b61aec9d6ea3316531b487ff87c85f24bcdabf39ea18945e20076ea1fdce76a2c3220a4ddc8d74a6197071af5b99347cd5d6dcbe330ed5018cabd61fe85d039475cb41d903b3d9752f65e670f2ee5002037eaf929e09baad0ab20361c1a01fe7d2b60ae87740f5ce0fb7f63093145237c992ff721115388d454bb31e704a4df4e5e02f68970476630e60e20d60ac787a648dfe9091873068e5d57de0dd5ac30b88db6e3e77902c68e17981cdd899299e9a3b5df3e787fb52c7ed185a8382a1b30b01ebd0700d1070e770dcc8c4e8f599b6b62493eb50df70292c5b32d48d1bd5e295dce4af6732a9996d7061925547f0f6559950f5dde011024939bdeb183154f7e32a3f42f112db179452d21651d2db2f24122df66f5e22ff53ba2c34380082714aab0a5731e498d65f85efdaadc1204da805389390c65414f55f981a43b3725fff24c4b0bf356c57ac612998d9aefaac1fd6f42abd912d23eb96367ebad39bc975ced4eab13b4dfad4be25dc346b9a9910f4572219989f6d19f35b38db3dafbcf4adf0f13543c4c4bff96b8528d2dc355f7affffdeb363c25b294e9f8786a8737b82420f961336951400f1229310b53e0409a185099163ac2ff56332cabccf413272cd8de702444c7a017681aad43bc5896774d8cd6a0e038cb6b8f24cdc8493468bf804ea318a58af9830abafae3271caefd294340209aa1e9db029d00f9c3bb97cff1872f58c8d190c4ebca07c6a4f2ef427d53e5cc82d31c54b49ef5f664a5d965ce91cc331de7ac2658a2f87a1a7a9ffab07c735db53ebe6c307df5689dc17bf31bc12f753da80a2521b1de4c60f6bcc5a0e6c9018e826210985e2f57b66f0ac6bd734120ccd5fbc5f09a52a90e6cb01caa194cc2a7fb3f0aa797bb961226e492ade41cea83e06eea5de91a1141a5c3c6bea5faf368b9fbfc82dbba1dbcba0556134459a29dd603f99daa4a9978ffa521312719d33b6067b1ed0a0b43f95a6148248ec5e9186e84c51aa4db846db2a52aa6e796bef97d6000a0ef4ef064119363efbb1b4eab6626ea137861b34ce1a4c060d0563c21b5712497f77e3b7a06c2606238c64150d9228d438527c9e61048872ca8424629a34ce49d1caffe9d2913abc04117e9b72acaa86bf572dc335ef8d74940c028bfd0dc438cc45d483e3c23c1b9dc4ce1aee770ef5ad64183b94a4ff82cf3d7351ee2a38a5bf259bac3edc931dccf96f181fefa45eb62af3637bcb8ad521c58ffa63474424e40de6e453ab77a0c9cb0b4170d7bbc4021dfaabe086d7d8277008b8bdfa66de2c4dd0840240d7aa849a05317a2928802883732afa2c47dfac90fd421e69ba3f99fc53946e1358d2036a52d69e8fbb25bc3f6905fb72aa6472844e22f6d35d67b763948641821ac938ce020840b94bb0ae836399a88a3486f671378b6fd404129d64e8393b99ae81fcc0e630fa557c92ae976b7d0a84d2470126772a6c56d308b6fea12452b44b17be005c7ebc98dee0b4af34faf35dc408709ad60adc958435fd0059b209f0cc027b419bbcc581b897131b03fc8325558052d13a2d9458fcbff399066cd7188210da11fb25ca4f305c4edf6fc0d1d6d67f01319c9050937ac4ac79e7a59a3b4b582939e7ec0745728bd6f64400d3139206d821f2f2adcdd4658e85003e99a7cae59682073864bbde36f2c21ad20d634fb950a541f91a490af6aab5d9c5e049dd85ac454cf52195341378104f0a837c09681ee32e99f6c7cf279e001c44c5dc83f6f7da6f59cdb59434cc06757b57d38810929b5698a14d312ca22ecc6c1132dd4bfbde3daf1fd3f781b1ec65f674829466a808044fdbfbb1a6989f12b5407b4eb35b1066a9567cbc50f71f2507ccc4b217f75a635b686d38d724c8ca4c2ed0903787a7dbb2f4ab60b40112745444ebd8aeb9117e1e60fa1ec5b9be28f8f7f621f7817709a70fcdc3804b3ff1cb826eb550afec3daa33aa4d403a7002fd9cdb3182f8ccf20c1f0bc91c6f95058dd0dab38ce2d5d5ebcd7f2b8d5975a52951ead6bd6cd45656c1979325e93fef76efb20d0daba8fa39987b4ff852e95af955b3732d3e6584439833a16a6809095a7d5d567d0928ea9ebef996c5962647b41150bbb38d0b650ae83ce3a576c12b7c392c3026ed183529d44b8147821c4efdcecaf6c0a30508d84d5be54cffed65ed9cb54cfa0489687deb7ac4eebabc736bdc3be760391467a25e60de0eb8f6610645cd7eb9c8d6be732a7b6a3cfed0939dd2e99e1c9c4b524ce29c05b7521244bfd78e6c0c0c553c2f85f6e7ad9d8fe4d22ba61870203c1f6d77f92c14d32177383a1e248cdf82847e0053b60e8b258f2642bec5179a5bd1c589c1000594a6be822ed25b9f808798a194ea39b03f0bd8fcf51f23d0ea4a086100deaca2b6291e99d965b24d538102c940ee1e8b4244759e70cf16839367c45a4dcc706f44d6f8628249a99e25b699d380a217c696161cb560a3d4dcb7b9533a09c50571bce21a810178bad6eba267f3fb6ab6e00fb5f5650f330556079c956d2e84033af9535a13be42e2346d9b206bd1c71020714eb9744bf78bdf7e2616ed53932833387093aa2692cf65cb88e3c53797db69a0a30b32805fd77b05600560fc28af497acb3d31ac99a640ed7cce2aa0774d2e7f53bbdd4bf20ee02a5bcc6126c8d7d919c86d23d7dba71fe047890cef3df0e79957e06a1fae5eed0d2df003593eab1c4fb2dc4347244459127e7c875148e07ab5856fd0373a54a51de49efdefae45f2d8c3324d327e07628415fa3de1c7358ef28989174720ff1e9dcd60046aac3ae1773e97c67ad96a7f4d57ef608f53c2ac8640889cb134f604faa1888fe0e6169d790f6a780f72374e23614535b6eb87457ea72b3be0c995ed1d4f3b4059a4bd1a69184af8aa621f584a091ea11c9950eb53c5e56e04230dd721b66ce6497c88e2e96021a8f5c90805bd60c4119239d15ee53882a317d8108d64820fd82782b5925fe882ae3f2e6772a1b6e69ccb7dcaf7b350aa5d2406d159f0ef36e5ee7ffee0e6b658b8e31903c0897a3652f9b9700f04455d2fa06d8989e2eb08fd7889b8812e1bb4fc9952024123e15a33e0061ee0cb47cae1b1f05f6d8e95e22b2451ce740e7bad0e406a38b6564e3843a67a3072d8ae4f97bcc4d6ab2c0a3aff627a9cde19024c5237bce7e3ea48ba2ac04d6d896f733f7b5156dc4500c4b37937abb9da605c41f0339c59fe46ad104dff796eb53299d83ce57fdcc96c327b744082d01a732a88126507ca1fd4270f7d8ff09aa9fee9a952f7e09016f030d7ca210f740e372c38cf74589fbdc8701e905ea109c36428cf40344bdb6531252c48671086f06feedc8cc74fd0103f20e96bf16eb26013f2e2e5eb7c4271c66df280416ef3e7d2b784dc0976bfd2677ca1c832a3c741f78e11e058977e3d56a82d03280e672442354864ced2622cb074661fd4d4b0ab430cdd17236523f703d471d4bbf4151eec868d626874679e2368c73ede5b6c2a5d65055dd543e7d423d851339c469fd2b833e7fc44bf435a10b84966a5003a1b1861934eaa8f12eb8625d734467be0cb5e487c10774242f6cfcc5456f3e1c06e362f5f16c3613bd21298cb6c87c5444ae7bb48c72c714f807c6a0a5bdb0ce67d7334af98be89bf217db604a4a9bb10ed04e7993bb8604eb5107020ce8070049c96c5ffef78d91f2916814491b777471489f6bd637c3edb5774639e19f6c86224eeaa9ebbafb206949ce17eb64c46b3d1ff44e94f00fb6ac0d79caca08c2e4dc8cb781d2b74133b857934bc0a2a1c3d154eff4442a56fd75ec4d2c9a1d0087bca2b9ec21550f2cb5ea87bb5541dad57c4a8912f71fdd5ec3459534e631e218425a6e8ae964dfa4a8429c19248dbc92b4764ca2a371838f9c659bdd2c136206069e5f0c4446bea78ffd2550ca7cc523c82f9725cba37c8c327ec374ab605d19a2fd6dfa37bf66eb3efbe8b19f8e27f3ff4447c9f750b847b22255ccadfd2715ef0b6d83f374757bc72e48bba6341d7dc9bbea8dc78caf2a3e2295f9a11b1f08721ef4ee805d9d8d8091aed51cf5aeef1267547c86e2c1d1eb8df9a982f2f33fcb76c137a7ff44946a38e62ffafd4bbff4bbfbcccf380f6800f499d7856b247dbf8d000adc934aee3697f9dcae35c4f1c682772728883196c55c0aea3ad32fe6c05fa0e6496c4a13bb25f3cde1e72978e2a8af4ac7c35d0f8386c06722f4a0068ade586120a7bce8d19bf8a4aac04ce4e2fdebdc4422a1d9057806dfd0df3d14a5f13a62511ccc4a7064dc12712e6278c1066dd79ee2d0cbac7cb48c9b9b195951bb625cfc7c126ff1e159fe3810913bfb59a56bb221da941199b034c1f2b5fc344522e54c0f9796be716148cb2b76382cf0d228bd9af5b038bc3e87943fe7968744f5fd51bdc4a4db18587e8a2a17db78fc28d9bfe75ebf0bbd6479908adfd2bed512f1527a5add20aafbbbae5f73bcb3854671bee2a2e5ca4649f5e81e09159475a132e3244a0d64c71bb602cb73a4665dc00982dabeac56eef65705f955524942aeb856d494fa9c0836a9ec9eacd6572e17c465acf0ccda15513239b29d2d1190cd7f996ae67634815ba3ca16f708eb8b57e8f301ac3ae3f0f47188c3d1ad8073e559d4b6d6806a83be86339313c4cab983b58358f4c97fb006f148dcbbd96432ba8825cffbf5bdf199d1394bea5bc124c7cd775896e60d82bb3f1e10e64e3cfd5b6773501d478c865b6c04d2795c1ebc12409055ad5858d93de2687d52ce5c389100cce1a910513e15dfa2469eda44388403413ae4e4f80d29b2b90689df5a6d3561dbba4e1ff7fd5fc544c6e8b9552f67f7ddde73fca7bf4434a1d40862545777dcc38c7318e5c4f884ab0e94b670e590cafa837947f77bbd0de5d294a0a25f2ed46f70f4e98569b4bd50b0e26abec31fe211233172237559245d4145f19abfcdbfbc2e0a5563943bd423fc0391d5ca3dd872234b2e32d392c1b04824cd04daec69d2591c7d128f5d75f6de42fc08265565264df85cb7728aea44e8149be3205cdab1b93f368d99f3e2ad123aadb2e11c4288baaf14c948a0e4fc2ed1a5fe719fa6443a637ad156124aebe4eaf2a5dc99378c866d63ec312dc147d9916f15651951c40ffc4ccd3bd6ef1d743c745d5e99740af760c0a4b275e6754a4997e6805565c5f88abfaa962da9a94db79345918bc40af05ca587974703f4ee82a3bd75119837c279b8052b11643e9f25fa135e329fc29717b5e412bb29cc3c99b7f7407c6109502c593f6cc576307eb49178c8d8bfc8055f850b64673f9145d4d73ba963ff985c73e2c59cb5e745741aebbf588fb61eb1a1440fd148a25b5eed11e4823cdd28927bbc787cfbcb00f1c2c1666419af145388fd95837637f832aedc16012a6e0e2e83d22adf2a373044bb09a1c845f5e203bdcfc8c69fa8faa80afbda3a800e6674e3d1bb5dfb43d4aa4dc9f3cb31d71ad779cfcfe0cd15fc46e0838f6da07e7c19d6fe9686f704a065f8c08e210e7f5d08841082b7c471dd18f297561847a5918d26618dbe7bd5071fc26368d2b5d6c952570bb0dbd63746e7e93a3dead74f4ee3951be5793bce3a4e624952c1e5a02788b6f9d59c0c18a16770e053b762ce4bf8b920ec01078a13a100060eb34236d1383ebc8f64ec9305a0a91f28215228e86953a85021a22b8420756dc8224eca0d60b8fbd136de90b5e9b1e3433cd04f46aa9828ac45e912b16af1513776bcb23de65a97202a24513a36e3e5e4af0eee82e1d52e3f8ea081a03c06416fe2a36127482ecdc5e8707832f9f0c8f1274724cde0dd9904a54e7e82f3a9a0007139e56a5e4af6675a82f7782cff2db0faffe17e550842bf02f6388c2828ae4fff92fee104cdcfe71a7e547ab2f446b80785986ea83ebdafbcbc8a3e0c3b51ac502589456108d9e73fd202ed2be6be3736c04f98085088a2c350879dc7c8a16986c7a604127e0cee575e5777d1e401c18fe5a158c0a3064b3e28ee92c74c257c97c7f8480847ac91933ca67127186537449ae536affb0c3488c19d9a0382b5e3096679a3d8de6f4ff8572dbb5cfe9280495f6cd8fb260a9244f825697afec964279d348afd4df97425e31a042064fb76ad63c4669a5db369baf10b1b9784fddd6014baa8e5323eca774e6685e1f0a1147d8a8119b0ecc83fc883d5a3fbc19fbbafa1c0f8ae921e990d0752a96e8d5dbadd6d9ec7c12d2d4dcc5ccf5edf004a0bfa6a7bc3237f8c05b757d23171b23934287912274c546021b9e5a3dc6846e304b13c69b8c0ced3ae8a3ec03efd39b0b94602b6c9b9ff2744b126339739e41d5bca99991480d47b82cc4e6fbaaa9c63f2fb19c64808a7d0f1d8f74b1c65fa69fa857f0e8411e1886fa47aef082e6db05594c99a7732209713d49e8b9836dbaad621dc53bfdaf77ef5b3e1455c227b83cb80833ba5ada33d6109b05ab3dc90631f7f2539b9d9d9caae702071adeb3e0c7f2f9efd307d927fc1be6aa5beba76bfe2d155af71de676590821e2a25dc0923e9bc029a47604c9aaeea3f0de5e50cfec5d2e9504932b04f73dca38b0f9c5b2e202eb94c34ae546f7ef41b58110d1b19ddf27f63462448880eaf6c3cbbae40985ca7c348f991293240d52d887b70eb8f19d9b99950f413992dfc6e65fd867328c78d808d4ff2ca34d2732a7a919cd66c6c0298bc2df301401af60687831da22f23c0c41108c0b88804e8d3772be420fd6180afc2b693168c9fb57b0373d89fb7614cba09a21735d7296f9e653f22705f49222bc7e1a222b6bb61bb4cb32ac9c09a353cd9d2345edf9e41e482c4bd80a4c4212e33bfa15fbb92fa53e2bb4cd8869a284736b4d18b44759d7971761467e3594c36412bc0b791f5b5fda47887bc507a73ef3a5e47bcfd3ac398bf7349e76291f4b925b2efbbb3b32f29f41bc5f7df824785529a70a5f603376f616fe1fc67d184db65518237f7364577313b104190cbccdb79d1089eedd57b81c7a93f7916190097fa77ce7718f22714c4e410f8a1340482de5c6efd7c9bb5237b09598072f785867b13924f67839037fa0473ca1abf56f7db08e177ad02d42ccf765dc3a6b4c66093a1a99ffb3a363c5094aaa690a457677b853617b1fb64416006a056eeb963054ed4696f3d7fb65bc90245c58eecdc5f96e4f6c97086abc625afe7914920083d6604d086631b6a719ebd19a7b1992bd9c72427d802fc5c1fd895999e29461f1f579e19414381b7924ab3b777661c18e89ea888775a39f7444dec3372f86d70da086c035dc9b7c12ea0cfe14fc11d5e32b32c6676d38d59ace6529858c1a48bb39636770327ae344587bce23359ef1eda1d811b67111e842a3d984723944245fa844a3a43c8fdb9f31f1512c5c2c68e06dbebfc46475a273f84f6252f5f257b4c33e16b62018eaf4c498bf8b8884ffcfb335e41d8936353756da80da69416500b9ac3ef1279ae480a0ce6444e1d7b1eb391d1ebb0c79ab82725553d60a07e0d50a51799891fbf64ca8e5a73924a2fb7fc3f27686e84b690441ab1af04abf113fe6977bfa3cbdb0201efd108e9132bfe4d2dc44b2fb7e1210854d3fc9d912ffd9f92d990ccbf757530308e7fa649bcb1c9578527a5956faa8d9567d708de307bd75ff716c9db0b8d16480d955f959efd2257a36cf3283270b45d762f59cc0d8a733181f02c69a84e3b49a23576fc230f2ac665b757962cbcc1527961589191cdb844088f95328a245c6b6238601c748b0d690acf0cb237cf0e8476fb6f4df63636206229ee886c9ca703c79455ee7a1e53693b7d94a36d12d2013733127908f13e221ada5bce15f70c25b6d5ec185a36e1e1a2b449c5002b2c8da88538b762473819ded8ce19f667b356890f310b0a73fdbe498bc36e46371c3da331612a9ac41081ebbc718207cefc43f4abf56ad816ebce8dbaf84c933da6af5db460529718e8df27e0814b14f7ee9ae1bdfc1852e0ce9ddab6fd4b20685560eee7d7493994b4e13c95285686d4a5db55cca37aa2a833d5d0f0e1441fc7728fbf011823cb2ded48a9f9011e129e90977f1337442ba9011c377cbc21904f4c8741a80bfa6500275f04759d86bd58a8fe3b604757c707af2b7a31e5153684f68e07a81ccbb0d6cf8a02331b68eae9b5869ec455206461d35e5bf4638111d646da9b99a154b57047d7efcc66517644d4d0bce03f1fc91b0f69cd169e1b400ff50f73a7438b82f2b1883a4014fc67d28ef6f80efce6b4331758b864fbbc84577a33ecdfbcec467d96f71e5aaafd638def0d6621344bd7317cc99a0d0620bba022067c4d804285478c5a41ea7a4116a03f48e8067e8507fdaecc39a1745189db61c54f542a595d03b35b1014f499ccf723c058c733b0804a38443c0580cc5c1c5f2796cc5df41a90771ddc6820aa35ee2d7426b27b29cb526ed6cac5e5b4bd5c6c5f4bddf4cd90a27c4f891729454d6f36d75f09286bb4331cb594805072292cac3d42d18b9d33d4f1f2c90a5751ad2af09cf23855a185ac5c877b32916acf0e13c04e03afa603a1393f86c05f4e2ce3d841c01f65170d9fdb7f94a176faed2e99b935fab7d3a5677976d1a3a0c4ea3c9a04f712aee9969758171a4bbd14be033b6a3cf65287a605b5268ee6004f248f79a63661c215696139b6077e820444c0cb240295a9878f4c452b4366e684ad38caa0441e56d10356a205da3208166192cc148a5eb12194d0ce18196099dee464320ceca56238deeba12c4fb71d82913b76cdf42f40598c4106b54079c7962675b62ee9687c9be1e6345551e51f435f21d0b19bca789f3288fbd6899e0aca8749993f89196bbbd7344f703564cc06f90de9da2b0dc9c2888c13c90b5ebae1efdefc90105d1c7cb232a3ace0625ee0008a6020c7c0ab99207dab768073e028a971a880d33c6df11c3ffec51373f5653d4de79f0c6a4fd0b9f8b4250f563973be6178facfda69b30242696a11057652cc635b62d643ebb61432490e8a419eb1859ee4ad8f45c3fe45ecf2b50437094e9cb9628078a8f4f6eb8852ca19b76abbbfb9ecca9203dfaf19f4b2669795bde99404e3f025de69b4af96e4e7191c3cfdb9fa2cdbbe5beb46fc059ba11f65ad75fe9eb5884adb021d2d7b3ff17d4f6d908e132cc1533d6b63d6ad193a750dfcffe18360dde03e405869a8b19aedefdcd20d003e5b5608f26c25fb3f4461cc3409f2efa10ad410b7b6935bfe42fff5a3281e5c619b67b6c29b003d9ae32b52ca34cc5fe56c88826df255a358a671c4efbb2655258511a3157815ada235bc7433a8fdbd61ee016128c0d55540a32355ed8258de7e826997891da3f758a5f48ff28107a84e38630a126c39fad3bf8a71b89192ca98ce220aa4cd2ed1d6ce413fc5c165400ba069f5e629f4777fbcd510c99e398aeed576818824ea1f9d2c175ba406c9b1d1fb1f6f34721422a57d48a784b53352c31f8116266cf2764aa71c063eff03f4321cee14e4769d41cf0a4a79e9a3e54319954a1a98996f5726b3f9cce5fb47229ae166b10f41a50f4730598f6e910075cf38531b776f88dd4aa128cbb45e3c3744df04f99da4c6e22f2870b6571fbbfc1f0715fb2cd7ad7abbab99982dc6ba39380d6b98e83aaa52da93051e40064d64f69931e9748c9111af654acac4142151a7e9632e03f67776fb8a1399c444f6b3a6987a6405678034101315dac7bfa4ba532addc79e304e7aab491e0af470cbc2c62f1eb08c8d4993fdb9f0fb90cf46b67ecb1ced40cb900cc5ce571c1c83e241e7e846509b1c2a6cc2a50c91179fa141787add9d424f4ef68cb3fcefb0ece38bdd0dc2cfa04777293e07ac702a5923da331b09eb1eb57f656b513209852f7fa1ebecef67f4463da3d174521ee54eed2b3f93d95a516455bce0d2c200251411b054efb1ff1115289ad7e7b2167690a5ee5bae869f0402ae9a09621218a0ccaf383389b020492427f4929ee66a372fa61e3676057697798fa360f6fbf53dc9d8cd66d182bf9f69d94c852f0fa21f44f2527909f978c90a2905958e1acac063dc12f9450afca88d62337adeeac28d56ce42564b984d3a41ac42ab9d2be74fc1db930a348361c9538ea915bfad99cd0675d0527a96244c8a896b497edbabb4c64abb67e51a59b62f0af4207aea35734ea3c476db6f4bb2f3595762184088530e5a13753b9234d0bb84a761f24c9e1c34de91764c5498639296bf6ad9e9cd50a32e68b5966e279ddd7f75bb1a6f255adf329466bbe9f86c11f9d1c137b8ff68be92c9df2407e3d12e3385c212b041ce194285dca67b35878c709bcf5676faa9834483d92005032380aefce7c1a5bd39d682837054e14e23b3da5fa4e1974ce16a4f16810411a5bb92804bed32065d55cb8b1e7568f6b654c5aac68cee7f29008041aaee46c5593c656762622f3e5e8ef7959fcf48696c4a987fd48c26a3d64cbfd41a579e7b5f5b15e359839faaf9b8d927990edfade7e30fc4b837b880ae4e315082d12231c09904f1cffb1a7a63d01c0b71089f5f15c0df6d51d8391cf88d2c5477b87144f3a5f2a6fb5fd2c08d932ef93a38e67e5aa927040b22b02ed2453c6fd3075d97e5c4ea08fa07fdeb95164db0885600a8d79dda628492daa7161edd465f7a0c4193854741d8b00aed9c4fde57c61a88905ad34adf74bb2e8803e64f8d243795faf57db68dbf094243d5a02505ac032a33f8f7b8df1911b55d00579eb9b56c33d279ce0eb25c6845532eaa1e3a5f1508a5a1ad53ac03529fbc0f301b18b6d6c3c210f37b428d421010f84ebb9c7d7bc0bd2bd778a94ddadf30b862dfea2078751ded4fef47a76dae43181500b8aa45ce64798cce304b58cdc735f1a5d558b69a86261632a594e17b6dc0752ec9ef67aacfa49b1c7f81b7f2f2b6176adab98025a88658951a96e052fca25544b6115809017bf52eaa8b5b6ae2247ec73b30af9d303d1cfd0dceba5373f1a36d3a15b0e8c84e254e1201399f3e20945734679fe1c33fd9348f226ad732ad8eba53a659131d8fa0574d88dccdc5ca46a0069e61f6cfe375370fe6d0fcc62630ed56f86698e3629949d202d5cd2e71e692ec56f6f4c9a7ec0bb7eb73fc1cf252bd73fe3156c7c53e11dfc8c35b98d526defe2804b9729187552529483535eb2ed21245680e14014945b40962befadf73d347f29af35a87ec2eea15dbe1429cc0bfef4920e802381d4609279fcc7af8516b9f8fed2947cc4980f70781c45814c123f8ecb4d078aa5cd52dd20bebe0cccbb1fac6e66800d05178e35b3bec0f5c03b4d74ae7c6d762a7ed9669bc1b31b289548b4c05e562217b65b487c64043e7f29ac7493a0a32e7dc2ce9604b755befcf45e149bc9347b9ef48f8480a9ab0a506129d2300acea82aa14abb88c2ed4043f51734f0ccaf1e3b9313e4ebec87378ce920a96253239063e199380bd85de7b96fda512fedef7ced2a11acc5ba48f797138fc0fa80d082e25a5e681982f0e3bfdefa3cdb9977bf03e3ec3825737846477b22a0e10ef20e2b1fc06b24fede12d987a0004915a78cba0b065f012a170a48df3d9fe40a47bc3082b5902bf38b946a3c879a009fc4b6a4138f9d1e28c380bb9b77a48b66d2dbd4bdd1978639832bfbfee264163d09aced6391642963617a4c8b5ed933185901a9ee622d25de71532fcac1300c43d2723a28f88ae437d42995d724b56a5252029b0ce7ed54ca3eb152c3e041092fe2bd29e384a4b57a60d43d6001e5d674f59d25517b236b9a2bbaf23a82eb0217de61639762ffd2227e16c170fe822a9ed5915aa0c5b4d311f23fbf434227383b8ae46f8479798b9c1e540b3447916f772c63fae7a9aecc57d1bcda94d26d61b4270141695ffad15bdc7d9b21f78afb2731b3a05d6cd592abe04276e511723a78674b2346e2d9256572a6fdfc1a9a64aa3eaf46aa63c0262dee66c0003f8814e0516cc48b1a00fd8d7f3483ef5bd34f9dddda747d30e0e33471d8b14f766117fb565cb9bd662ac6a233782d28586322f0a992188604401375a092c309c90118e8ab5f3ed374f1207ab55278817dce1e5f9daf82a9050347d6e4caaf88e24c2508856f3e427f5c1937ae94c8fab557ec792d78e68b0c098e63f18d4897c32249013ac8f11abbe2adb6f0e22439af2b8dffded780fe1f299581c7da077efecbd6461c8d4fb20191b2166685ef3272d39393951bb96a1ac75570c404d11d9c14a7186a8058a05317325efcef04b8304c3aabc2206f721a1b515a510c0dced04017a2f5b69037c93b8ea6a405fe62dbd63cf61ad863c99599cb928cf9e635a0b4ca306438e9de6636b264eb7fb84ff92bab05b329053cbd02a2629b55e35ae8484b8c4f99dc19b05f7dae0c6d775417a56e0a7b94a93da8cab27d91fcee657b6c8d30a0bf8f1b4b51774d8b3d51fb15c1cbba0b52dc5e1090cc152299175ae8a480aafb369ad4a3a2d7945e767bbf15406bb301bb6072fde1dabdd85230bebd09569e59e270e56faed99e58d0809f6cae036d1c79676c65ea57daa21c172a797d9b2e38feebe617ce8b3944bc9216221bd6751b4fec5be938f257910dbf4be1ac4aa4943565743f1c9888befec0193ea1d1f72f902ff175afb14922cc281b47d2b302a6d3ec5e9b79154d38ceb03c6012757c5296ee2715ff591873b94d21a973217d6c4f7c815eba507d306d0cc015a1031b8eea8d6de8829ec694c97c0514c2cd10da3f46aa0741b6bf80d0cb656115f094f9840f05e898053716130f4bd7611cc5a58278c169ff014621480442a561d3742237f69385873994e1a798276a0092853090c0fc750afbd7c11549a9ce9ca1fc397f2c505e6c47062b7c7ea313ae57e2a6140a739278491183e329db5f7fd7fdf0ed3ac1746abb7b78bb9702de698756f50db80c0ccd5edf98b0488bafe667e1a568b591d27bfa6b5fb1cbfb242aee3ae30289bc5ae2e1f27217e113b27edb7577dffde0c7ccfba82bacceabdadc7e282eeb1f41eb90d5a57a9ae3c826c425f05e2b335a627826542c2057b18167bd349128e76e6b2d8149aeefac4c34753814b9cf1337d6479591521dbcd2efc7bbc512901607c80b47f564d8062a328da7d474ada531868df3b8a208804d516703ecf4ce9b35e0f1084b793de012db1854ae82933144814aecd8e1a961dbe9c761a0d041a2fc72d4bd10d2bc8067355d9466427749ca5529bd5a514b72b9ad554c34141436439d29a44b1df8950c05830e67013d550c4f689278c2e331efb8155b8d959b8080ab6323912be53e9528b78ccc4ed812daddb26d0a3e306aadb738ea3afef6a16287ea253285e8923045c632935c5344006cbaf0f8aa69d5e64177e7a851bb2370f10b1bc9148007aa4fcf8441499753d32e7de4229c9a3572e266d3e2debc5223267fd38447309accc1444bda0153fb1dacdc807dc3baf4a4dd9f8e4b9a133a2bc013615d83358e1e38c320c479fe9c514db854c91518c8c71e5effc1d62ed4851489947175f5fda5e0f426022335a3ccb903fa325399e40c8e261179580bc0c8ed5094bae74d87b978c31d2a07412030911898b50985ad6dee9a81e94483ca307c4f9c9cdc126d62cc80a2893168e4c8ab440d0e97e14f242dce6f5e9924a3c19f2d2c92981df673586975cf5d1b414a2e4359814761b4e8b2bf6b9cab29fb386d6f5dcad214b8a3614671fe2ba76b574fe0feb67e2fb4578d1d59d310540d686311c8bf0c6ad8686ab9b9642ae1c7b3c8fc2015b9bc9b0b52b9ccb7b0a8a2e297263393f0aee305cd2cf16c541439ecb394cf152d1fc7be4661db8c2b7f7cd6a5208d99be9e269bb47fa92b52b208b757b86c414a98ee65e768ca247aafba428e7cbf697ac938ca7476099c25c94770969279a9ae72371245142c7afc30fd624128d22628938a2f2a5f4d8419cd5ee93ca31edcd7666d9156c16b9f39d9f6bccea51acb3d07a69f38547532a52b314329f9e9ff24d8bbf1d2147422fc3d7e7c60f31d28aa62275cf64b18df2e7426ab030d72432f57effcc9ab8f69b536ce5d54b5c47703d903827fecdcc159e5026a7f65c4d5276ec4d3477c7355c3a2b5d5c931503df56ff6c4966b7379fe0038bb02272f6ae8931c07b4d32f490d1980535301aeb87f3049ecd92e2904f610cee76e3fcc2fe8880c1f74439f5a21eb9bcf302ae362da2a6678e1292ad9f87354985971b0eef049c617736bdc622b7c75251797f0faa00728f719681c36940a4e548f8769f4214770aa101715c4a71dd43d0b5716909233bc2848bf696d5ec07299e2680373cc8c2d2810b9884b308a7b38f7c67ff011429a086a5db23215ca87e14a830322da6d4f363f2fb3ef3f472ef78ed7f5bb765fc441163af4164320805d6bd3ef68c4d849a247023c256419f68f9e1865277c521ee98f7924274d2303e4912b4c0bbf90676ed9346e0388cd7c55349deaef3f19b84f65885c8f0135d430e3584edd1da732b7f7da02106b612e13176b623625346b42ec184cdc76cc9eb53f69292068a53d2609aeb78fe403ae72d4c7d8f4111e2f5d5c15ba4bc6389c39652b2f8dc610306c6b84f05ac6facfcdf300f7bf3f0291df9e2ad9283f4e225988673c4fa2cd1573a6660726bd5564af145a56d4c2e64f16f6a2ebf943feaa69dab20cc91104fa25996f49392a3df6970e03707d868e70662cc3080d36f1da74d85cbeb36d72dd5f53b7324da67ed068f2e132c0743c8d6cb11730e99e7b47952a81bfec1c5c579865ad8740b15866cda94fa459cd6d73f1c911d95b41db92af8a43dde204a49c940866a4bec1dffb6d0d994cfcd84a386a126cd5eacc5f5a46bd4d92cd5bc8c96f156e848910e3f1ede088d8c63d0b6efccdfe3b07dd8c2632f69d4e394d875e0a4dc2c18939165d0351ec236aa13a097d913d7bcbead9a9e3c76c97211fe2e8b75de8fe6adfc92276fa46474f19d715921274dd4f8965e8b43395064108ca92029256178d20dc9cb4fce3d827f7674b07451c7e8e7702a77b40cdbe56a1cbcc83c1be5c98b73ab7b078637e165ab8cda59c51eaf34d37b76f7610a4b395c9c3a8d0d518e8600bdb05752fc6b907b0532a7a4efc8ff7d9d50ade968aaf5cc711fd2a86f682f18ead6d32fd686bc25f8240e816acdef07d0524cc757b276f7716ed58a7bdfbf361e9baaceb8429de43e7a478f29bceaa0f8be07af90ef2e3b46b095b59258709fa57fc4b27ea07adb0638a29f916579c797ba409b250b86fd63bd347007ad4f84d0fe8f619cadf8ffcd9d908ad538fd5051c955d52dfb0b11b3a5435bb8fcbd63598a3c4a549f4a5566bfa946f338acae5e16bc35cf519970edfe730f628f3422dd92eaf6dbed5284dc2c03b466ad2b8d22d42f144545dcf3da8c9b0c7b15abec8aa13d8a4b5a59447148e5317d38266f8aee1badf102f987665469f49968c357d80a9896b8e8cb9775761ebab3b9cb1c4d0f0540c89b16c34c201b51aabf9e6635de63493f26e12d6b2a4d55f191877d61fa033cde4d01940fc4dbdc7e0fb08c52dcdfcb726180548d27f5284f519abf097122e97726f94a80521a557b58d972aa86a8c201ac0a550f65c1164eeb50d145f47cd3265de4467939b51ecab0a74d623f7988c37de77a12bc59d209894df4bc7f00298d472836e47e453d330732b0ab50a8c9ffeca3e2952549ea3272049dc8fce0a404709332aad882a231b7d21dab218633e3ad614d284d116dd15263f1c4da171a6523c31d7d6e0b5650282ec157220329fba280365c95836a8ef2ebbb93fc567bdf853cc7c0a343ebbff9f4e03655cc5e7dbe5e3ce862730c8bb7e08440e779b81565a46133fcb838fa5707a78837d110784477b5601a0af30432a8222b013b1c6ec4fe7e0779641827ecb2e23fe053553ce519c0fa3723fdbef532c1b57e3219bfdd6f531de267b81e0ddcec52a6e478e0444c53a6d16d1823c925b9dcd6d0d926378741c70ef47cdacb409cffe7a963c1912c697b10d4ab78ed4f7ecee83774442b431bea556a41b31a3e39a9ca42d801df60545f0a08a886030759044decfbd560485d6206e1dc21ec6d19af63cbbb7e4553ad452927443b28c8646f267009daa508c04730fe5cae82400f7495c3cb806e2656f25c41b6d2cfe320b55dd10e2ea76a6789c831923aa50a1238013394c218f8c27e9d5467b07d3ea41640214aa91105a423920485fc3a5a2ba81e9603d0e0ee6acd796c422181a5defc8b5ca5ea150b1f431c9acf611744e4aa3f8f0ceb23cb46d3e891a7e58b3b187151926c85778b3b81b0b80a1cbae4017f287881a57ca69f9dc6244b669841e24cd448b7dc1a074b072583d558f09a4390090545552c01000f66dd1f14764556cab15da1b4f8f2733c26b6bed8d316933fc3a24a80c122af0faee214a25932cabc5534adb6c53ea2cf2a09513eba5f927d20d2a5953b57946ef305953070b7cca8ec65b67588d5e1f38f4b7ef16175855427f93284168e3b524a0175e70f05de717a159e0ed3a7fe5e6ddbffe732bafe177d7b6803bdc48745832ca1f5941305a6593d18e6d654555246c4a638461b72afe1a3b1dc08148987acb4201dea1d9cd165e773fc355278a06480cf2000377aa8b0ab4f5b972b2f6d96f095a8292392600055a6e1198312bd1c4b6449c15579e0074e231ea37a315a9719d3967964baee03752f32bf28f67852e16e37736ac29703bd4adf48e9706619072d0e0bfdb02303d65806bb841d599197b8337dfc1f9e59f1cf6010f4aebc975df46ca4513434408721ee2934c992d2b65a1d198ac65f1c5b96888cffc99c82367986640b2369a729c50b0bcf1869d86d7b043479ae419498a97bda9ec3b0ca785bdf7b45a9553ed0a08d419c23e6738cbd571f602738cae196979a8ecb8eca6b1ad70eafd4f481c4ceb81a67519937386e6bfe7b75b11cfa1839d566ef7787a215164878c0fbaead3cb9331b9b8cfbe0bd6cfaa29706243d0483ef3034ab2969380ff430b76e144a477f0dc16673c336b98f566293d03f31661baac0eca180fc2c89ded4523026fe9c386dad76d15f9e83392cda0f17032274fb41f87a1579ab166c40301dc69a67df0aca327f181c7596b6d196335da6a1fc9a1d955dd62c36ed68cac7d083b329d782b700100f5c79c22c894cf8fbccfd992aa61268416a09158413e2d9c2bab571dd16c6a85b8e34ede999b7375a48d27a843dbfc85a8118b054545e20ef6ae9cc2ef844cce1ce2f16aa09b9c918614b3eef40d5817ddef9b17792d4861c8daba19e183db6b78c0e7a3cd449087ade0f2934f759e0debed11c82f90444d1d3fb55756223ca888e0dca3c99ca5cc55e7303aca4d8c562e23507774f136d0cbd6f5e615f954ad5c56b409d66d491ca78ef6f6d543c355ff1f0a86e42933fffe242c7165ab6e5c680478aff226ad1e58046b8483870b0a9261d0e24bcfcadaf939b9790f75a5e29a24f391a955c72997158b19c0380747ce3e131610ff77f2dee9aea912b5d4c2bf43d8303641ac3736dbe4ffa7e2013431f9acc36b3c90ead9172fef36f0ba9ab9bd0798198e7b98b3a9f4ba01f58d7ba6dbf90f357af4fee046e8180d7064762e9d4ccb14400cc5aeabff543da0076c21c47c421c54207b0299834990da7b80c145e7b2964d7f82a2179a50c8e2c9e0c6b851ea43f6f06ab3c91bbdadb47d0637c90dc54d16c519f1f8a58f1c8e0b1881dcc4bad96e146a41ed18d2ebfad388f5ae6ca40c3bdfa3b33af058f42d2e84eed956711ab00b8c4c9c2ba27b5415c8a73b810a98a2f22e98594c7e7adbe7f0a108319cd2e02887ccedd444aaa9c488a68f1cc2916d2b80e028b8101dc1b17ece8bd0d5f74829eb897e477af277437a01e5118a089c8f8405573cc1556404fadbbd50e6deca7c6da31eb6f889aa87b0234e24947cc42ec4aa45578f4f96f1cb9bdb65cf2ef1eec3e6816f735cc7eb58b92a25e92a6be2910e9c41b36a0edc7311be1c24499172833ce34a5a80000d9d7e49e9fd68b7f33d23a65ec8d2eea8389e26cdf8d49f81f12b843e0691816e58e9a8c7089b141197ec03821de0c4cf36b55bc236d68038deae6015f9fa3cdc42e8015e1aaae001d4d62e720dfdbbab2513eecf59d853c4dc15ad7fc83ee8fc97ab96e5cc136671b5222da99705d01b0d7bcff5766de5c28d8a6ef178b12f8c315818dad118d5a46a982323d429fd6cb82e5adec07979ae4356b879f7a4526d3dace8c2bcb615592863e47a78dabdfd3a79086d19bd73bc1c7903c872628756fdc9606b57118370ca9574bc20739ad063f9ebd5a695128f2215dfb23f5da0e01c9f4a02bbf450e6ab880f4636e06d8166f900b7cb737414478b155c7703ed2226eb7a3b0bd5b6b60a52f91c1bf0b73cfc93b57adea960d52e55834a84ecabdcc33fea21ec20bec0d593f0dc5fcc601f868e701e93c3d715437486a10ad56d994668a24ad8dbae9b268909ba60658fffa49b89aa39e31a4242e9af3bd8fbf73ad0c3de7e6b013614a2c5f81bf7fdabf20b0f22e358b77a76af30bdf02638080126f7ca2ff2bfaaee209c6d8bed2161f0c8776ceb7dda52861ca4bc283f366c9561e962880b9f22c19d429585a7192313525f511dd0b256b24af09589b4d3efa6678d27481b83f72b0a3a2c8103157b5d30be2f155be231c6db14d8576f47313c5a1a6ccb24529a196abc2d97dcaadc2353d004ca46ca01f6b171ee600659227f78b9096a86215b98900cb8e7129f2df2610bfe5efcb0701799211def516a4373fd9628640b7c92ea251644d68688dcf820a938957f633e9a2fa4498bce1c951ca8544ea0c8b4848ffbe2f4c287ffcfaf8d5b2c0efc1908e2f4026505e98ad4b842d4bd2443ba3d2c95ca36a09517c5ea951138fe039993e47de2754c679f5bb111e58eb13fd5055c1c17c5599c79af922d983049433dc8f656917e1d6b8897ad0c1991a8c3c1929d886a76382eee4606e0e2bb0ca5076b8ab7e6d797c632c69fc5e5746f6fe53f674820a482e116cb1c5580da072a25ca72094122dc51a6d9283d8be6f8056538fa96973880457971fd4a6c21ac668356eaadb2129093b110c7486829b7a8c071978de9d7aa07821751e78cdad9277e5fda970afaf433964052967e7c3ca62990bc14032a695a4d8b5b230fe72ba9fdfdc37fbd177ef0cfc84c10dca6acdd8e992ae1600ed7f98c8a787b380dfde1e4f20abe8e28067a90ca1a3e44339c666a831f188075f5df9d7d978f97916ce0e6e96bc0bcf77048c863632ec73dd7a91266e5f95a4471e33e28b349fed6fc9f401d8f563d579054b8d1dad1521dd136994a97b3fd41a55a46a9914f670c4a5f72adceb826e925d4a425fee874ac3aeb5407236c6d516d62c9ff2c0a99b72151dca3fd4e87a0b8f4c4688f7295f0ff23f6ecee4c156c08331be3008dca80e690bef0f3753ede575d4abeccafae020c592a65ef56064d4ca95fb45f984a8651e734accc094d21b19e3f9146a81fa9d96bc52f140a4eb8e04291a0ffcd2314804f161f6642cc1ede319c843f794b3d026326e1549c20a6570fd795814cb0143227383554a8442fade55c28b48ffc3d8acaaf1629e6cdb1457f6c65170eda0a44174a2ed137a03a2fa5eb9c4a1fb4d5fd478d4ec77fac813bd21102f5c49f3e5ecf095c6695886d106ecd8e7d4f6a9fbcfcce581fdbcfce9af8a7a3cb38150d19503d0c82e16f7f1493fa735825ddd3bdb51a8c326ad1f6a7f108701b95c4b7290360f81659cc98cca6080d75e5db7953ea3ffc9c5515963c7cdc97c8c4b7e94f79b886448bc8daa7976656e8b5ab1a4653380af75e6708ee82ccf9d5fb232abd85dcc904f831fef3362d0c4c66cefe42f3d2b3f6204d2fb1e1a01371b2bce1609999585ce535e92abfdec5e33c31e1d770ce7e07cd80f5afa7fafc411c38db717673071033dc34ca3c0b6ac2fc5b5809136c91c706985b293f87bb63a51ecc8c14fae06dd060c844fc7bcdfba0d143232ac17b7468fe22cfa1c6e517d9bec8ee9701927057b79997471627db1bef083635c28cfebff9d9398577299e4e779810ae5935bd71e630afdea025d47b7ec738f1de088b7c7bce1785ff56d8513e3b351175b2d40d3ed0442e51bb014f505d7db46c460ff6bc1ab27cd70b81fc2b14b559f21eeb59c7b1ee5abbed56634cbb52f46d1719e1f1d436628d0d3b82c57f19025a5ef70c496ca340f1474b9f27d65e1a4eb439dbf0ec778cc7dd4afe9d199bd109d7821a972bfcf79b88fd87192a5d5f25e0b57f0b9230b36051b093604a9b687ace67291ebd2a9f5309ab9de202e2daa15b920dcb0842ca037c530daf1761c99286fa0f64b03e2cb11f585eb11dfb94d1f490b113b0e27e02a6e9f46629272591945218c634f6c528d3121aeb521fc8b4cf5c8c4b59754b86e3bfcd5ec9fce6a12c38578b98a343b1e6e05d088f256b91ddd27775753e3d208c78a72d2a70d80127ad3740c82c3b6e26208d51ed470c58af4a37a4a6541a743ef067357d42ed8ef56a3e77cf7a1dfbb3fe0949cda4beef6d3d47f2584ae952c28be15825a34b0fce021468b850e0a59d0c9e62748f7c2931658a411ead00ca4114b0396360302e20d30a95f315a5c86c94bcb8893701fd984c31d17687f00ef9e878b4c5c10f035de4309332b8d777aca634911eb39f8b8a6fedf5ba492919e98c8e69f82c4d717527beaade4ab509d46e6c435dc5a6d93e0afc7d792e881d528b6fe1b0a3cdd19ec0a2a0b19920ee2054e857bb347b6d0b8adc87dce9f1c6bc5c3649c5806661773f0b6543b84441a2132bca2dae63518be4e034ce032b2d3d6bca1d5b3b5c0b6bd773bd6877a7d8591796d697d6d90300a52e233f7c1d39345215cc1bc9dae9b91cb3a5f1a93f45ff6a00700d0f85f8776f93d8628f4fbe7295fba3de53fda928c93fba0dd3a480c58e45f72c1777a82c468e626c83673fd266eb6c1cd3a8c1c8f06cfc0a0f254f69449d843297f9aeb9a0d9e7b9983d460eade56f43e41853740321bcb936f350efad</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空_无 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拖更———炸蛋纽er &amp; 计组小科普</title>
      <link href="/posts/33655/"/>
      <url>/posts/33655/</url>
      
        <content type="html"><![CDATA[<p><del>新坑+1</del><br><strong>关注 <a href="https://space.bilibili.com/39521068">炸蛋纽er</a>谢谢喵~</strong><br><strong>关注 <a href="https://space.bilibili.com/39521068">炸蛋纽er</a>谢谢喵~</strong><br><strong>关注 <a href="https://space.bilibili.com/39521068">炸蛋纽er</a>谢谢喵~</strong></p><p>相关链接：</p><ul><li><p>视频&amp;仓库：<a href="https://github.com/ZDaneel/MyManimCode">ZDaneel&#x2F;MyManimCode: 存放个人制作manim相关视频的代码</a></p></li><li><p>up的blog：<a href="https://zdaneel.github.io/">leenadz</a></p></li><li><p><a href="https://www.bilibili.com/video/av492622096/?p=1">理解计算机物理内存，从位、字节到字，以及寻址的双重视角</a></p></li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">主要介绍了物理内存的基础模型，内存地址的计算方法，位、字节和字的概念，寻址的两个不同视角。</span><br><span class="line"></span><br><span class="line">从0开始学manim到完成共花费了50h，剪辑和ai配音共花费10h。本来计划的是cache的知识，但一开始的内存部分越讲越多，就成了单独的介绍物理内存，算是比较基础的科普。</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.bilibili.com/video/av493658546/">理解计算机Cache：从块到缓存结构，以及逐步推出映射策略</a></li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">主要介绍了Cache的基础知识，包括块的概念、与内存的映射策略和缓存结构。</span><br><span class="line"></span><br><span class="line">代码实现花费20h，配音剪辑花费15h。</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://github.com/3b1b/manim">动画使用ManimGL v1.6.1</a><br><a href="https://github.com/ZDaneel/MyManimCode">源代码地址</a></p></li><li><p><a href="https://space.bilibili.com/5859321">配音使用AI星瞳在线语音合成（Bert-Vits2）<br>作者：Xz乔希</a></p></li><li><p><a href="https://space.bilibili.com/401315430">声音归属：星瞳_Official</a></p></li><li><p>参考：</p><ul><li><a href="https://docs.manim.org.cn/index.html">ManimGL 教程文档</a></li><li><a href="https://www.youtube.com/watch?v=V_QS1HzJ8Bc">Direct Memory Mapping</a></li></ul></li></ul><hr><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>前两天中午买完放回宿舍打开平板就看见：<br><img src="https://picdl.sunbangyan.cn/2023/11/26/2f2f5dc2ed09bc48b7ae482c40d3a19c.jpeg" alt="2" style="zoom:45%"/><br>好家伙！下饭视频不是来了2333······我点进去是合集的第二集，我就看第一集——计组相关的科普吧算是。<br><img src="https://picdl.sunbangyan.cn/2023/11/26/e6a6be4cd8ad86e896db63a9a81334f8.jpeg" alt="1" style="zoom:45%"/><br>AI配音，而且语气和声调调得不错，动画、PPT都不错，只是我听不懂——问题不大！<br>于是开了这一个坑，其实也就是以这个视频为主，弄懂视频讲的就行了，不深入，有时间就搞，没时间先搁着。</p><hr><p>然后跟up私信聊了一下：</p><ul><li>谢谢谢谢，我现在大四了，在学语言的间隙重新再补基础的知识，机缘巧合下做了视频。文案需要的话我整理下放视频源代码的仓库里。关于视频和书籍，推荐一个up清华邓博士，我比较认同他的观点，<strong>视频是高度浓缩的，看不同老师讲相同的知识可以得到不同的视角加深理解，而书籍里有更多细节作为补充。但不管怎样，多写肯定是最重要的，多写一些高质量的lab，这也是我遗憾没有一开始就做的事。</strong></li><li>视频方向还没什么大想法，接下去我时间也会比较紧，可能会做一些有意思的内容，已经有一个想法了，也是会跟之前的有所关联</li></ul><hr><p>还加了up微信，哈哈。<br>这里面的东西我都挺感兴趣的：AI配音、MainmGL、视频剪辑、py（up的代码是python写的，1000+行，看不懂······python确实强大啊）</p>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归档（拖更√） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以文学视角评价超越时代的巅峰之作——《白色相簿2》</title>
      <link href="/posts/23610/"/>
      <url>/posts/23610/</url>
      
        <content type="html"><![CDATA[<p>原文出处（已征得转载同意）：<a href="https://mp.weixin.qq.com/s/ahzS_uIqVofRT7AMPkIwMg">从文学视角评价超越时代的巅峰之作——《白色相簿2》</a>，只知道睡觉的觉皇 Galgame批评 2023-11-22</p><hr><p class='p blue center logo large'>白色相簿2</p><p>又到了白色相簿的季节。</p><hr><img src="https://picdm.sunbangyan.cn/2023/11/22/56a25beeee22758bbff35056c4ae2e7d.jpeg" alt="1" /><p><strong>《白色相簿2》作为Galgame历史上最成功且评分最高的作品之一，直至今日仍旧霸占着亚马逊R18Game销量的榜首（2023.11.16），其在浪漫主义作品中融合的“现实感”的做法令观众津津乐道，关于白学的品鉴分析也一直存续至今。本篇专栏想从文学的视角来谈谈这部超越时代的巅峰之作——《白色相簿2》。</strong></p><hr><p>余华在《鲁迅是我这辈子唯一讨厌过的作家》中写道：“鲁迅已经从一个作家变成了一个词汇，一个代表着永远正确和永远革命的词汇。”</p><p>如果要在ACG作品中挑选一个成为“词汇”的作品。那我想《白色相簿2》再合适不过了，《白2》已然成为了一个“印象”，一张“名片”。只要提到《白2》，无论是否玩过原作，人们都会联想到那个名场面以及它带来的影响力。尽管现如今真正体验过原作的人并不多，但每当宅男宅女们提到冬天、提到三角关系时，那个经典的分镜也或多或少会在脑海中浮现。</p><p>纵观那些屹立于Galgame巅峰的作品，似乎只有《白2》的设定显得日常且平庸，它只不过是一个设定在校园和职场中的，几个学生与社畜之间的故事。它没有《兰斯10》那样恢弘的异世界设定和独到的游戏玩法；没有SCA-自笔下《素晴日》、《樱之诗》的哲学思辨；没有《樱花、萌放》里奇思妙想的魔法世界；也没有《Ever17》、《命运石之门》中有关轮回的那般丰富想象。同样偏向日常的《Clannad》、《Summer Pockets》中光玉、七影蝶之类的超自然设定也并未在《白2》中存在。</p><img src="https://picst.sunbangyan.cn/2023/11/22/e44f069662776b7af8130c73f5cfd592.jpeg" alt="2" /><p>但是，站在山巅之上的作品一定有自己的独特之处。丸户史明用残忍却温柔的笔触，写下了这部理性的浪漫主义神作。残忍在于其令人扼腕的结局和悲剧的内核。正如亚里士多德在《诗学》里所说，悲剧的六个要素中，最重要的是情节。情节乃悲剧的基础，有似悲剧的灵魂。那么，《白2》是如何处理情节上的悲剧呢？</p><p>人们都说悲剧是把美好的事物毁灭，《白2》则是先创作出美好的事物，让观众爱上美好，醉心于略带苦涩的甜蜜毒药。明知悲剧不可避免，沉溺谵妄美好的幸福感和无法阻止悲剧的无力感在剧情的深入中互相交织。在中后半段，故事无情得将美好的事物撕成两片，强迫你选择其中之一。而这也正是其温柔所在，它并未毁去全部，而是保留了一部分美好，让观众仍有所留恋。最后利用尾声、AfterStory和广播剧、电子小说等“番外”展开稍稍填补观众内心的空缺，或舔舐曾经的伤痕，或再补上几刀。</p><p>当然，玩家口中的“胃疼”并不是说着玩的，在这个没有猎奇的作品中，生理不适的情况真的有可能出现。这并非是因为画面的惊悚和文字的血腥带来的生理不适，而是对情感纯粹且真挚的细腻描绘所带来的痛苦，表达了一种不能承受的生命之轻。在体验作品的过程中，笔者也在部分关键内容上出现了“呼吸困难”、“心悸”等生理现象，随之而来的则是不经意间的泪流满面。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/0414614b20d678e57e047f75ef1da475.jpeg" alt="3" /><p>凭借出色的脚本设计，《白2》贯彻了悲剧的内核。这里可能会有读者感到疑惑，我觉得部分线路的结尾还是挺幸福的，为什么笔者认为这是悲剧呢。这里我想引用朱光潜先生在《悲剧心理学》中的观点，“仅仅有没有不幸结局这一点，对于一部伟大的悲剧来说并不很重要。”仅有苦难和灾祸构不成悲剧，至多是苦难剧或惨剧。对悲剧来说，紧要的不仅是巨大的苦难，而是对待痛苦的方式。没有对灾难的反抗，也就没有悲剧。</p><p>小春线对校园暴力的反抗，和纱te对整个社会规则与人情束缚的反抗，还有那贯穿终章的，春希、和纱、雪菜等人对自我过去经历的反抗。这也是《白2》中没有传统悲剧中角色失去生命、失去记忆等桥段，却仍能展现悲剧美的原因。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/de48b72fce5b60642d1b9bf49796d6e7.jpeg" alt="4" /><p>就这样，丸户在一个完全可以自由幻想的虚拟世界中，给观众划下一道道现实的伤疤。这里的现实不仅指对观众造成的现实影响，也是指作品中颇具“现实感”的内容。虽然《白2》是在二次元世界中演绎的故事，却有着浓烈的现实色彩。不同于其他二次元作品中虚幻的校园，丸户将少许笔墨用来展现真实的校园与社会，观众能在部分内容中真实感受到升学、工作、交友、处理人际关系的压力。作品不止聚焦于爱情故事，在上述的刻画中更体现了主角从学生到社畜的成长经历。</p><p> “无论多么大的爱情,也不可能从社会逃出去,更是不能和社会脱轨。有了想法就突然坐上电车，逃避现实，然后大结局，这种故事怎能让人信赖他们之后的人生呢？”丸户史明是这么说的，也是这么做的。他确实在和纱TE里完成了一个颇具现实感的结局，而不是充满二次元幻想风味的爱情故事。</p><p>许多故事在叙述时总会按照遭遇挫折——受到鼓励——奋发振作的心路历程来讲述，这样一套叙事逻辑是经过市场检验的，也是不易翻车的，受观众欢迎的，但也正是最不符合现实的“童话”。因为不是所有挫折都能靠鼓励治愈，也不是所有努力都一定能获得满意的结局。这或许正是《白色相簿2》中想要表达的内容之一。而想用环境和角色的塑造讲好一个现实感十足的悲剧是相当困难的，想要做到逻辑自洽，就必然要在设计上下功夫。在这一点上，丸户史明用两百万字的文本量交出了一份满意的答卷。</p><p>打个比方的话，《白2》的部分内容就像是发生在二次元世界的《飘》一样，只是《飘》中二男一女的三角关系转变为了《白2》中的二女一男。</p><img src="https://picst.sunbangyan.cn/2023/11/22/ad4726f896f822d2bd1d917b3f9e9845.jpeg" alt="5" /><p>在叙事的过程中，《白2》对插叙和闪回的使用登峰造极。故意利用关键事件的缺失，让自以为上帝视角的观众并不能知晓故事的全貌。又在其后的发展中，或运用插叙的手段，或让脚本中的人物进行自我表述，填补线条上的空缺，串连起一个完整的故事。</p><p>在塑造人物的手法上，《白2》并未使用很多其他作品中简单的“贴标签”手法，区别于千篇一律的“扁形人物”，《白2》中的角色几乎全是立体的“圆形人物”。雪菜神性般的忍耐与包容有目共睹，但也借由剧情的发展凸显其身为“人”的可爱。在雪菜TE线中，观众也了解到了雪菜的心路历程和其为何对男主如此包容的真相，完成了对雪菜圣母形象的逻辑自洽。和纱的怠惰与对男主忠犬般的依赖是她的明面，而坚毅的情感和敢于断舍离的暗面也在“浮气”、“雪菜TE”线中得以表现。</p><p>无论是和纱还是雪菜，其角色画像都不是一条线路能完整表述的。这也印证了前文所说的“叙述思路”，因为其出色的叙事手法和对部分信息的刻意隐藏，单一线路中的故事只能让观众管中窥豹，只有完整体验整部作品，才能感受到角色与作品本真的魅力。当然，这也正是多线剧情向Galgame的魅力所在。哪怕不跳过选择段落的重复内容，你都能在重复的体验中发掘出全新的内容体验。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/03fd45d6166dd649dcebfebefae7ee0c.jpeg" alt="6" /><p>在终章中出场的另外三位角色也各有其特色，麻理没有和纱那样一走了之的决绝，也不因对男主的宠溺而像雪菜一样包容，令男主经历了从犹豫摇摆到坚定果断的成长。尤其是尾声狡猾的叙诡手法，让麻理线的含金量得以提高。对于小春来说，虽然我一开始对她与春希交往的感到突兀和诧异，但随着体验的深入，我逐渐理解了小春这一角色存在的意义。我们通常称小春为“小春希”，因为她的处事态度和逻辑与春希相似。小春的存在就像春希的一面镜子，让春希看到属于自己的那一面，让他能看到自己身上的优缺点，从而领悟到自己应该改变什么，应该坚定什么。千晶大魔王的存在则是男主经历的见证者，但她也在交往的过程中“假戏真做”，不觉萌生了情愫。也正如游戏中所说，麻理给予了“我”勇气，小春为“我”指出了正确的道路，千晶则教给了“我”答案。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/bfff5013d864987751fbe4d70166c31c.jpeg" alt="7" /><p>除了几位关键角色之外，哪怕是像柳原朋这样出场率不高半边缘角色，也演绎出令观众爱恨交织的多面体。一方面她对雪菜的捉弄令观众不满，另一方面，她又切实推进了主角关系的进展。最终也确实成为了雪菜的朋友之一。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/e38a4f0094ef5e7346e9369f04b874a8.jpeg" alt="8" /><p>可惜的是，白学名场面、“明明是我先来的”等内容，伴随着出圈也产生了解构的现象。诞生于机场的名场面原本是一个情感交织的复杂命题，是由矛盾所导致的苦难，是浪漫主义的具象化表现，也是一场角色内心冲突的真实写照。这些内容却在传播的解构中被消解淡化，只留下了一个经典的镜头，变为了一场戏谑揶揄的狂欢。“明明是我先来的”这句经典台词，在单拎出来时也显得像是怨妇的无理取闹，反而失去了原作中那种痛彻心扉与深入骨髓的悲痛情感。</p><p>《镜与灯：浪漫主义文论及批评传统》中指出，世界、作家、作品和读者是文学批评的四个要素。所有作品不得不依靠读者的阅读而真实地存在，否则就只能成为潜在的文本。所以，对《白2》内容的解构或许是出名破圈所带来的不可避免的必然后果，当然这样未必都是消极的，或许也会有更多玩家能借此机会接触到《白色相簿2》这样优秀的作品，转而成为这部神作的忠实拥趸。</p><img src="https://picst.sunbangyan.cn/2023/11/22/eb73fcbbe6ffc0731a9985852f3dc6a4.jpeg" alt="9" /><p>通过荡气回肠的剧情故事，现实感的描绘和丰满立体的角色塑造，《白色相簿2》成为了我心目中超越神作的存在。它已然列入我个人的ACG作品排行榜中第一的位置。在推完游戏后，我也产生了不想游玩其他作品的“脱宅”反应。在《白2》问世后，也有不少ACG作品想要重现“胃疼”的现象，例如颜艺社的《恋爱成双》。但它们都很难企及《白2》的高度。哪怕是丸户史明本人后来的作品《路人女主》、《契约之吻》，都再难与《白色相簿2》的高度并肩。或许这也和《白2》本身现实感的设定，以及Gal这一产业的日渐消沉相关吧。而《白2》十年来屹立于各项排行榜前三的辉煌本身，也成为了其超越时代的见证。</p><p>对浪漫主义者而言，作品就是第二自然世界，所以，我在这里也衷心祝福雪菜、和纱、春希、武也、依绪、曜子、朋、麻理、千晶、小春、孝宏等人，祝愿你们能幸福地在《白色相簿2》的世界里过完一生。</p><img src="https://picdm.sunbangyan.cn/2023/11/22/55b092bc99ace691e704f40d7c74601a.jpeg" alt="10" /><p>在我推完序章部分时，刚好我所在的城市下起了今年的第一场雪。我也很久没有经历过这样令我沉迷的游戏了，想起来上一个令我这般着迷的Galgame可能还是代表夏天的Summer Pockets。或许季节也在冥冥之中赋予了我一层buff吧。在推完整部作品之后，我立刻提笔写下了这篇四千多字的评价，如果你看到这里并且觉得我的评价还算不错的话，请给个三连支持一下我吧！非常感谢。</p><hr><p class='p center logo large'>写在后面</p><p>又到了白色相簿的季节。在写文案的时候，看到着游戏里的CG、听见那一首首熟悉的BGM，好几次不禁潸然泪下。</p><p>因为是从文学视角的点评，所以仅展现了《白2》在剧情上的闪光点，并没有涉及游戏音乐、原画等方面的内容。引用了一些文学理论和美学相关著作的观点。本篇内容尽可能通俗易懂的浅显评价了《白色相簿2》的整体文字部分。 </p><p>本篇并未涉及党争相关内容，也没有讨论哪个结局合理哪个结局不合理或者谁是真结局，尽量保持主客观内容的均衡，我认为一千个人有一千个哈姆雷特。每个人都有不同的答案，如果读者有自己的想法也可以互相沟通，思维的碰撞才能闪耀出灵魂的火花。</p><p>其实关于《白色相簿2》可以谈论的内容很多，本篇内容中的小点也还能细致拆分出来详尽分析，例如悲剧美是如何在游戏中具体体现的，白2的整体叙事风格基调，或者是从空间叙事学角度进行分析（游戏本身并不是一个单纯的第一视角游戏，从男主配音这一特色就能看出，本期专栏主要还是对人物分析角度着墨）、以及对每个人物本身进行更细致入微的展开（例如几个角色家庭背景产生的影响，雪菜看似美好的家庭对她的影响、和纱成为怠惰女高的家庭原因）等等，但关于文字内容的大体分析到这里就暂且浅尝辄止了。</p><p>最后，感谢所有喜欢《白色相簿2》的人们，感谢丸户史明，感谢游玩过程中“IMay.TuzKi”和我的沟通交流，再一次感谢屏幕前的各位!</p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈——线性结构的应用之一</title>
      <link href="/posts/34532/"/>
      <url>/posts/34532/</url>
      
        <content type="html"><![CDATA[<p><strong>栈和队列是一种特殊的线性结构，是连续存储或离散存储的一种应用。</strong><br>此为链式队列。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一种可以实现“先进后出”的存储结构，类似于箱子。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul><li>静态栈</li><li>动态栈</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>出栈</li><li>压栈</li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ul><li>函数调用</li><li>中断</li><li>表达式求值</li><li>分配内存</li><li>缓冲处理</li><li>迷宫</li></ul><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    <span class="type">int</span> * m = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如静态变量p和m是在栈中分配，由操作系统自动分配和释放。而<code>(int *)malloc(100);</code>执行后，将在堆中分配一块100字节的内存，由程序员手动分配。<br><img src="https://picdl.sunbangyan.cn/2023/11/24/8b16547b47f71dd4d754e2e88f5e2a34.jpeg" alt="1" style="150%"/></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @version: 4.0  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-10-17 19:42:30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE, *PNODE;      <span class="comment">// 定义栈节点叫Stack_Node 和 pStack_Node 更好</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PNODE pTop;</span><br><span class="line">    PNODE pBottom;</span><br><span class="line">&#125;STACK, *PSTACK;    <span class="comment">// 定义保存栈节点地址的 栈指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(PSTACK)</span>;          <span class="comment">// 栈初始化，造出空栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(PSTACK, <span class="type">int</span> )</span>;    <span class="comment">// 压栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(PSTACK)</span>;      <span class="comment">// 遍历</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(PSTACK pS)</span>;      <span class="comment">// 栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(PSTACK, <span class="type">int</span> *)</span>;    <span class="comment">// 出栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(PSTACK pS)</span>;      <span class="comment">// 清除栈</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    STACK s;    <span class="comment">// STACK 等价于 struct Stack</span></span><br><span class="line"><span class="comment">//  PSTACK S = (PSTACK)malloc(sizeof(PSTACK));  // 没必要，画蛇添足</span></span><br><span class="line"><span class="comment">//  PSTACK S = (PNODE)malloc(sizeof(NODE));     // 结构体类型不一样，不能转换</span></span><br><span class="line"><span class="comment">//  PSTACK S = NULL;    // 大错特错！</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 郝斌老师：</span></span><br><span class="line">    Init(&amp;s);</span><br><span class="line">    Push(&amp;s, <span class="number">1</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">2</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">3</span>);</span><br><span class="line">    Push(&amp;s, <span class="number">4</span>);</span><br><span class="line">    Traverse(&amp;s);   <span class="comment">// 目的是便于输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上————没必要，画蛇添足。</span></span><br><span class="line"><span class="comment">/*  Me:</span></span><br><span class="line"><span class="comment">    Init(S);</span></span><br><span class="line"><span class="comment">    Push(S, 1);</span></span><br><span class="line"><span class="comment">    Push(S, 2);</span></span><br><span class="line"><span class="comment">    Traverse(S);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span>(Pop(&amp;s, &amp;val))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈成功！出栈的元素是：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈失败！\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Clear(&amp;s);</span><br><span class="line">    Traverse(&amp;s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Pop(&amp;s, &amp;val))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈成功！出栈的元素是：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈失败！\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">    pS-&gt;pTop = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));     <span class="comment">// 新建栈节点，头栈节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pS-&gt;pTop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pS-&gt;pBottom = pS-&gt;pTop;     <span class="comment">// 栈顶和栈底 都指向指针域为空的头栈节点</span></span><br><span class="line">        pS-&gt;pBottom-&gt;pNext = <span class="literal">NULL</span>;  <span class="comment">// 头栈节点的指针域为 NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(PSTACK pS, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));   <span class="comment">// 新建一个栈节点</span></span><br><span class="line">    </span><br><span class="line">    pNew-&gt;data = val;   <span class="comment">// 给栈节点中的数据域赋值</span></span><br><span class="line">    pNew-&gt;pNext = pS-&gt;pTop;     <span class="comment">// pS-pTop 不能改为 pS-pBottom</span></span><br><span class="line">                                <span class="comment">// 栈节点的指针域保存下一个节点的地址</span></span><br><span class="line">    pS-&gt;pTop = pNew;    <span class="comment">// 新的栈节点变为新的栈顶</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE p = pS-&gt;pTop;     <span class="comment">// 指针指向栈顶</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p != pS-&gt;pBottom) <span class="comment">// 是否遍历到栈底</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;   <span class="comment">// 下一个节点的地址，栈节点的指针域保存下一个节点的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pS-&gt;pTop == pS-&gt;pBottom) <span class="comment">// 栈顶和栈底都指向头栈节点时栈才为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把pS所指向的栈出栈一次，并把出栈的元素存入 pVal形参所指向的变量中，如果出栈失败，返回 false，否则返回 true</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(PSTACK pS, <span class="type">int</span>* pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Empty(pS))   <span class="comment">// pS 本身存放的就是S的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PNODE r = pS-&gt;pTop; <span class="comment">// 指针指向栈顶</span></span><br><span class="line">        *pVal = r-&gt;data;    <span class="comment">// 获取栈顶的数据域内的数据 </span></span><br><span class="line">        pS-&gt;pTop = r-&gt;pNext;<span class="comment">// 新的栈节点变为新的栈顶</span></span><br><span class="line">        <span class="built_in">free</span>(r);    <span class="comment">// 内存释放，否则容易造成内存泄漏。释放r所指向的原栈顶节点的内存</span></span><br><span class="line">        r = <span class="literal">NULL</span>;   <span class="comment">// 避免野指针，NULL 是拴狗的狗链子</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(PSTACK pS)</span>   <span class="comment">// 清空栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Empty(pS))   <span class="comment">// pS 本身存放的就是 S 的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PNODE p = pS-&gt;pTop; <span class="comment">// 指针指向栈顶</span></span><br><span class="line">        PNODE q = <span class="literal">NULL</span>;     <span class="comment">// 栈节点的地址临时保存在 q 中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p != pS-&gt;pBottom) <span class="comment">// 是否遍历到栈底</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            q = p-&gt;pNext;   <span class="comment">// 栈节点指针域(下一节点地址)临时保存在指针 q 中</span></span><br><span class="line">            <span class="built_in">free</span>(p);    <span class="comment">// 经过上步才能进行此步，否则直接 free，就找不到下一个节点地址了</span></span><br><span class="line">            p = q;      <span class="comment">// 临时保存在 q 中的下一节点地址赋值给 p，准备循环释放下一节点内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        pS-&gt;pTop = pS-&gt;pBottom; <span class="comment">// 栈顶和栈底都指向指针域为空的头栈节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列（链式队列）—— 线性结构的应用之一</title>
      <link href="/posts/7017/"/>
      <url>/posts/7017/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-10-27 17:18:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pNext</span>;</span><span class="comment">// int* pBase; 错误！</span></span><br><span class="line">&#125;NODE, *PNODE;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  PNODE pHead, pTail;<span class="comment">//pHead指向无用的头结点 pHead-&gt;pNext才指向队首元素, pTail指向队尾元素</span></span><br><span class="line">  </span><br><span class="line">public:</span><br><span class="line">  Queue();</span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> <span class="title function_">Traverse_Queue</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="title function_">Empty_Queue</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span>;</span><br><span class="line"><span class="comment">//bool Full_Queue();// 链式队列不会满！</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">En_Queue</span><span class="params">(<span class="type">int</span> val)</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="title function_">Out_Queue</span><span class="params">(<span class="type">int</span>&amp; val)</span>;<span class="comment">//使用引用更好；bool Out_Queue(int* pVal);</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Clear_Queue</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">  </span><br><span class="line">  ~Queue();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  Queue Q;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    Q.En_Queue(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Q.Traverse_Queue();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>( Q.Out_Queue(val) )<span class="comment">//用引用代替&amp;val</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;出队成功，出队的元素是: &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;出队失败！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>( Q.Out_Queue(val) )<span class="comment">//用引用代替&amp;val</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;出队成功，出队的元素是: &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;出队失败！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  Q.Traverse_Queue();</span><br><span class="line">  </span><br><span class="line">  Q.Clear_Queue();</span><br><span class="line">  Q.Traverse_Queue();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue::Queue()</span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;pHead = this-&gt;pTail = new NODE;</span><br><span class="line">  this-&gt;pHead-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue::~Queue()</span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;Clear_Queue();</span><br><span class="line">  delete this-&gt;pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue::Traverse_Queue</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  PNODE pTemp = this-&gt;pHead-&gt;pNext;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(pTemp == nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空，无法遍历！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(pTemp != nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pTemp-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    pTemp = pTemp-&gt;pNext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Queue::Empty_Queue</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(this-&gt;pHead == this-&gt;pTail)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue::En_Queue</span><span class="params">(<span class="type">int</span> val)</span><span class="comment">//在类外必须指定成员函数的作用域Queue::</span></span><br><span class="line">&#123;</span><br><span class="line">  PNODE pNew = new NODE;</span><br><span class="line">  </span><br><span class="line">  pNew-&gt;data = val;</span><br><span class="line">  pNew-&gt;pNext = nullptr;<span class="comment">//使用nullptr而不是NULL，这是现代C++的做法</span></span><br><span class="line">  </span><br><span class="line">  this-&gt;pTail-&gt;pNext = pNew;<span class="comment">//用this指代当前对象的指针，增强可读性</span></span><br><span class="line">  this-&gt;pTail = pNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Queue::Out_Queue</span><span class="params">(<span class="type">int</span>&amp; val)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(this-&gt;Empty_Queue())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空，无法出队！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    PNODE pTemp = this-&gt;pHead-&gt;pNext;</span><br><span class="line">    val = pTemp-&gt;data;</span><br><span class="line">    </span><br><span class="line">    this-&gt;pHead-&gt;pNext = pTemp-&gt;pNext;<span class="comment">//this-&gt;pHead-&gt;pNext-&gt;pNext;</span></span><br><span class="line">    delete pTemp;<span class="comment">// 使用delete释放内存，而不是free(pTemp);</span></span><br><span class="line">    pTemp = nullptr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( nullptr == this-&gt;pHead-&gt;pNext )<span class="comment">//检查队列是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      this-&gt;pTail = this-&gt;pHead;</span><br><span class="line">      <span class="comment">//如果队列为空，则将 pTail 指针移回 pHead，</span></span><br><span class="line">      <span class="comment">//这是为了确保在队列变为空时， pTail 也要指向无用的头结点。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue::Clear_Queue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>( !this-&gt;Empty_Queue() )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    this-&gt;Out_Queue(val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列（循环队列）—— 线性结构的应用之一</title>
      <link href="/posts/13537/"/>
      <url>/posts/13537/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-10-26 18:40:37</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在程序结束时，应该使用 free 函数来释放分配的内存，以防止内存泄漏。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//struct Queue* pBase;</span></span><br><span class="line">  <span class="type">int</span>* pBase;</span><br><span class="line">  <span class="type">int</span> front;</span><br><span class="line">  <span class="type">int</span> rear;</span><br><span class="line">&#125;QUEUE, *PQUEUE;<span class="comment">//PQUEUE == struct Queue*，即创建一个 QUEUE 类型的指针别名</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_Queue</span><span class="params">(PQUEUE pQ)</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">En_Queue</span><span class="params">(PQUEUE pQ, <span class="type">int</span> val)</span>;<span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Out_Queue</span><span class="params">(PQUEUE pQ, <span class="type">int</span>* pVal)</span>;<span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Full_Queue</span><span class="params">(PQUEUE pQ)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty_Queue</span><span class="params">(PQUEUE pQ)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse_Queue</span><span class="params">(PQUEUE pQ)</span>;<span class="comment">//遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  PQUEUE Q;<span class="comment">//在 Init_Queue 函数中，不再需要分配内存，因为 Q 是一个指向 QUEUE 结构的指针</span></span><br><span class="line">  Q = (PQUEUE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QUEUE));<span class="comment">// QUEUE == struct Queue</span></span><br><span class="line">  <span class="keyword">if</span> (Q == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  </span><br><span class="line">  Init_Queue(Q);</span><br><span class="line">  En_Queue(Q, <span class="number">1</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">2</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">3</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">4</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">5</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">6</span>);</span><br><span class="line">  En_Queue(Q, <span class="number">7</span>);</span><br><span class="line">  Traverse_Queue(Q);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>( Out_Queue(Q, &amp;val) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队成功，出队的元素为：%d\n&quot;</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队失败！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Traverse_Queue(Q);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在程序结束时，应该使用 free 函数来释放分配的内存，以防止内存泄漏。</span></span><br><span class="line">  <span class="built_in">free</span>(Q);</span><br><span class="line">  <span class="built_in">free</span>(Q-&gt;pBase);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_Queue</span><span class="params">(PQUEUE pQ)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//QUEUE* pQ = (Queue)malloc(sizeof(QUEUE));//在 Init_Queue 函数中，不再需要分配内存，因为 Q 是一个指向 QUEUE 结构的指针。</span></span><br><span class="line">  pQ-&gt;pBase = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span>(pQ-&gt;pBase == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    pQ-&gt;front = <span class="number">0</span>;</span><br><span class="line">    pQ-&gt;rear = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">En_Queue</span><span class="params">(PQUEUE pQ, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>( Full_Queue(pQ) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    pQ-&gt;pBase[pQ-&gt;rear] = val;</span><br><span class="line">    pQ-&gt;rear = (pQ-&gt;rear + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Out_Queue</span><span class="params">(PQUEUE pQ, <span class="type">int</span>* pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>( Empty_Queue(pQ) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *pVal = pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">    pQ-&gt;front = (pQ-&gt;front + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty_Queue</span><span class="params">(PQUEUE pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(pQ-&gt;rear == pQ-&gt;front)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Full_Queue</span><span class="params">(PQUEUE pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>( (pQ-&gt;rear + <span class="number">1</span>) % <span class="number">6</span> == pQ-&gt;front )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse_Queue</span><span class="params">(PQUEUE pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = pQ-&gt;front;<span class="comment">//借助临时变量 i 来进行遍历</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i != pQ-&gt;rear)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pQ-&gt;pBase[i]);</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表</title>
      <link href="/posts/45748/"/>
      <url>/posts/45748/</url>
      
        <content type="html"><![CDATA[<p>涉及到链表的 创建、遍历、求长度、插入、删除、查找、排序。</p><h1 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h1><ul><li><strong>typedef</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;* PSTU, STU;        </span><br><span class="line"><span class="comment">//PSTU等价于struct Student *, STU等价于struct Student</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    STU st;        <span class="comment">//struct Student st;</span></span><br><span class="line">    PSTU ps = &amp;st;    <span class="comment">//struct Student* ps = &amp;st;</span></span><br><span class="line">    ps-&gt;sid = <span class="number">99</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ps-&gt;sid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>确定一个链表所需要的参数</strong><br>头指针</p></li><li><p><strong>每一个链表节点的数据类型该如何表示的问题</strong></p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>      //节点————每一个节点分为两部分，数据域和指针域</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;    <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span>      <span class="comment">//指针域————指向的是一个跟它本身数据类型一致、但是是另外一个节点</span></span><br><span class="line">&#125;NODE, *PNODE;    <span class="comment">//NODE 等价于struct Node，PNODE等价于struct Node *</span></span><br></pre></td></tr></table></figure><ul><li><strong>插入节点</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>  r = p-&gt;pNext; p-&gt;pNext = q;  q-&gt;pNext = r;</span><br><span class="line"><span class="comment">//q-&gt;pNext表示的是q指向的那个结构体变量中的pNext成员</span></span><br><span class="line"><span class="number">2.</span>  q-&gt;pNext = p-&gt;pNext;  p-&gt;pNext = q;</span><br></pre></td></tr></table></figure><ul><li><strong>删除节点</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line"><span class="built_in">free</span>(r);</span><br></pre></td></tr></table></figure><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-10-04 11:13:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不懂就画图！！！！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span>    <span class="comment">//指针域</span></span><br><span class="line">&#125;NODE, *PNODE;  <span class="comment">//NODE等价于struct Node    PNODE等价于struct Node *</span></span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">Create_List</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">//创建链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse_List</span><span class="params">(PNODE pHead)</span>;    <span class="comment">//遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Empty</span><span class="params">(PNODE pHead)</span>;         <span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length_List</span><span class="params">(PNODE pHead)</span>;       <span class="comment">//求链表长度</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_List</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> val)</span>;    <span class="comment">//在pHead所指向链表的第pos个节点的前面插入一个新的结点，该节点的值是val， 并且pos的值是从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete_List</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span>; <span class="comment">//删除链表第pos个节点，并将删除的结点的值存入pVal所指向的变量中,  并且pos的值是从1开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_List</span><span class="params">(PNODE)</span>;          <span class="comment">//选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_List_Bubble</span><span class="params">(PNODE)</span>;   <span class="comment">//冒泡排序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    PNODE pHead = <span class="literal">NULL</span>;     <span class="comment">//等价于 struct Node * pHead = NULL;</span></span><br><span class="line">    </span><br><span class="line">    pHead = Create_List();  <span class="comment">//函数功能：创建一个非循环单链表，并将该链表头节点的地址赋给null</span></span><br><span class="line">    Traverse_List(pHead);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  Insert_List(pHead, 4, 88);</span></span><br><span class="line"><span class="comment">//  Insert_List(pHead, 5, 55);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( Delete_List(pHead, <span class="number">4</span>, &amp;val) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功， 删除的元素为：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  if( Is_Empty(pHead) )</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      printf(&quot;链表为空！\n&quot;);</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  else</span></span><br><span class="line"><span class="comment">//      printf(&quot;链表不为空！\n&quot;);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  int len = Length_List(pHead);</span></span><br><span class="line"><span class="comment">//  printf(&quot;链表的长度是%d\n&quot;, len);</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  Sort_List(pHead);</span></span><br><span class="line"><span class="comment">//  Traverse_List(pHead);</span></span><br><span class="line">    </span><br><span class="line">    Sort_List_Bubble(pHead);</span><br><span class="line">    Traverse_List(pHead);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    释放链表内存空间:</span></span><br><span class="line"><span class="comment">      首先，从链表的第一个节点开始，依次释放每个节点的内存空间。然后释放头节点的内存空间。这样就确保了整个链表的内存空间都被释放。</span></span><br><span class="line"><span class="comment">      需要注意的是，释放节点内存空间时，应先保存下一个节点的指针，然后再释放当前节点的内存空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PNODE temp = p;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pHead);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">Create_List</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;    <span class="comment">//用来存放有效节点的个数</span></span><br><span class="line">    <span class="type">int</span> val;    <span class="comment">//用来临时存放用户输入的结点的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配了一个不存放有效数据的头节点</span></span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));  <span class="comment">//返回的是节点本身的数据类型，所以是NODE，不是PNODE</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNODE pTail = pHead;    <span class="comment">//定义一个时刻指向尾节点的变量</span></span><br><span class="line">    pTail-&gt;pNext = <span class="literal">NULL</span>;    <span class="comment">//如果只输入一个数据时满足此情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入需要生成的链表节点个数：len = &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个节点的值：&quot;</span>, i+<span class="number">1</span>); </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">        </span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//临时节点</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == pNew)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pNew-&gt;data = val;       <span class="comment">//临时节点存放临时变量</span></span><br><span class="line">        pTail-&gt;pNext = pNew;    <span class="comment">//把新的节点挂到尾节点后</span></span><br><span class="line">        pNew-&gt;pNext = <span class="literal">NULL</span>;     <span class="comment">//新节点的下一个节点就为空了</span></span><br><span class="line">        pTail = pNew;           <span class="comment">//更新尾节点</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*  错误：每个节点都挂在了头结点之后！</span></span><br><span class="line"><span class="comment">        pNew-&gt;data = val;</span></span><br><span class="line"><span class="comment">        pHead-&gt;pNext = pNew;</span></span><br><span class="line"><span class="comment">        pNew-&gt;pNext = NULL;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse_List</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;     <span class="comment">//p可能为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;     <span class="comment">//表示函数执行完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Empty</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead-&gt;pNext == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Length_List</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提到了C++重载、泛型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_List</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line">    <span class="type">int</span> len = Length_List(pHead);</span><br><span class="line">    PNODE p, q;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, p=pHead-&gt;pNext;i&lt;len<span class="number">-1</span>;i++, p=p-&gt;pNext)    <span class="comment">//i=0：第一个元素的下标；p=pHead-&gt;pNext：第一个有效元素的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>, q=p-&gt;pNext;j&lt;len;j++, q=q-&gt;pNext)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data)       <span class="comment">//类似于数组中的：a[i] &gt; a[j]</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = p-&gt;data;            <span class="comment">//类似于数组中的：t = a[i];</span></span><br><span class="line">                p-&gt;data = q-&gt;data;      <span class="comment">//类似于数组中的：a[i] = a[j];</span></span><br><span class="line">                q-&gt;data = t;            <span class="comment">//类似于数组中的：a[j] = t;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_List_Bubble</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line">    <span class="type">int</span> len = Length_List(pHead);</span><br><span class="line">    PNODE p,q;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,p=pHead-&gt;pNext;i&lt;len<span class="number">-1</span>;i++,p=p-&gt;pNext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>,q=pHead-&gt;pNext;j&lt;len<span class="number">-1</span>-i;j++,q=q-&gt;pNext)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;data &gt; q-&gt;pNext-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                t = q-&gt;data;</span><br><span class="line">                q-&gt;data = q-&gt;pNext-&gt;data;</span><br><span class="line">                q-&gt;pNext-&gt;data = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在pHead所指向链表的第pos个节点的前面插入一个新的结点，该节点的值是val， 并且pos的值是从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_List</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">NULL</span>!=p &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;pNext; </span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span>==p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果程序能执行到这一行说明p已经指向了第pos-1个结点,但第pos-1个节点是否存在无所谓</span></span><br><span class="line">    <span class="comment">//分配新的结点</span></span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pNew)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pNew-&gt;data = val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将新的结点存入p节点的后面</span></span><br><span class="line">    PNODE q = p-&gt;pNext;</span><br><span class="line">    p-&gt;pNext = pNew;</span><br><span class="line">    pNew-&gt;pNext = q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//健壮性非常好</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete_List</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">NULL</span>!=p &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span>==p-&gt;pNext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果程序能执行到这一行说明p已经指向了第pos-1个结点，并且第pos个节点是存在的</span></span><br><span class="line">    PNODE q = p-&gt;pNext;</span><br><span class="line">    *pVal = q-&gt;data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除p后面的结点</span></span><br><span class="line">    p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line">    <span class="built_in">free</span>(q);        <span class="comment">//删除p后面的结点</span></span><br><span class="line">    q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态 链式二叉树</title>
      <link href="/posts/23318/"/>
      <url>/posts/23318/</url>
      
        <content type="html"><![CDATA[<p>此为静态的链式二叉树。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *       A</span></span><br><span class="line"><span class="comment"> *   B       C</span></span><br><span class="line"><span class="comment"> *        D</span></span><br><span class="line"><span class="comment"> *            E</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">pLchild</span>;</span> <span class="comment">// 左子树指针域 p是指针 L是左孩子 R是右孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">pRchild</span>;</span> <span class="comment">// 右子树指针域</span></span><br><span class="line">&#125;BTNODE, *PBTNODE;</span><br><span class="line"></span><br><span class="line">PBTNODE <span class="title function_">CreateBTree</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 创建二叉树，并返回二叉树根节点地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span>;   <span class="comment">//先序遍历二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span>;    <span class="comment">//中序遍历二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span>;  <span class="comment">//后续遍历二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PBTNODE pT = CreateBTree();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;先序遍历二叉树：\n&quot;</span>);</span><br><span class="line">    PreTraverseBTree(pT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历二叉树：\n&quot;</span>);</span><br><span class="line">    InTraverseBTree(pT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;后序遍历二叉树：\n&quot;</span>);</span><br><span class="line">    PostTraverseBTree(pT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PBTNODE <span class="title function_">CreateBTree</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建5个节点</span></span><br><span class="line">    PBTNODE pA = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pB = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pC = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pD = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pE = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给5个节点分配数据</span></span><br><span class="line">    pA-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    pB-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    pC-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    pD-&gt;data = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    pE-&gt;data = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设立各个节点之间的关系</span></span><br><span class="line">    pA-&gt;pLchild = pB;</span><br><span class="line">    pA-&gt;pRchild = pC;</span><br><span class="line">    pB-&gt;pLchild = pB-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pC-&gt;pLchild = pD;</span><br><span class="line">    pC-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pD-&gt;pLchild = <span class="literal">NULL</span>;</span><br><span class="line">    pD-&gt;pRchild = pE;</span><br><span class="line">    pE-&gt;pLchild = pE-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pA; <span class="comment">// 返回二叉树根节点地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span> <span class="comment">// 先序遍历二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pT-&gt;pLchild可以代表整个左子树</span></span><br><span class="line">    <span class="comment">// pT-&gt;pRchild可以代表整个右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> != pT ) <span class="comment">// 根节点地址不为空时才创建二叉树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pT-&gt;data);         <span class="comment">// 先序遍历根节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pLchild )<span class="comment">// 根节点左子树不为空时才遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            PreTraverseBTree(pT-&gt;pLchild); <span class="comment">// 先序遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pRchild )<span class="comment">// 根节点右子树不为空时才遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            PreTraverseBTree(pT-&gt;pRchild);  <span class="comment">// 先序遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span> <span class="comment">// 中序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> != pT )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pLchild )</span><br><span class="line">        &#123;</span><br><span class="line">            InTraverseBTree(pT-&gt;pLchild); <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pT-&gt;data);         <span class="comment">// 中序遍历根节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pRchild )</span><br><span class="line">        &#123;</span><br><span class="line">            InTraverseBTree(pT-&gt;pRchild); <span class="comment">// 中序遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span> <span class="comment">// 后序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="literal">NULL</span> != pT )</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pLchild )</span><br><span class="line">        &#123;</span><br><span class="line">            PostTraverseBTree(pT-&gt;pLchild);  <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != pT-&gt;pRchild )</span><br><span class="line">        &#123;</span><br><span class="line">            PostTraverseBTree(pT-&gt;pRchild);  <span class="comment">// 后序遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pT-&gt;data);            <span class="comment">// 后序遍历根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>萌新九宫格之首的全新解读：里界小CL——假如逝去之人不再归来</title>
      <link href="/posts/64630/"/>
      <url>/posts/64630/</url>
      
        <content type="html"><![CDATA[<p>原文出处（已征得转载同意）：<a href="https://mp.weixin.qq.com/s/QlwaFMw-WqiQiyoNZ-ogTg">萌新九宫格之首的全新解读：里界小CL——假如逝去之人不再归来</a>，破军歌姬 Galgame批评 2023-11-08 11:00</p><p>（虽然这个gal我并没有玩过吧，但是作者的这篇文章让我想起了Clannad，已经看好多年了……）</p><hr><p>当挚爱之人逝去时，空留人世之人要如何摆脱内心的伤痛呢？clannad这部作品给我们的答案是去帮助别人，然后别人也会帮助你，甚至最后世界都会来帮助你。clannad确实是一个美好的童话故事，可以通过人们的善意，让心爱之人起死回生。然而现实世界里是没有救世的光玉存在的，能够治愈人类的，只有人类自己。<br><img src="https://picss.sunbangyan.cn/2023/11/12/edc97536768ec9f21c5df8ab9c7d003e.jpg" alt="Clannad" style="zoom:70%"/></p><p>让我意识到这一点的，是《若能与你再次相见》这部作品。这部作品又被誉为萌新九宫格之首，是galgame吧最推荐萌新入坑的游戏之一。说起入坑，我自然就想到了我的gal入坑作clannad，CL我当时看得非常感动，感叹有情人终成眷属。然而随着年龄的增长，我渐渐觉得CL的结局有些超现实了，如果现实中和朋也类似的人，真的遭遇了与他相似的惨剧，那么那些没有被光玉拯救的人又应该怎么办呢？如今，若能与你再次相见这部作品，就给出了一个非常现实的答案。<br><img src="https://picss.sunbangyan.cn/2023/11/12/a990becccf9ba34260ef09cb04685221.jpg" alt="1" /></p><hr><p>在若能与你再次相见中，男主角大崎陆持有的超自然道具，是一个被诅咒的怀表。使用这块怀表，虽然可以回到过去，但无法改变已经发生过的事，只能再次看着事情朝自己不愿看到的方向发展。赠予陆怀表的人是他的初恋古川涟，涟姐在赠予男主怀表后没多久就去世了。陆无法释怀涟姐逝去带来的伤痛，把希望都寄托在了怀表身上，虽然涟姐说过，怀表并不能改变既定的过去，但万一自己能成功呢？于是男主便像一只受了伤的候鸟一般，踏上了一场寻求救赎的旅途。<br><img src="https://picst.sunbangyan.cn/2023/11/12/0b9a111b715b9f3edf7b20294b4235b2.png" alt="2" /><br>男主放弃学业，一边打日结工挣旅游经费，一边到处用怀表逆转时空帮助别人。男主试图提前做出应对措施，让别人的困难在过去就不会发生，可是一次也没有成功。只能不依靠怀表，在困难发生后再帮助别人解决。男主只在一个城市待三个月，三个月过后就会去下一个城市旅行。这样的生活过了5年，5年后的男主来到了一个南方城市。在这里他遇到了一位境遇很像涟姐的少女泉诗乃，男主自然而然的被诗乃吸引，与她交谈甚欢。但因为诗乃也患有绝症，所以即使她和男主相处的很好，一个多月后也还是撒手人寰了，男主再一次感受到了重要之人逝去时的悲痛。这一次治愈男主的，不是怀表超自然的力量，而是诗乃的闺蜜岩出山未喜。男主先帮助未喜解决了她的烦恼，同时也解开了未喜哥哥笃史的心结，最后未喜再用她的爱去治愈男主，让男主有了新的生活目标，从而放下过去，走向未来。<br><img src="https://picdm.sunbangyan.cn/2023/11/12/1866e3c154ba07451d581cb7c2824530.png" alt="3" /><br><img src="https://picdl.sunbangyan.cn/2023/11/12/3ad41faa896eb10812c9ac28b8476099.png" alt="4" /></p><hr><p>岩出山未喜路线的人设，和cl中伊吹风子路线的人设很像：</p><p>冈崎直幸和古川涟都对男主角造成过伤害，所以冈崎直幸约等于古川涟；</p><p>泉诗乃和古河渚没有伤害男主的本意，但她们的逝去同样也对男主造成了伤害，所以泉诗乃约等于古河渚；</p><p>伊吹公子和岩出山笃史都是被男主解开对妹妹的心结后，才安心追逐自己的幸福，所以伊吹公子约等于岩出山笃史；</p><p>冈崎朋也和大崎陆虽然都是依靠帮助他人来逃避自己受到的痛苦，但他们确实也实实在在地帮助了很多人，所以冈崎朋也约等于大崎陆；</p><p>伊吹风子和岩出山未喜都得到了男主很大的帮助，并且她们也想要去回报和治愈男主了。所以伊吹风子约等于岩出山未喜。<br><img src="https://picdm.sunbangyan.cn/2023/11/12/482936b0f1690d33412e1cb60bae91ad.jpg" alt="5" style="zoom:70%"/><br>在岩出山未喜的路线中，男主与未喜同甘共苦，拼命帮未喜解决了她的家庭问题。解决问题时同样使用了怀表，怀表自然也没有奏效。那时，帮助未喜解决困难的心情大过了想要给涟姐证明怀表有用的心情，于是男主通过自己的力量成功帮助了未喜。那之后，他终于意识到了自己只不过是在通过怀表去逃避失去涟姐的伤痛罢了，人不能一直活在过去，逝者已逝，生者如斯。如今他终于可以走出涟姐和诗乃的逝去给自己带来的阴影了。因为他现在他要给自己新的爱人未喜带去幸福，过去的阴影已经被未喜的光芒照亮了。<br><img src="https://picst.sunbangyan.cn/2023/11/12/5bf6102d462df2458e043df6c59a6794.png" alt="6" /><br>在cl的as路线中，朋也同样先后失去了妻子和女儿。剧情发展到那种地步，满屏的绝望感真的很让人窒息，这让我时常在想，如果没有光玉，那能支撑朋也走完往后漫长人生路的动力，究竟还有什么？经历过多次重创的朋也，还能够得到救赎吗？岩出山未喜的路线给我提供了一种可能性：就算朋也再次自暴自弃，他的朋友们也不会放弃他，因为他的朋友们都曾得到过朋也的帮助。而朋也对伊吹风子有再生之德，她更加不会放弃朋也，一定会想尽办法去治愈他。毕竟在原作的AS路线里，风子就对朋也说过，难过的时候随时都可以来找她。爱人者人恒爱之，为众人报薪者，不可使其冻毙于风雪。如果自己想要得到救赎，那就去帮助别人，这样自己也能够得到救赎。这或许就是《clannad》和《若能与你再次相见》这两部作品想要传递的思想吧。<br><img src="https://picdm.sunbangyan.cn/2023/11/12/31f2ea6ea1442e3fc5951fe602354660.png" alt="7" /></p><hr><p>祝愿身陷囹圄的人们也能迎来属于自己的光。即使自己也身处阴影之中，也要把人推向光明。光明之处的朋友越多，自己离光明也就越近，谁说站在光里的才算英雄！感谢各位的观看，如果本期杂谈让你有所触动的话，推荐去游玩原作，一定会获得一场不错的体验。最后就用key社的另一位女主神北小毬的幸福螺旋理论来结束这篇杂谈吧：“如果你能幸福，我会很开心，看到别人幸福的样子，自己也会觉得幸福，我幸福的话，你也会很幸福，一直一直循环下去，最后啊，就会变成幸福螺旋了。”<br><img src="https://picdm.sunbangyan.cn/2023/11/12/fa27485e99e1489c17c2994fa53018b5.png" alt="8" /></p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序—选择排序</title>
      <link href="/posts/61129/"/>
      <url>/posts/61129/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://www.runoob.com/w3cnote/selection-sort.html">1.2 选择排序 | 菜鸟教程</a><br>数组、链表的基本操作都涉及到排序，排序有很多种，根据情况选择合适的算法即可。<br>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><h1 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h1><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="psc" style="zoom"/><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>就是每一次从未排序的所有元素中，“选出”最小（或最大）的，放在首位，然后递推其余未排序的元素，每一次都选出余下最小的。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="http://acm.zzuli.edu.cn/problem.php?cid=1908&pid=8">ZZULIOJ-Contest 1908-I: 混乱的成绩表</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Zero 是一名学习委员，他负责很多有关学习上的任务，今天辅导员给了他一张成绩单，这个成绩单是按学号排序的，但是它是成绩单，应该按成绩排序。Zero 作为一个 acmer，对排序还算了解，但他想考考你，你能完成这个任务吗？</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个正整数 n，代表成绩单上学生的人数(n &lt;= 2000)</span><br><span class="line">接下来 n 行，每行两个整数 ID 和 x，ID是学生的编号(递增给出），x 是学生成绩 (0 &lt;= x &lt;= 100)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出按成绩排名的成绩单，成绩越高，排名越靠前，相同成绩的人 ID 较小的排名在前</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 68</span><br><span class="line">2 68</span><br><span class="line">3 90</span><br><span class="line">4 91</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 91</span><br><span class="line">3 90</span><br><span class="line">1 68</span><br><span class="line">2 68</span><br></pre></td></tr></table></figure><h2 id="结构体代码-选择排序"><a href="#结构体代码-选择排序" class="headerlink" title="结构体代码 选择排序"></a>结构体代码 选择排序</h2><p><strong>考察点：结构体、排序</strong><br>很明显本题让我们对成绩排序，但难点在于每个人的成绩和学号是绑定在一起的，这个时候我们就有两种选择：</p><ul><li>两个数组，排序时一起交换这两数组的值</li><li>开一个结构体，排序时交换结构体的值</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id, soc;    <span class="comment">// 学号 成绩</span></span><br><span class="line">&#125;a[<span class="number">2001</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_select</span><span class="params">(<span class="keyword">struct</span> Student a[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a[i].id, &amp;a[i].soc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Sort_select(a, n);  <span class="comment">//调用函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a[i].id, a[i].soc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序的实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_select</span><span class="params">(<span class="keyword">struct</span> Student a[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">0</span>;   <span class="comment">// 是否需要排序，0 代表不需要，1 代表需要</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(a[i].soc &lt; a[j].soc)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;   <span class="comment">// 成绩较高的在前</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i].soc == a[j].soc &amp;&amp; a[i].id &gt; a[j].id)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;   <span class="comment">// 相同成绩，编号较小的在前</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">// 交换</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">t</span> =</span> a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组代码-选择排序"><a href="#数组代码-选择排序" class="headerlink" title="数组代码 选择排序"></a>数组代码 选择排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id[<span class="number">2001</span>], sco[<span class="number">2001</span>];    <span class="comment">// 1.为什么放外面？</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_select</span><span class="params">(<span class="type">int</span> n)</span>;    <span class="comment">// 2.函数定义为什么只有n？</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;id[i], &amp;sco[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Sort_select(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, id[i], sco[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序的实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_select</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 是否需要排序，0 代表不需要，1 代表需要</span></span><br><span class="line">            <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(sco[i] &lt; sco[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;   <span class="comment">// 成绩较高在前</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sco[i] == sco[j] &amp;&amp; sco[i] &gt; sco[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;   <span class="comment">// 相同成绩，编号较小的在前</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag)        <span class="comment">// 交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = id[i];</span><br><span class="line">                id[i] = id[j];</span><br><span class="line">                id[j] = t;</span><br><span class="line">                t = sco[i];</span><br><span class="line">                sco[i] = sco[j];</span><br><span class="line">                sco[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><h3 id="1-为什么数组放外面？"><a href="#1-为什么数组放外面？" class="headerlink" title="1. 为什么数组放外面？"></a>1. 为什么数组放外面？</h3><p>将数组定义放在main函数之外更好，因为这样可以使得<strong>数组在整个程序中都可见</strong>，而不仅仅是在main函数中可见。这样可以使得代码<strong>更加清晰易懂</strong>。如果数组定义在main函数内部，那么它的<strong>作用域</strong>就只在main函数内部，而在main函数外部就无法访问该数组。<br>此外，如果数组定义在main函数内部，那么它的内存分配在<strong>栈区</strong>内，而栈区的内存是比较小的。因此，如果数组比较大，就会出现<strong>爆出</strong>的问题，程序无法访问内存就会出错。相对的，如果数组定义在main函数外部，那么它的内存分配在<strong>数据区</strong>内，<strong>数据区的内存较大，所以开数组开在数据区&#x2F;main函数外面，就不易出现这样的问题。</strong></p><h3 id="2-数组中函数定义为什么只有n？"><a href="#2-数组中函数定义为什么只有n？" class="headerlink" title="2. 数组中函数定义为什么只有n？"></a>2. 数组中函数定义为什么只有n？</h3><p>因为数组在外面定义呀！<br>整个程序都可以访问，这样函数只需要一个数组长度的参数即可。</p><h3 id="3-为什么设立标志数flag？"><a href="#3-为什么设立标志数flag？" class="headerlink" title="3. 为什么设立标志数flag？"></a>3. 为什么设立标志数flag？</h3><p>因为题目要求<strong>成绩越高，排名越靠前</strong>，<strong>相同成绩的人 ID 较小的排名在前</strong>，有两处都需要排序，如果不设立标志数，这两处都需要排序，代码会重复。<br>设立flag是为了<strong>减少重复代码，增强可读性</strong>，满足flag就if语句进行交换即可。</p><h3 id="4-为什么结构体里交换只交换成绩而数组里成绩和序号都交换？"><a href="#4-为什么结构体里交换只交换成绩而数组里成绩和序号都交换？" class="headerlink" title="4. 为什么结构体里交换只交换成绩而数组里成绩和序号都交换？"></a>4. 为什么结构体里交换只交换成绩而数组里成绩和序号都交换？</h3><p>因为结构体是捆绑在一起的，学号和成绩一一对应。<br>而数组里不是，二者没有关系，只交换成绩序号全乱了。</p><hr><p><del>下集预告：冒泡排序（托更bushi）</del></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 十大排序 </tag>
            
            <tag> 排序和查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拖更计划（bushi)</title>
      <link href="/posts/35809/"/>
      <url>/posts/35809/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>记录以下后续想要写的内容，当成备忘录罢了。</strong><br>“总有一天，每个人会和这个故事告别，走向不同的方向，独属于你自己的下一页。但是那样就好，累了的话就停下脚步，怀念的话就回来看看这个故事也一直都在。且行且看，尽力而为，不要害怕，不要后悔。”<br><del>另外我发现，在vc和typora里[TOC]会直接生成目录，但在blog里只显示“[TOC]”的文字……</del></p><h1 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h1><h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2><p>这东西第一次听，简单查了一下，应该是一种规范，主题文档的语言应该还是HTML？</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p><a href="https://www.bilibili.com/video/av271280711/">[自制双语字幕] 计算机教育缺失的一课(2020) - 第1讲 - 课程概览与 shell</a><br>hexo clean和Linux这类的命令最初应该都是shell相关吧，涉及到命令应该都离不开shell</p><h2 id="cmd-powershell"><a href="#cmd-powershell" class="headerlink" title="cmd &#x2F; powershell"></a>cmd &#x2F; powershell</h2><p>这俩东西我也不了解，但很多操作都是通过这俩完成的，还有跟shell、bash有什么关系、区别……</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>作业……</p><h2 id="十大排序"><a href="#十大排序" class="headerlink" title="十大排序"></a>十大排序</h2><p><a href="https://www.runoob.com/w3cnote/sort-algorithm-summary.html">排序算法总结 | 菜鸟教程</a><br><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">1.0 十大经典排序算法 | 菜鸟教程</a><br>冒泡、选择、插入、选择、希尔、归并、快速、堆、计数、桶、基数排序。<br>我就学了选择和冒泡。</p><h2 id="十大编程算法"><a href="#十大编程算法" class="headerlink" title="十大编程算法"></a>十大编程算法</h2><p><a href="https://www.runoob.com/w3cnote/the-friendship-algorithm-the-big-bang-theory.html">十大编程算法助程序员走上高手之路 | 菜鸟教程</a></p><h1 id="English"><a href="#English" class="headerlink" title="English"></a>English</h1><p><a href="https://www.runoob.com/w3cnote/common-english-terminology-in-programming.html">编程常用英语词汇 | 菜鸟教程</a></p><h1 id="ACGN"><a href="#ACGN" class="headerlink" title="ACGN"></a>ACGN</h1><h2 id="Lovelive-虹咲"><a href="#Lovelive-虹咲" class="headerlink" title="Lovelive 虹咲"></a>Lovelive 虹咲</h2><h2 id="少女歌剧"><a href="#少女歌剧" class="headerlink" title="少女歌剧"></a>少女歌剧</h2><h1 id="生活日常"><a href="#生活日常" class="headerlink" title="生活日常"></a>生活日常</h1>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归档（拖更√） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归—汉诺塔</title>
      <link href="/posts/53020/"/>
      <url>/posts/53020/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/av6159200?p=57">57 _ 递归8 _ 汉诺塔_1_哔哩哔哩</a><br>趁热打铁，记录下来，后续有什么再补充。</p><h1 id="问题引入："><a href="#问题引入：" class="headerlink" title="问题引入："></a>问题引入：</h1><img src="https://picdl.sunbangyan.cn/2023/11/07/9d9308fa088968e70158787c10947a68.jpg" alt="递归汉诺塔3" style="zoom:70%"/><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><img src="https://picdl.sunbangyan.cn/2023/11/07/17ec6792727493ca736a229f19d637b9.jpg" alt="递归_汉诺塔" style="zoom:70%"/>主要是运用递归的思想。将规模为n的问题转为为规模为n-1的问题，直到可以一步解决。<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">如果是1个盘子</span><br><span class="line"><span class="code">    直接将A柱子上的盘子移到C上</span></span><br><span class="line"><span class="code">否则</span></span><br><span class="line"><span class="code">    先将A柱子上的n-1个盘子借助C移到B</span></span><br><span class="line"><span class="code">    直接将A柱子上编号为n的盘子移到C</span></span><br><span class="line"><span class="code">    最后将B柱子上的n-1个盘子借助A移到C</span></span><br></pre></td></tr></table></figure><h1 id="C版本："><a href="#C版本：" class="headerlink" title="C版本："></a>C版本：</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief: </span></span><br><span class="line"><span class="comment"> * @version:  </span></span><br><span class="line"><span class="comment"> * @author: @Shiel</span></span><br><span class="line"><span class="comment"> * @date: 2023-11-7 22:12:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//依次表示 要移动的盘子个数、盘子所在柱子、借助的柱子、目标柱子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hannuota</span><span class="params">( <span class="type">int</span> n, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义三个柱子 和 要移动的盘子个数</span></span><br><span class="line"><span class="type">char</span> ch1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> ch2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="type">char</span> ch3 = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入要移动的盘子个数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">Hannuota(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hannuota</span><span class="params">( <span class="type">int</span> n, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( n == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;将编号为%d的盘子从%c直接移到%c上\n&quot;</span>, n, A, C);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Hannuota( n - <span class="number">1</span>, A, C, B );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;将编号为%d的盘子从%c直接移到%c上\n&quot;</span>, n, A, C);</span><br><span class="line">Hannuota( n - <span class="number">1</span>, B, A, C );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><ul><li><code>void Hannuota( int n, char A, char B, char C );</code><br>在这里，A、B、C仅仅是参数名字，并不是代表从A借助B移到C，因为递归过程中会出现从B借助A移到C的情况。</li></ul><p><strong>郝斌老师：</strong></p><ul><li>一次要想看懂是不可能的，必须下去多练多看，慢慢的就会感觉跟1+1一样简单了。</li><li>要不停地去想为什么，真的是这样写的吗，别人告诉我的一定正确吗，有没有更好的方法，必须多问为什么，去思考。<img src="https://picss.sunbangyan.cn/2023/11/07/e9b3379325464b31ab56aa0ed0e75544.jpg" alt="递归汉诺塔4" style="zoom:70%"/></li></ul>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【汇总】学习教程</title>
      <link href="/posts/64685/"/>
      <url>/posts/64685/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基础语言"><a href="#基础语言" class="headerlink" title="基础语言"></a>基础语言</h1><h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/">C# 文档 - 入门、教程、参考。 | Microsoft Learn</a></p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p><a href="https://www.bilibili.com/video/av271280711/">[自制双语字幕] 计算机教育缺失的一课(2020) - 第1讲 - 课程概览与 shell</a></p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><p><a href="https://www.bilibili.com/video/BV1qh411p7Sa/?vd_source=200eb9ec89309b331e61b367cc247a68">C++ 教程 - 油管大佬The Cherno C++ 教程</a></p><p><a href="https://www.bilibili.com/video/BV1Dd4y1R7VS/?vd_source=200eb9ec89309b331e61b367cc247a68">【中字精译】《为游戏编程学习C++》 C++入门教程</a></p><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><h2 id="unity"><a href="#unity" class="headerlink" title="unity"></a>unity</h2><p><a href="https://docs.unity3d.com/Manual/index.html">英文 - Unity User Manual 2022.3</a><br><a href="https://docs.unity.cn/cn/2019.4/Manual/ManualVersions.html">中文 - Unity 手册</a></p><p><a href="https://gitee.com/chutianshu1981/AwesomeUnityTutorial">AwesomeUnityTutorial: 精选官方高质量教程作为入门学习内容</a><br><a href="https://space.bilibili.com/43644141/channel/series">白熊游戏-chutianbo视频专辑</a></p><h1 id="408"><a href="#408" class="headerlink" title="408"></a>408</h1><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p><a href="https://www.programmercarl.com/">代码随想录</a><br><a href="https://www.bilibili.com/video/av6159200/">【郝斌】-数据结构入门_哔哩哔哩</a><br><a href="https://www.bilibili.com/video/av92191094/">王道计算机考研 数据结构_哔哩哔哩</a><br><a href="https://www.bilibili.com/video/av974498314/">【小金鱼】2023王道数据结构课后算法题解析（第二章线性表）</a><br><a href="https://www.bilibili.com/video/av462193433/">【小金鱼】2023王道数据结构课后编程题解析（第三章栈和队列）</a><br><a href="https://www.bilibili.com/video/av632298013/">【小金鱼】2023王道数据结构课后编程题解析 (第5、6、7、8章)</a></p>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归档（拖更√） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验四  常用类和集合框架</title>
      <link href="/posts/50615/"/>
      <url>/posts/50615/</url>
      
        <content type="html"><![CDATA[<p>完成作业罢了。</p><h1 id="一、目的与任务"><a href="#一、目的与任务" class="headerlink" title="一、目的与任务"></a>一、目的与任务</h1><p>理解并掌握String类、StringBuffer类；掌握字符串与其他数据类型的转换掌握Math类的使用；了解和掌握集合框架；掌握Java Application命令行参数的使用。</p><h1 id="二、内容、要求与安排方式"><a href="#二、内容、要求与安排方式" class="headerlink" title="二、内容、要求与安排方式"></a>二、内容、要求与安排方式</h1><p>（1）编写程序，当以年-月-日的格式输入一个日期时，输出该年是否为闰年，该月有几天，该日是星期几。<br>（2）设计一个Student类，该类中包括学生的姓名和成绩。创建Student类的5个对象，如下所示：<br>姓名成绩<br>刘德华90<br>张学友80<br>刘杰65<br>章子怡100<br>周迅60<br>将以上5个对象放入LinkedList中，完成如下操作和统计：</p><ul><li>输出LinkedList中的对象个数。</li><li>删除姓名为“刘杰”的学生信息，并输出LinkedList中现有学生信息。</li><li>将姓名为“刘德华”的学生成绩改为95。</li><li>输出成绩不及格的学生姓名。</li></ul><p>（3）现有以下三个email地址”<a href="mailto:&#122;&#104;&#97;&#110;&#103;&#x73;&#97;&#110;&#64;&#115;&#x6f;&#104;&#x75;&#46;&#x63;&#x6f;&#109;">&#122;&#104;&#97;&#110;&#103;&#x73;&#97;&#110;&#64;&#115;&#x6f;&#104;&#x75;&#46;&#x63;&#x6f;&#109;</a>”、”<a href="mailto:&#108;&#x69;&#115;&#x69;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;">&#108;&#x69;&#115;&#x69;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;</a>”、”<a href="mailto:&#119;&#97;&#x6e;&#103;&#119;&#x75;&#x40;&#115;&#x69;&#110;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">&#119;&#97;&#x6e;&#103;&#119;&#x75;&#x40;&#115;&#x69;&#110;&#x61;&#x2e;&#x63;&#x6f;&#x6d;</a>”。需要把email中的用户部分和邮件地址部分分离（即将@前后部分分离），分离后以键值对应的方式存入HashMap中，并遍历输出。<br>（4）现有一段文本如下：“I&#x2F;have&#x2F;a&#x2F;dream&#x2F;今天&#x2F;天气&#x2F;晴朗&#x2F;万里&#x2F;无云&#x2F;I&#x2F;have&#x2F;a&#x2F;good&#x2F;idea&#x2F;今天&#x2F;天气&#x2F;不错”。试用HashMap实现对文本中出现的单词词频进行统计，并对统计结果进行输出显示，如“I：2”，表示单词“I”在文本中出现了两次。</p><h1 id="第（1）题"><a href="#第（1）题" class="headerlink" title="第（1）题"></a>第（1）题</h1><p>（1）编写程序，当以年-月-日的格式输入一个日期时，输出该年是否为闰年，该月有几天，该日是星期几。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这些行引入了程序所需的库，包括SimpleDateFormat（用于日期格式化）、Date（日期对象）和Calendar（日期操作）。</span></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateInfo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请以年-月-日的格式输入日期，例如：2023-10-31&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputDate</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> dateFormat.parse(inputDate);</span><br><span class="line">            <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">            calendar.setTime(date);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> calendar.get(Calendar.YEAR);</span><br><span class="line">            <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 月份从0开始，需要加1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否为闰年</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLeapYear</span> <span class="operator">=</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该月的天数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">daysInMonth</span> <span class="operator">=</span> calendar.getActualMaximum(Calendar.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该日是星期几</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK);</span><br><span class="line"></span><br><span class="line">            String[] dayOfWeekNames = &#123;<span class="string">&quot;星期日&quot;</span>, <span class="string">&quot;星期一&quot;</span>, <span class="string">&quot;星期二&quot;</span>, <span class="string">&quot;星期三&quot;</span>, <span class="string">&quot;星期四&quot;</span>, <span class="string">&quot;星期五&quot;</span>, <span class="string">&quot;星期六&quot;</span>&#125;;</span><br><span class="line">            <span class="type">String</span> <span class="variable">dayOfWeekName</span> <span class="operator">=</span> dayOfWeekNames[dayOfWeek - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            System.out.println(year + <span class="string">&quot;年是否为闰年: &quot;</span> + (isLeapYear ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;不是&quot;</span>));</span><br><span class="line">            System.out.println(month + <span class="string">&quot;月有 &quot;</span> + daysInMonth + <span class="string">&quot; 天&quot;</span>);</span><br><span class="line">            System.out.println(inputDate + <span class="string">&quot; 是 &quot;</span> + dayOfWeekName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;日期格式无效，请使用 yyyy-MM-dd 格式&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="概括程序"><a href="#概括程序" class="headerlink" title="概括程序"></a>概括程序</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">它接受用户输入的日期，然后根据输入的日期执行以下操作：</span><br><span class="line"></span><br><span class="line">1.判断输入的年份是否为闰年。</span><br><span class="line">2.获取输入月份的天数。</span><br><span class="line">3.确定输入的日期是星期几。</span><br><span class="line">此外，程序还包括了异常处理，以便在用户提供无效日期格式时提供错误消息。以下是对程序的概括：</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 使用 Scanner 从用户输入中获取日期。</span><br><span class="line"><span class="bullet">*</span> 使用 SimpleDateFormat 解析用户输入的日期。</span><br><span class="line"><span class="bullet">*</span> 使用 Calendar 类获取日期的年份、月份、日期等信息。</span><br><span class="line"></span><br><span class="line">根据计算，判断年份是否为闰年。</span><br><span class="line">使用 getActualMaximum 方法获取月份的天数。</span><br><span class="line">使用数组来存储星期的名称，然后根据计算的星期值找到相应的名称。</span><br><span class="line">输出结果，包括年份是否为闰年、月份的天数和输入日期的星期。</span><br><span class="line">这个程序是一个很好的示例，展示了如何使用Java处理日期和用户输入，以及如何实施异常处理来提高程序的健壮性。</span><br></pre></td></tr></table></figure><h2 id="java库是什么，怎么知道该用哪个库？"><a href="#java库是什么，怎么知道该用哪个库？" class="headerlink" title="java库是什么，怎么知道该用哪个库？"></a>java库是什么，怎么知道该用哪个库？</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Java库（Java libraries）是Java编程语言提供的预定义类和方法的集合，用于执行各种任务和操作。这些库被设计为通用工具，以便开发者可以轻松地处理常见任务，而无需从头开始编写所有代码。Java库包括了各种用途的类和方法，例如日期处理、文件操作、网络通信、图形界面、数据结构、数据库连接等。</span><br><span class="line"></span><br><span class="line">在Java编程中，您可以通过导入库中的类来使用库中的功能。以下是一些常见的Java库和用途：</span><br><span class="line"></span><br><span class="line">java.util： 提供了用于数据结构（如集合、列表、队列、堆栈）、日期和时间处理的类。</span><br><span class="line">java.io： 用于文件输入输出的类，允许您读取和写入文件。</span><br><span class="line">java.net： 用于网络通信的类，包括Socket、URL等，可用于创建网络应用程序。</span><br><span class="line">java.awt和javax.swing： 用于创建图形用户界面（GUI）的类和组件。</span><br><span class="line">java.sql： 用于数据库连接和执行SQL查询的类。</span><br><span class="line">java.lang： 包含Java的基本类，如String、Object、Math等，这些类无需显式导入，可以直接使用。</span><br><span class="line">java.nio： 提供了新I/O系统，用于高性能的文件和网络I/O操作。</span><br><span class="line">java.util.concurrent： 用于并发编程的类，如线程池、锁等。</span><br><span class="line"></span><br><span class="line">根据您的任务和需求，选择合适的库来简化编程工作。通常，可以在Java文档中找到每个库和类的详细信息，以帮助了解它们的功能和用法。同时，IDE（如IntelliJ IDEA）通常会提供自动导入库的功能，以简化库的使用。</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br></pre></td></tr></table></figure><p>这一行创建了一个 SimpleDateFormat 对象，用于将输入的日期字符串解析为日期对象。”yyyy-MM-dd” 是日期格式的模式，它表示年-月-日的格式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> dateFormat.parse(inputDate);</span><br></pre></td></tr></table></figure><p>在 try 块中，程序尝试将输入的日期字符串解析为 Date 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.setTime(date);</span><br></pre></td></tr></table></figure><p>这里创建了一个 Calendar 对象，用于执行日期操作。calendar.setTime(date) 设置日历对象的日期为解析后的日期对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> calendar.get(Calendar.YEAR);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 月份从0开始，需要加1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br></pre></td></tr></table></figure><p>这些代码行从 Calendar 对象中提取年、月和日的信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isLeapYear</span> <span class="operator">=</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这一行判断输入的年份是否为闰年。它根据闰年的规则进行判断，如果符合规则，则 isLeapYear 变量为 true，否则为 false。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">daysInMonth</span> <span class="operator">=</span> calendar.getActualMaximum(Calendar.DAY_OF_MONTH);</span><br></pre></td></tr></table></figure><p>这一行获取了输入日期所在月份的天数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK);</span><br></pre></td></tr></table></figure><p>这一行获取了输入日期是星期几，其中星期日是1，星期一是2，以此类推。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] dayOfWeekNames = &#123;<span class="string">&quot;星期日&quot;</span>, <span class="string">&quot;星期一&quot;</span>, <span class="string">&quot;星期二&quot;</span>, <span class="string">&quot;星期三&quot;</span>, <span class="string">&quot;星期四&quot;</span>, <span class="string">&quot;星期五&quot;</span>, <span class="string">&quot;星期六&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">dayOfWeekName</span> <span class="operator">=</span> dayOfWeekNames[dayOfWeek - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这些代码用于将星期数字转换为星期的文本名称，例如将数字1转换为”星期日”。<br>最后，程序将结果输出到控制台，包括年份是否为闰年、月份的天数和输入日期的星期。</p><h2 id="第（2）题"><a href="#第（2）题" class="headerlink" title="第（2）题"></a>第（2）题</h2><p>（2）设计一个Student类，该类中包括学生的姓名和成绩。创建Student类的5个对象，如下所示：<br>姓名成绩<br>刘德华90<br>张学友80<br>刘杰65<br>章子怡100<br>周迅60<br>将以上5个对象放入LinkedList中，完成如下操作和统计：</p><ul><li>输出LinkedList中的对象个数。</li><li>删除姓名为“刘杰”的学生信息，并输出LinkedList中现有学生信息。</li><li>将姓名为“刘德华”的学生成绩改为95。</li><li>输出成绩不及格的学生姓名。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentManagement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个LinkedList并添加5个Student对象</span></span><br><span class="line">        LinkedList&lt;Student&gt; studentList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Student&gt;();</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;刘德华&quot;</span>, <span class="number">90</span>));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张学友&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;刘杰&quot;</span>, <span class="number">65</span>));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;章子怡&quot;</span>, <span class="number">100</span>));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周迅&quot;</span>, <span class="number">60</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出LinkedList中的对象个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedList中的对象个数: &quot;</span> + studentList.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除姓名为“刘杰”的学生信息</span></span><br><span class="line">        Iterator&lt;Student&gt; iterator = studentList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (student.getName().equals(<span class="string">&quot;刘杰&quot;</span>)) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出LinkedList中现有学生信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除“刘杰”后的学生信息:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;姓名: &quot;</span> + student.getName() + <span class="string">&quot;, 成绩: &quot;</span> + student.getScore());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将姓名为“刘德华”的学生成绩改为95</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getName().equals(<span class="string">&quot;刘德华&quot;</span>)) &#123;</span><br><span class="line">                student.setScore(<span class="number">95</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出成绩不及格的学生姓名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;成绩不及格的学生姓名:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getScore() &lt; <span class="number">60</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;姓名: &quot;</span> + student.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第（3）题"><a href="#第（3）题" class="headerlink" title="第（3）题"></a>第（3）题</h2><p>（3）现有以下三个email地址”<a href="mailto:&#x7a;&#x68;&#97;&#x6e;&#x67;&#x73;&#97;&#x6e;&#64;&#x73;&#x6f;&#x68;&#117;&#x2e;&#x63;&#111;&#109;">&#x7a;&#x68;&#97;&#x6e;&#x67;&#x73;&#97;&#x6e;&#64;&#x73;&#x6f;&#x68;&#117;&#x2e;&#x63;&#111;&#109;</a>”、”<a href="mailto:&#108;&#105;&#x73;&#105;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d;">&#108;&#105;&#x73;&#105;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a>”、”<a href="mailto:&#x77;&#x61;&#x6e;&#x67;&#119;&#x75;&#x40;&#115;&#105;&#110;&#x61;&#46;&#x63;&#111;&#x6d;">&#x77;&#x61;&#x6e;&#x67;&#119;&#x75;&#x40;&#115;&#105;&#110;&#x61;&#46;&#x63;&#111;&#x6d;</a>”。需要把email中的用户部分和邮件地址部分分离（即将@前后部分分离），分离后以键值对应的方式存入HashMap中，并遍历输出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProject</span>: Lab_4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsPackage</span>: EmailParser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Shiel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> 2023/10/31 13:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailParser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个HashMap来存储email地址的用户部分和邮件地址部分</span></span><br><span class="line">        HashMap&lt;String, String&gt; emailMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加email地址到HashMap</span></span><br><span class="line">        emailMap.put(<span class="string">&quot;zhangsan@sohu.com&quot;</span>, <span class="string">&quot;用户部分: zhangsan, 邮件地址部分: sohu.com&quot;</span>);</span><br><span class="line">        emailMap.put(<span class="string">&quot;lisi@163.com&quot;</span>, <span class="string">&quot;用户部分: lisi, 邮件地址部分: 163.com&quot;</span>);</span><br><span class="line">        emailMap.put(<span class="string">&quot;wangwu@sina.com&quot;</span>, <span class="string">&quot;用户部分: wangwu, 邮件地址部分: sina.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历HashMap并输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (String email : emailMap.keySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> emailMap.get(email);</span><br><span class="line">            System.out.println(email + <span class="string">&quot; -&gt; &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第（4）题"><a href="#第（4）题" class="headerlink" title="第（4）题"></a>第（4）题</h2><p>（4）现有一段文本如下：“I&#x2F;have&#x2F;a&#x2F;dream&#x2F;今天&#x2F;天气&#x2F;晴朗&#x2F;万里&#x2F;无云&#x2F;I&#x2F;have&#x2F;a&#x2F;good&#x2F;idea&#x2F;今天&#x2F;天气&#x2F;不错”。试用HashMap实现对文本中出现的单词词频进行统计，并对统计结果进行输出显示，如“I：2”，表示单词“I”在文本中出现了两次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProject</span>: Lab_4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsPackage</span>: WordFrequency</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Shiel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> 2023/10/31 13:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordFrequency</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;I/have/a/dream/今天/天气/晴朗/万里/无云/I/have/a/good/idea/今天/天气/不错&quot;</span>;</span><br><span class="line">        String[] words = text.split(<span class="string">&quot;/&quot;</span>); <span class="comment">// 使用斜杠分割文本</span></span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, Integer&gt; wordFrequencyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">// 如果单词已经在HashMap中存在，增加词频；否则，将词频设置为1</span></span><br><span class="line">            <span class="keyword">if</span> (wordFrequencyMap.containsKey(word)) &#123;</span><br><span class="line">                wordFrequencyMap.put(word, wordFrequencyMap.get(word) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wordFrequencyMap.put(word, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历HashMap并输出统计结果</span></span><br><span class="line">        <span class="keyword">for</span> (String word : wordFrequencyMap.keySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> wordFrequencyMap.get(word);</span><br><span class="line">            System.out.println(word + <span class="string">&quot;：&quot;</span> + frequency);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/posts/42877/"/>
      <url>/posts/42877/</url>
      
        <content type="html"><![CDATA[<p><strong>观前提示</strong>：以下内容均为<a href="https://zh.moegirl.org.cn/%E5%A4%A9%E7%8E%8B%E5%AF%BA%E7%92%83%E5%A5%88">天王寺科技</a>所属。<del>与本人无任何联系。</del><br><del><strong>下集预告</strong>：十大排序——选择排序</del></p><h1 id="参考网站："><a href="#参考网站：" class="headerlink" title="参考网站："></a>参考网站：</h1><p><a href="https://www.programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">代码随想录-二分查找</a><br><a href="https://www.runoob.com/w3cnote/the-friendship-algorithm-the-big-bang-theory.html">十大编程算法助程序员走上高手之路 | 菜鸟教程</a><br><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找 - 力扣（LeetCode）</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在引入二分查找之前，先来想一个问题：在一个有序、无重复数组中 <strong>（想一想，为什么要求有序且无重复元素？）</strong>，给一个目标值，要求定义一个函数返回此目标值在数组中的下标。<br>可能你脑海中第一印象是，遍历数组，依次比较目标值是否与每一个元素相等，相等就返回下标。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> length, <span class="type">int</span> target )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( target == a[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><p>这种写法遍历每一个元素，太浪费时间，需要额外的内存，但易理解，那么使用二分不失为一种好方法：<br><strong>二分查找</strong>算法是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，</p><ul><li>如果中间元素正好是要查找的元素，则搜索过程结束；</li><li>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。</li><li>如果在某一步骤数组 为空则代表找不到。<br>这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(log n) 。</li></ul><h1 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h1><ul><li>数组元素必须有序</li><li>数组中不能有重复元素，必须保证返回值唯一</li></ul><h1 id="详解："><a href="#详解：" class="headerlink" title="详解："></a>详解：</h1><p>二分搜索也称为二分查找或折半查找，它充分利用了元素间的次序关系，采用分治策略，<br>可在最坏的情况下用 O(log n)完成搜索任务。它的基本思想是，将 n 个元素分成数量大致相同<br>的两部分，取 a[n&#x2F;2]与欲查找的 x 作比较，如果 x&#x3D;&#x3D;a[n&#x2F;2]则找到 x，算法终止。如果 x＜a[n&#x2F;2]，<br>则我们只要在数组 a 的左半部继续搜索 x（这里假设数组元素呈升序排列）。如果 x＞a[n&#x2F;2]，<br>则我们只要在数组 a 的右半部继续搜索 x。<br>二分搜索过程可以描述为以下递归过程：<br>若待搜区间为空，返回-1；<br>否则<br>mid &#x3D; (low+high)&#x2F;2;<br>若 x 等于 a[mid]，搜索成功，返回 mid；<br>若 x 小于 a[mid]，在左半区间搜索；<br>若 x 大于 a[mid]，在右半区间搜索； </p><h1 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h1><h2 id="1、左闭右闭："><a href="#1、左闭右闭：" class="headerlink" title="1、左闭右闭："></a>1、左闭右闭：</h2><img src="https://picss.sunbangyan.cn/2023/11/07/363a51df2f28492697e54ff56c6d351f.png" alt="二分查找1" /><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">( <span class="type">int</span> a[], <span class="type">int</span> length, <span class="type">int</span> target )</span>&#123;  <span class="comment">//传入数组首地址、长度、待搜索目标值</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = length<span class="number">-1</span>;                   <span class="comment">//因为左闭右闭，所以数组下标为[0, length - 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( left &lt;= right )</span><br><span class="line">        &#123;     <span class="comment">//因为左闭右闭，所以是 &lt;= ，left = right 是允许的</span></span><br><span class="line"><span class="type">int</span> middle = left + (right - left) / <span class="number">2</span>;     <span class="comment">//防止middle长度越界</span></span><br><span class="line"><span class="keyword">if</span>( target &lt; a[middle] )&#123;       <span class="comment">//目标值在middle左边</span></span><br><span class="line">right = middle - <span class="number">1</span>;     <span class="comment">//更新右边界</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( target &gt; a[middle] )&#123;</span><br><span class="line">left = middle + <span class="number">1</span>;        <span class="comment">//更新左边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> middle;          <span class="comment">//即target=a[middle]，说明查找成功，则返回目标值下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">//未找到目标值，返回 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、左闭右开："><a href="#2、左闭右开：" class="headerlink" title="2、左闭右开："></a>2、左闭右开：</h2><img src="https://picdm.sunbangyan.cn/2023/11/07/a19c7cac17b1d9150056163d351f7188.png" alt="二分查找2" /><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> length, <span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = length;         <span class="comment">//因为左闭右开，所以数组下标为[0, length)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt; right )      <span class="comment">//因为左闭右开，所以是 &lt; ，而left = right是不允许的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> middle = left + ( right - left ) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( target &lt; a[middle] )&#123;</span><br><span class="line">            right = middle;         <span class="comment">//更新右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( target &gt; a[middle] )&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;      <span class="comment">//更新左边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;         <span class="comment">//说明查找成功，返回下标值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;       <span class="comment">//未找到目标值，返回 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="要注意的问题"><a href="#要注意的问题" class="headerlink" title="要注意的问题"></a>要注意的问题</h1><h2 id="为什么分为左闭右闭和左闭右开？"><a href="#为什么分为左闭右闭和左闭右开？" class="headerlink" title="为什么分为左闭右闭和左闭右开？"></a>为什么分为左闭右闭和左闭右开？</h2><p>我也不知道，反正就是这么规定的，记住就行了，其实也就是两种情况罢了。<br>每一种情况必须牢记到底是二分的哪种情况，是[ 左闭右闭 ]，还是[ 左闭右开 )，不然程序你是看不懂的，更不要说写了。</p><h2 id="区间的定义"><a href="#区间的定义" class="headerlink" title="区间的定义"></a>区间的定义</h2><ul><li><strong>左闭右闭时，为什么left&lt;&#x3D; right？左闭右开时，为什么left &lt; right？</strong><br>首先，target 所在的区间即为 left 和 right 之间。把它当成数学的区间看待，那么此区间必须是有意义的。<br><strong>不论哪种情况，right最大所能取到的值都不能越界、区间都要有意义。</strong><br>左闭右闭：<br>left &lt;&#x3D; right是有意义的，因为[left, right]是一个有效区间，可以取到。</li><li><strong>左闭右开 以此类推</strong>。</li></ul><h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><ul><li>**左闭右闭时，为什么target &lt;&#x3D; a[middle]时，right &#x3D; middle - 1？而左闭右开却不是？**<br>还是区间是否有效的问题。<br>target &lt; a[middle] 时，right &#x3D; middle - 1：因为是闭区间[ ]，右边界是可以取到的；而 &lt; 说明target不在此区间，我们要更新查找的空间，即在此区间的左区间，即 middle - 1。如果是middle，那更新了个寂寞……<br>target &gt; a[middle] 时，right &#x3D; middle + 1：由上面分析可知，这次要更新的是右区间了，即middle + 1。</li><li><strong>左闭右开</strong><br>这种情况，是[ )了，右区间是取不到的，更新时就要注意了，动手在纸上画画吧！</li></ul><hr><p>好了，你已经学会二分了，快去敲代码试试吧！</p><h1 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">( vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target )</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right )&#123;</span><br><span class="line">          <span class="type">int</span> middle = left + ( right - left ) / <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span>( target &lt; nums[middle] )&#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; nums[middle] )&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">( vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target )</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( left &lt; right )&#123;</span><br><span class="line">          <span class="type">int</span> middle = left + ( right - left ) / <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span>( target &lt; nums[middle] )&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; nums[middle] )&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 排序和查找 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续存储数组的算法演示</title>
      <link href="/posts/35130/"/>
      <url>/posts/35130/</url>
      
        <content type="html"><![CDATA[<p>郝斌老师数据结构视频学习记录。<br>涉及到数组的初始化、插入、删除、查找、翻转、排序等。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. 讲数组是为了讲泛型：</span></span><br><span class="line"><span class="comment">    存储不一样，操作就不一样；</span></span><br><span class="line"><span class="comment">    而泛型达到的效果是：存储不一样，但操作一样</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  2. 试数，画图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span><span class="comment">//包含了malloc函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">//包含了exit函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>* pBase;     <span class="comment">//存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> len;        <span class="comment">//数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> cnt;        <span class="comment">//当前数组有效元素的个数</span></span><br><span class="line">&#125;;                  <span class="comment">//分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> len)</span>;   <span class="comment">//初始化数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>;    <span class="comment">//获取下标</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_empty</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>;    <span class="comment">//判断数组是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_full</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>;     <span class="comment">//判断数组是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Append_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>;     <span class="comment">//追加</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> pos, <span class="type">int</span> val)</span>;    <span class="comment">//插入,pos从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span>;     <span class="comment">//删除</span></span><br><span class="line"><span class="comment">//如果用int，无法判断是否删除成功。bool不能返回删除的值，所以只能用指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Inversion_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>;   <span class="comment">//翻转，倒置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>;        <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span> <span class="title">arr</span>;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    </span><br><span class="line">    Init_arr(&amp;arr, <span class="number">6</span>);</span><br><span class="line">    Show_arr(&amp;arr);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">1</span>);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">10</span>);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">-3</span>);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">6</span>);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">88</span>);</span><br><span class="line">    Append_arr(&amp;arr, <span class="number">11</span>);</span><br><span class="line">    </span><br><span class="line">    Get_arr(&amp;arr, <span class="number">4</span>);</span><br><span class="line">    Insert_arr(&amp;arr, <span class="number">6</span>, <span class="number">99</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把val的地址发给pVal,在函数内部可以通过它修改val的值</span></span><br><span class="line">    <span class="keyword">if</span>( Delete_arr(&amp;arr, <span class="number">4</span>, &amp;val) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除的元素是：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    if( Append_arr(&amp;arr, 7) )&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;追加成功！\n&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;追加失败\n&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Show_arr(&amp;arr);</span><br><span class="line">    Inversion_arr(&amp;arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;倒置之后的数组内容是：\n&quot;</span>);</span><br><span class="line">    Show_arr(&amp;arr);</span><br><span class="line">    Sort_arr(&amp;arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组内容是:\n&quot;</span>);</span><br><span class="line">    Show_arr(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* len);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pArr-&gt;pBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态分配内存失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);   <span class="comment">//终止整个程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pArr-&gt;len = len;</span><br><span class="line">        pArr-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;     <span class="comment">//表示此函数终止了，增强可读性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Is_empty(pArr) )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取下标失败！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;cnt; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pArr-&gt;pBase[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d的数组下标为：&quot;</span>, val);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_empty</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == pArr-&gt;cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_full</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pArr-&gt;cnt == pArr-&gt;len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>&#123;<span class="comment">//此处的pArr来自arr，即结构体变量地址</span></span><br><span class="line">    <span class="keyword">if</span>(Is_empty(pArr))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//*pArr错误，此处应该接收结构体变量的地址，而pArr已经是了，不需要加*</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组为空!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pArr-&gt;pBase[i]);</span><br><span class="line">            <span class="comment">//pArr[i],(*pArr[i])错误，因为都不是数组名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Append_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="comment">//满时返回false</span></span><br><span class="line">    <span class="keyword">if</span>( Is_full(pArr) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//不满时追加</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//是cnt，不是cnt+1，不是cnt-1————试数，下标与数组关系</span></span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;cnt] = val;</span><br><span class="line">        (pArr-&gt;cnt)++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos的值从1开始，即插入后的次序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> pos, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Is_full(pArr))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos&gt;pArr-&gt;cnt+<span class="number">1</span>)<span class="comment">//pos不能为负，不能大于有效个数+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i的值-不用记，试数，画图就行了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pArr-&gt;cnt<span class="number">-1</span>; i&gt;=pos<span class="number">-1</span>; i--)&#123;</span><br><span class="line">        pArr-&gt;pBase[i+<span class="number">1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;pBase[pos<span class="number">-1</span>] = val;</span><br><span class="line">    (pArr-&gt;cnt)++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete_arr</span><span class="params">(<span class="keyword">struct</span> Arr * pArr, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Is_empty(pArr))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos&gt;pArr-&gt;cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    *pVal = pArr-&gt;pBase[pos<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos; i&lt;pArr-&gt;cnt; i++)&#123;</span><br><span class="line">        pArr-&gt;pBase[i<span class="number">-1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;cnt--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inversion_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;cnt/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[pArr-&gt;cnt<span class="number">-1</span>-i];</span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;cnt<span class="number">-1</span>-i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;cnt<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;pArr-&gt;cnt; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pArr-&gt;pBase[i] &gt; pArr-&gt;pBase[j])&#123;</span><br><span class="line">                t = pArr-&gt;pBase[i];</span><br><span class="line">                pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">                pArr-&gt;pBase[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>其中Inversion_arr翻转数组可以使用折半方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Inversion_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pArr-&gt;cnt/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[pArr-&gt;cnt<span class="number">-1</span>-i];</span><br><span class="line">        pArr-&gt;pBase[pArr-&gt;cnt<span class="number">-1</span>-i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于下面这种方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Inversion_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = pArr-&gt;cnt<span class="number">-1</span>, t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">        pArr-&gt;pBase[j] = t;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法并不是最优解，因为它需要使用额外的空间来存储输入的数组，即使是在原地翻转数组的情况下，交换的操作次数也更多。<br>而第一种方法更简洁的方法在不使用额外空间的情况下原地翻转数组，而且只需要一次遍历，每次将首尾元素进行交换，从而实现原地翻转数组。</p><p>下面再看查找数组，相信你已经猜到了，当然是二分啦！</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Get_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Is_empty(pArr) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取下标失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pArr-&gt;cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pArr-&gt;pBase[i] == val)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d的数组下标为：&quot;</span>, val);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方法是最笨、但也是最容易理解的方法，但是效率太低了。<br>那么就对它使用二分吧：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种：左闭右闭</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = pArr-&gt;cnt<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; pArr-&gt;pBase[middle])&#123;</span><br><span class="line">            right = middle<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; pArr-&gt;pBase[middle])&#123;</span><br><span class="line">            left = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种：左闭右开</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_arr_2</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = pArr-&gt;cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; pArr-&gt;pBase[middle])&#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; pArr-&gt;pBase[middle])&#123;</span><br><span class="line">            left = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一颠（2）</title>
      <link href="/posts/14317/"/>
      <url>/posts/14317/</url>
      
        <content type="html"><![CDATA[<p><em><del>本系列全新命名：每日一癫 喵</del></em><br><em><del>激情赶稿！动力满满喵</del></em></p><hr><p>首先我不是米娅粉，但她真的很可爱。我对米娅确实没有什么幻想，毕竟我不是lovelive粉。但是该说不说的，米娅，真的可爱死了，<br>我真的不是lovelive粉。有一说一，我也确实说不喜欢米娅。因为这个企划确实是挺好看的，我就不是lovelive粉，但是怎么说，一看到她，心里就痒痒的，类似一种原始冲动，就像看到影视剧里看到多年未见的老友的重逢，一段崭新情缘的开端一样，激发人向美向善最淳朴的一面。就像登上山峰，目睹潮汐那般自然，仿佛冥冥之中自有天意就是一种朦胧的感觉，像伟大的革命友谊一样，令人憧憬，要是能和我牵个手就更好了，毕竟我不是米娅粉。</p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.wwfoOjPFvYg9Gg-QMZLFsAAAAA?pid=ImgDet&rs=1" alt="曲绘" title="曲绘" style="zoom: 60%;" /><p><a href="https://music.163.com/song?id=1960852861&userid=310905058">stars we chase——内田秀</a><br>TV动画《Love Live! 虹咲学园校园偶像同好会 第二季》第9集插曲</p><blockquote><ul><li><em>哪有二次元会听英文歌啊</em></li><li><em>Let’s restart it, you and me Walking on that new story 米娅唱完solo，打开岚珠心结以后，是栞子抱上了岚珠，米娅却只能在边上看着，真令人感慨，流水的CP，永恒的love triangle。</em></li><li><em>如果是萌p的话一切都合理起来了。</em></li><li><em>米娅饱含深情唱完stars we chase；岚珠：栞子是我唯一的朋友。</em></li><li><em>美国大帅哥表白中国直女，我为什么会做这样的梦？</em></li></ul></blockquote><p><strong>╯ 　乀<br>ヘ　  へ<br>　 ′<br>　 ﹀<br>步也挺好吗？</strong></p><hr><p>Ps: <strong>wyy</strong>你不要太过分了，最开始不需要vip的时候我就下载了，结果今天一听就只能试听了。你要说最开始就是vip我还能勉强接受变为试听，你然而中途变为vip，那我之前下载的全听不了了…</p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 发癫日常 </tag>
            
            <tag> ACGN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/posts/22648/"/>
      <url>/posts/22648/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="markdown的使用说明"><a href="#markdown的使用说明" class="headerlink" title="markdown的使用说明"></a>markdown的使用说明</h1><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><blockquote><p>语法：# (一级标题)  ## (二级标题)  ### (三级标题) ……</p></blockquote><blockquote><p>代码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;# 这是一级标题</span><br><span class="line">&gt;## 这是二级标题</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:  </p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2></blockquote><blockquote><p>快捷键:</p><ul><li>Ctrl+数字1~6可以快速将选中的文本调成对应级别的标题</li><li>Ctrl+0可以快速将选中的文本调成普通文本</li><li>Ctrl+加号&#x2F;减号对标题级别进行加减</li></ul></blockquote><h2 id="二、段落"><a href="#二、段落" class="headerlink" title="二、段落"></a>二、段落</h2><h3 id="1、换行"><a href="#1、换行" class="headerlink" title="1、换行"></a>1、换行</h3><blockquote><p>代码:  </p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是一个段落</span><br><span class="line">&gt;这是一个段落</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果: </p><p>这是一个段落<br>这是一个段落</p></blockquote><h3 id="2、分割线"><a href="#2、分割线" class="headerlink" title="2、分割线"></a>2、分割线</h3><blockquote><p>语法:  —或者***+回车</p></blockquote><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;---或者<span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><hr></blockquote><h2 id="三、文字显示"><a href="#三、文字显示" class="headerlink" title="三、文字显示"></a>三、文字显示</h2><h3 id="1、字体"><a href="#1、字体" class="headerlink" title="1、字体"></a>1、字体</h3><blockquote><p>语法:</p><ul><li>粗体:  用一对双星号包裹</li><li>删除线:  用一对双飘号包裹</li><li>下划线:  用一对u标签包裹</li><li>斜体:  用一对单星号包裹</li><li>高亮:  用一对双等号包裹</li></ul></blockquote><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;<span class="strong">**这是粗体**</span></span><br><span class="line">&gt;~~这是删除线~~</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>这是下划线<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line">&gt;<span class="emphasis">*这是斜体*</span></span><br><span class="line">&gt;==这是高亮==</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br><strong>这是粗体</strong><br><del>这是删除线</del><br><u>这是下划线</u><br><em>这是斜体</em><br>&#x3D;&#x3D;这是高亮&#x3D;&#x3D;</p></blockquote><blockquote><p>快捷键:</p><ul><li>加粗:  Ctrl+B</li><li>删除线:  Shift+Alt+5</li><li>下划线:  Ctrl+U</li><li>斜体:  Ctrl+I</li></ul></blockquote><h3 id="2、上下标"><a href="#2、上下标" class="headerlink" title="2、上下标"></a>2、上下标</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;x^2^</span><br><span class="line">&gt;H~2~O</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>x^2^<br>H<del>2</del>O</p></blockquote><h2 id="四、列表"><a href="#四、列表" class="headerlink" title="四、列表"></a>四、列表</h2><h3 id="1、无序列表"><a href="#1、无序列表" class="headerlink" title="1、无序列表"></a>1、无序列表</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;<span class="emphasis">*/-/+ +空格</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>1.只有同一级别:</p><ul><li>苹果</li><li>香蕉</li><li>橘子</li></ul><p>2.子集类:</p><ul><li>一级分类</li><li>二级分类 <ul><li>三级分类</li></ul></li></ul></blockquote><blockquote><p>快捷键:  Ctrl+Shift+]</p></blockquote><h3 id="2、有序列表"><a href="#2、有序列表" class="headerlink" title="2、有序列表"></a>2、有序列表</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;数字+.+空格</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><ol><li>第一个标题</li><li>第二个标题</li><li>第三个标题</li></ol><ul><li>子内容1<ul><li>子内容2</li></ul></li></ul><ol start="4"><li>第四个标题</li></ol></blockquote><blockquote><p>快捷键:  Ctrl+Shift+[</p></blockquote><h3 id="3、任务列表"><a href="#3、任务列表" class="headerlink" title="3、任务列表"></a>3、任务列表</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;- [ ] 吃早餐</span><br><span class="line">&gt;- [x] 背单词</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><ul><li><input disabled="" type="checkbox"> 吃早餐</li><li><input checked="" disabled="" type="checkbox"> 背单词</li></ul></blockquote><h2 id="五、区块显示"><a href="#五、区块显示" class="headerlink" title="五、区块显示"></a>五、区块显示</h2><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;&gt;+回车</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><blockquote><p>这是最外层区块</p></blockquote><blockquote><blockquote><p>这是内层区块</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>这是最内层区块</p></blockquote></blockquote></blockquote></blockquote><h2 id="六、代码显示"><a href="#六、代码显示" class="headerlink" title="六、代码显示"></a>六、代码显示</h2><h3 id="1、行内代码"><a href="#1、行内代码" class="headerlink" title="1、行内代码"></a>1、行内代码</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;<span class="code">`int a=0;`</span>（说明：`位于Esc下面）</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br><code>int a=0;</code></p></blockquote><blockquote><p>快捷键:  Ctrl+Shift+&#96;</p></blockquote><h3 id="2、代码块"><a href="#2、代码块" class="headerlink" title="2、代码块"></a>2、代码块</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;<span class="code">```js/java/c#/text</span></span><br><span class="line"><span class="code">&gt;内容</span></span><br><span class="line"><span class="code">&gt;```</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>快捷键:  Ctrl+Shift+K</p></blockquote><h2 id="七、链接"><a href="#七、链接" class="headerlink" title="七、链接"></a>七、链接</h2><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;www.baidu.com</span><br><span class="line">&gt;[<span class="string">百度一下</span>](<span class="link">https://www.baidu.com</span>)</span><br><span class="line">&gt;[<span class="string">百度一下</span>](<span class="link">https://www.baidu.com &quot;https://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br><a href="http://www.baidu.com/">www.baidu.com</a><br><a href="https://www.baidu.com/">百度一下</a><br><a href="https://www.baidu.com/" title="https://www.baidu.com">百度一下</a></p></blockquote><blockquote><p>快捷键:  Ctrl+K</p></blockquote><h2 id="八、脚注"><a href="#八、脚注" class="headerlink" title="八、脚注"></a>八、脚注</h2><blockquote><p>说明:  对文本进行解释说明。</p></blockquote><blockquote><p>代码: </p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;[^文本]</span><br><span class="line">&gt;[^文本]:解释说明</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>这是一个技术<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%E6%A1%86%E6%9E%B6%E3%80%82">^①</a></p></blockquote><h2 id="九、图片插入"><a href="#九、图片插入" class="headerlink" title="九、图片插入"></a>九、图片插入</h2><blockquote><p>代码:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;![不显示的文字](图片路径 &quot;图片标题&quot;)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br><img src="D:\001-changyong\001-xuexiwenjian\壁纸.webp" alt="This is a picture"></p><p>(注：效果路径为C:\Users\asus\Pictures\Saved Pictures\Snipaste_2020-09-03_13-19-11.png。在其他电脑上可能不显示。)</p></blockquote><blockquote><p>快捷键:  Ctrl+Shift+I</p></blockquote><h2 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h2><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;|  1   |  2   |  3   |</span><br><span class="line">&gt;| :--- | :--: | ---: |</span><br><span class="line">&gt;|  4   |  5   |  6   |</span><br><span class="line">&gt;|  7   |  8   |  9   |</span><br><span class="line">&gt;|  10  |  11  |  12  |</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><table><thead><tr><th>1</th><th align="center">2</th><th align="right">3</th></tr></thead><tbody><tr><td>4</td><td align="center">5</td><td align="right">6</td></tr><tr><td>7</td><td align="center">8</td><td align="right">9</td></tr><tr><td>10</td><td align="center">11</td><td align="right">12</td></tr></tbody></table></blockquote><blockquote><p>快捷键:  Ctrl+T</p></blockquote><h2 id="十一、流程图"><a href="#十一、流程图" class="headerlink" title="十一、流程图"></a>十一、流程图</h2><h3 id="1、横向流程图"><a href="#1、横向流程图" class="headerlink" title="1、横向流程图"></a>1、横向流程图</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph LR</span></span><br><span class="line"><span class="code">A[方形]==&gt;B(圆角)</span></span><br><span class="line"><span class="code">B==&gt;C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">C--&gt;|a=1|D[结果1]</span></span><br><span class="line"><span class="code">C--&gt;|a=2|E[结果2]</span></span><br><span class="line"><span class="code">F[横向流程图]</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;graph LR</span><br><span class="line">&gt;A[方形]==&gt;B(圆角)</span><br><span class="line">&gt;B==&gt;C&#123;条件a&#125;</span><br><span class="line">&gt;C--&gt;|a=1|D[结果1]</span><br><span class="line">&gt;C--&gt;|a=2|E[结果2]</span><br><span class="line">&gt;F[横向流程图]</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、竖向流程图"><a href="#2、竖向流程图" class="headerlink" title="2、竖向流程图"></a>2、竖向流程图</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```mermaid</span></span><br><span class="line"><span class="code">graph TD</span></span><br><span class="line"><span class="code">A[方形]==&gt;B(圆角)</span></span><br><span class="line"><span class="code">B==&gt;C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">C--&gt;|a=1|D[结果1]</span></span><br><span class="line"><span class="code">C--&gt;|a=2|E[结果2]</span></span><br><span class="line"><span class="code">F[竖向流程图]</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;graph TD</span><br><span class="line">&gt;A[方形]==&gt;B(圆角)</span><br><span class="line">&gt;B==&gt;C&#123;条件a&#125;</span><br><span class="line">&gt;C--&gt;|a=1|D[结果1]</span><br><span class="line">&gt;C--&gt;|a=2|E[结果2]</span><br><span class="line">&gt;F[竖向流程图]</span><br></pre></td></tr></table></figure></blockquote><h2 id="十二、表情符号"><a href="#十二、表情符号" class="headerlink" title="十二、表情符号"></a>十二、表情符号</h2><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;:happy:、:cry:、:man:</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>:happy:、 :cry:、 :man:</p></blockquote><h2 id="十三、数学公式的输入"><a href="#十三、数学公式的输入" class="headerlink" title="十三、数学公式的输入"></a>十三、数学公式的输入</h2><h3 id="1、公式的插入"><a href="#1、公式的插入" class="headerlink" title="1、公式的插入"></a>1、公式的插入</h3><h4 id="①行中公式"><a href="#①行中公式" class="headerlink" title="①行中公式"></a>①行中公式</h4><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$公式$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$公式$</p></blockquote><h4 id="②独立公式"><a href="#②独立公式" class="headerlink" title="②独立公式"></a>②独立公式</h4><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$$</span><br><span class="line">&gt;公式</span><br><span class="line">&gt;$$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$$<br>公式<br>$$</p></blockquote><h3 id="2、上下标-1"><a href="#2、上下标-1" class="headerlink" title="2、上下标"></a>2、上下标</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$x^&#123;y^z&#125;=(1+e^x)^&#123;-2xy^w&#125;$</span><br><span class="line">&gt;$\sideset&#123;^1<span class="emphasis">_2&#125;&#123;^3_</span>4&#125;&#123;\underset&#123;6&#125;\bigotimes&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$x^{y^z}&#x3D;(1+e^x)^{-2xy^w}$<br>$\sideset{^1_2}{^3_4}{\underset{6}\bigotimes}$</p></blockquote><h3 id="3、括号和分隔符"><a href="#3、括号和分隔符" class="headerlink" title="3、括号和分隔符"></a>3、括号和分隔符</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\langle\quad\rangle\quad\lceil\quad\rceil\quad\lfloor\quad\rfloor\quad\lbrace\quad\rbrace\quad\lVert\quad\rVert$</span><br><span class="line">&gt;$f(x,y,z)=3y^2z\left(3+\dfrac&#123;7x+5&#125;&#123;1+y^2&#125;\right)$</span><br><span class="line">&gt;$\left.\dfrac&#123;\mathrm&#123;d&#125;u&#125;&#123;\mathrm&#123;d&#125;x&#125;\right|<span class="emphasis">_&#123;x=0&#125;$</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\langle\quad\rangle\quad\lceil\quad\rceil\quad\lfloor\quad\rfloor\quad\lbrace\quad\rbrace\quad\lVert\quad\rVert$<br>$f(x,y,z)&#x3D;3y^2z\left(3+\dfrac{7x+5}{1+y^2}\right)$<br>$\left.\dfrac{\mathrm{d}u}{\mathrm{d}x}\right|_{x&#x3D;0}$</p></blockquote><h3 id="4、分数"><a href="#4、分数" class="headerlink" title="4、分数"></a>4、分数</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\frac&#123;a&#125;&#123;b&#125;\quad\dfrac&#123;a&#125;&#123;b&#125;\quad &#123;a\over b&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\frac{a}{b}\quad\dfrac{a}{b}\quad {a\over b}$</p></blockquote><h3 id="5、开方"><a href="#5、开方" class="headerlink" title="5、开方"></a>5、开方</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\sqrt[根指数,省略时为2]&#123;被开方数&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\sqrt{2}\quad\sqrt[3]{2}$</p></blockquote><h3 id="6、省略号"><a href="#6、省略号" class="headerlink" title="6、省略号"></a>6、省略号</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\cdots\quad\ldots\quad\vdots\quad\ddots$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\cdots\quad\ldots\quad\vdots\quad\ddots$</p></blockquote><h3 id="7、矢量和均值"><a href="#7、矢量和均值" class="headerlink" title="7、矢量和均值"></a>7、矢量和均值</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\overrightarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\overleftarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\overleftrightarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\underrightarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\underleftarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\underleftrightarrow&#123;E(\vec&#123;r&#125;)&#125;\quad\overline&#123;v&#125;=\bar&#123;v&#125;\quad\underline&#123;v&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\overrightarrow{E(\vec{r})}\quad\overleftarrow{E(\vec{r})}\quad\overleftrightarrow{E(\vec{r})}\quad\underrightarrow{E(\vec{r})}\quad\underleftarrow{E(\vec{r})}\quad\underleftrightarrow{E(\vec{r})}\quad\overline{v}&#x3D;\bar{v}\quad\underline{v}$</p></blockquote><h3 id="8、积分"><a href="#8、积分" class="headerlink" title="8、积分"></a>8、积分</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$$</span><br><span class="line">&gt;\iint\limits<span class="emphasis">_D\left(\dfrac&#123;\partial Q&#125;&#123;\partial x&#125;-\dfrac&#123;\partial P&#125;&#123;\partial y&#125;\right)&#123;\rm d&#125;x&#123;\rm d&#125;y=\oint\limits_</span>LP&#123;\rm d&#125;x+Q&#123;\rm d&#125;y</span><br><span class="line">&gt;$$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$$<br>\iint\limits_D\left(\dfrac{\partial Q}{\partial x}-\dfrac{\partial P}{\partial y}\right){\rm d}x{\rm d}y&#x3D;\oint\limits_LP{\rm d}x+Q{\rm d}y<br>$$</p></blockquote><h3 id="9、极限"><a href="#9、极限" class="headerlink" title="9、极限"></a>9、极限</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\lim\limits<span class="emphasis">_&#123;n\to\infin&#125;(1+\dfrac&#123;1&#125;&#123;n&#125;)^n=e$</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\lim\limits_{n\to\infin}(1+\dfrac{1}{n})^n&#x3D;e$</p></blockquote><h3 id="10、累加、累乘及交集、并集"><a href="#10、累加、累乘及交集、并集" class="headerlink" title="10、累加、累乘及交集、并集"></a>10、累加、累乘及交集、并集</h3><blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\sum\limits<span class="emphasis">_&#123;i=1&#125;^n\dfrac&#123;1&#125;&#123;n^2&#125;\quad and\quad\prod\limits_</span>&#123;i=1&#125;^n\dfrac&#123;1&#125;&#123;n^2&#125;\quad and\quad\bigcup\limits<span class="emphasis">_&#123;i=1&#125;^n\dfrac&#123;1&#125;&#123;n^2&#125;\quad and\quad\bigcap\limits_</span>&#123;i=1&#125;^n\dfrac&#123;1&#125;&#123;n^2&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$\sum\limits_{i&#x3D;1}^n\dfrac{1}{n^2}\quad and\quad\prod\limits_{i&#x3D;1}^n\dfrac{1}{n^2}\quad and\quad\bigcup\limits_{i&#x3D;1}^n\dfrac{1}{n^2}\quad and\quad\bigcap\limits_{i&#x3D;1}^n\dfrac{1}{n^2}$</p></blockquote><h3 id="11、希腊字母"><a href="#11、希腊字母" class="headerlink" title="11、希腊字母"></a>11、希腊字母</h3><table><thead><tr><th>语法</th><th>字母</th><th>语法</th><th>字母</th><th>语法</th><th>字母</th></tr></thead><tbody><tr><td>\Alpha(\alpha)</td><td>$\Alpha(\alpha)$</td><td>\Beta(\beta)</td><td>$\Beta(\beta)$</td><td>\Gamma(\gamma)</td><td>$\Gamma(\gamma)$</td></tr><tr><td>\Epsilon(\epsilon)\varepsilon</td><td>$\Epsilon(\epsilon)\varepsilon$</td><td>\Zeta(\zeta)</td><td>$\Zeta(\zeta)$</td><td>\Eta(\eta)</td><td>$\Eta(\eta)$</td></tr><tr><td>\Iota(\iota)</td><td>$\Iota(\iota)$</td><td>\Kappa(\kappa)\varkappa</td><td>$\Kappa(\kappa)\varkappa$</td><td>\Lambda(\lambda)</td><td>$\Lambda(\lambda)$</td></tr><tr><td>\Nu(\nu)</td><td>$\Nu(\nu)$</td><td>\Xi(\xi)</td><td>$\Xi(\xi)$</td><td>\Omicron(\omicron)</td><td>$\Omicron(\omicron)$</td></tr><tr><td>\Rho(\rho)\varrho</td><td>$\Rho(\rho)\varrho$</td><td>\Sigma(\sigma)\varsigma</td><td>$\Sigma(\sigma)\varsigma$</td><td>\Tau(\tau)</td><td>$\Tau(\tau)$</td></tr><tr><td>\Phi(\phi)\varphi</td><td>$\Phi(\phi)\varphi$</td><td>\Chi(\chi)</td><td>$\Chi(\chi)$</td><td>\Psi(\psi)</td><td>$\Psi(\psi)$</td></tr><tr><td>\Delta(\delta)</td><td>$\Delta(\delta)$</td><td>\Theta(\theta)\vartheta</td><td>$\Theta(\theta)\vartheta$</td><td>\Mu(\mu)</td><td>$\Mu(\mu)$</td></tr><tr><td>\Pi(\pi)\varpi</td><td>$\Pi(\pi)\varpi$</td><td>\Omega(\omega)</td><td>$\Omega(\omega)$</td><td>\upsilon</td><td>$\upsilon$</td></tr><tr><td>\ell</td><td>$\ell$</td><td>\eth</td><td>$\eth$</td><td>\hbar</td><td>$\hbar$</td></tr><tr><td>\hslash</td><td>$\hslash$</td><td>\mho</td><td>$\mho$</td><td>\partial</td><td>$\partial$</td></tr></tbody></table><h3 id="12、特殊字符"><a href="#12、特殊字符" class="headerlink" title="12、特殊字符"></a>12、特殊字符</h3><h4 id="①说明"><a href="#①说明" class="headerlink" title="①说明"></a>①说明</h4><blockquote><p>可以在字符前使用<code>\large</code>或<code>\small</code>以显示更大或更小的字符。${\LARGE A}{\Large A}{\large A}A{\small A}$</p></blockquote><h4 id="②关系运算符"><a href="#②关系运算符" class="headerlink" title="②关系运算符"></a>②关系运算符</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\pm(\mp)</td><td>$\pm(\mp)$</td><td>\times</td><td>$\times$</td><td>\div</td><td>$\div$</td></tr><tr><td>\nmid</td><td>$\nmid$</td><td>\cdot</td><td>$\cdot$</td><td>\mid</td><td>$\mid$</td></tr><tr><td>\bigodot</td><td>$\bigodot$</td><td>\bigotimes</td><td>$\bigotimes$</td><td>\bigoplus</td><td>$\bigoplus$</td></tr><tr><td>\ge</td><td>$\ge$</td><td>\le</td><td>$\le$</td><td>\ll</td><td>$\ll$</td></tr><tr><td>\geqslant</td><td>$\geqslant$</td><td>\leqslant</td><td>$\leqslant$</td><td>\neq</td><td>$\neq$</td></tr><tr><td>\approx</td><td>$\approx$</td><td>\xlongequal{文本}</td><td>$\xlongequal{文本}$</td><td>\triangleq</td><td>$\triangleq$</td></tr><tr><td>\sim</td><td>$\sim$</td><td>\doteq</td><td>$\doteq$</td><td>\equiv</td><td>$\equiv$</td></tr><tr><td>\cong</td><td>$\cong$</td><td>\propto</td><td>$\propto$</td><td>\parallel(\</td><td>)</td></tr><tr><td>\prec</td><td>$\prec$</td><td>\pmod{2}</td><td>$\pmod{2}$</td><td>\bmod</td><td>$\bmod{2}$</td></tr></tbody></table><h4 id="③集合运算符"><a href="#③集合运算符" class="headerlink" title="③集合运算符"></a>③集合运算符</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\emptyset</td><td>$\emptyset$</td><td>\varnothing</td><td>$\varnothing$</td><td></td><td></td></tr><tr><td>\subset</td><td>$\subset$</td><td>\subseteq</td><td>$\subseteq$</td><td>\subsetneq</td><td>$\subsetneq$</td></tr><tr><td>\supset</td><td>$\supset$</td><td>\supseteq</td><td>$\supseteq$</td><td>\supsetneq</td><td>$\supsetneq$</td></tr><tr><td>\bigcap</td><td>$\bigcap$</td><td>\bigcup</td><td>$\bigcup$</td><td>\setminus</td><td>$\setminus$</td></tr><tr><td>\bigvee</td><td>$\bigvee$</td><td>\bigwedge</td><td>$\bigwedge$</td><td></td><td></td></tr><tr><td>\in</td><td>$\in$</td><td>\notin</td><td>$\notin$</td><td>\ni</td><td>$\ni$</td></tr></tbody></table><h4 id="④三角运算符"><a href="#④三角运算符" class="headerlink" title="④三角运算符"></a>④三角运算符</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\circ</td><td>$\circ$</td><td>\bot</td><td>$\bot$</td><td>\angle</td><td>$\angle$</td></tr><tr><td>\degree</td><td>$\degree$</td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="⑤微积分运算符"><a href="#⑤微积分运算符" class="headerlink" title="⑤微积分运算符"></a>⑤微积分运算符</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\int</td><td>$\int$</td><td>\iint</td><td>$\iint$</td><td>\iiint</td><td>$\iiint$</td></tr><tr><td>\oint</td><td>$\oint$</td><td>\oiint</td><td>$\oiint$</td><td>\prime(‘)</td><td>$\prime$</td></tr><tr><td>\lim</td><td>$\lim$</td><td>\infin</td><td>$\infin$</td><td>\nabla</td><td>$\nabla$</td></tr><tr><td>\grad</td><td>$\grad$</td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="⑥逻辑运算符"><a href="#⑥逻辑运算符" class="headerlink" title="⑥逻辑运算符"></a>⑥逻辑运算符</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\because</td><td>$\because$</td><td>\therefore</td><td>$\therefore$</td><td></td><td></td></tr><tr><td>\forall</td><td>$\forall$</td><td>\exist</td><td>$\exist$</td><td></td><td></td></tr><tr><td>\not&gt;</td><td>$\not&gt;$</td><td>\not&lt;</td><td>$\not&lt;$</td><td></td><td></td></tr><tr><td>\land</td><td>$\land$</td><td>\lor</td><td>$\lor$</td><td>\lnot</td><td>$\lnot$</td></tr><tr><td>\top</td><td>$\top$</td><td>\vdash</td><td>$\vdash$</td><td>\vDash</td><td>$\vDash$</td></tr></tbody></table><h4 id="⑦带帽符号"><a href="#⑦带帽符号" class="headerlink" title="⑦带帽符号"></a>⑦带帽符号</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\hat{xy}</td><td>$\hat{xy}$</td><td>\widehat{xyz}</td><td>$\widehat{xyz}$</td></tr><tr><td>\tilde{xy}</td><td>$\tilde{xy}$</td><td>\widetilde{xyz}</td><td>$\widetilde{xyz}$</td></tr><tr><td>\check{x}</td><td>$\check{x}$</td><td>\breve{y}</td><td>$\breve{y}$</td></tr><tr><td>\grave{x}</td><td>$\grave{x}$</td><td>\acute{y}</td><td>$\acute{y}$</td></tr><tr><td>\dot{x}</td><td>$\dot{x}$</td><td>\ddot{x}</td><td>$\ddot{x}$</td></tr><tr><td>\overparen{xy}</td><td>$\overparen{xy}$</td><td></td><td></td></tr></tbody></table><h4 id="⑧选取符号"><a href="#⑧选取符号" class="headerlink" title="⑧选取符号"></a>⑧选取符号</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\fbox{a+b+c+d}</td><td>$\fbox{a+b+c+d}$</td><td></td><td></td></tr><tr><td>\overbrace{xx\cdots x}^{10个x}</td><td>$\overbrace{xx\cdots x}^{10个x}$</td><td>\underbrace{xx\cdots x}_{10个x}</td><td>$\underbrace{xx\cdots x}_{10个x}$</td></tr></tbody></table><h4 id="⑨箭头符号"><a href="#⑨箭头符号" class="headerlink" title="⑨箭头符号"></a>⑨箭头符号</h4><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>\leftarrow</td><td>$\leftarrow$</td><td>\rightarrow</td><td>$\rightarrow$</td><td>\leftrightarrow</td><td>$\leftrightarrow$</td></tr><tr><td>\longleftarrow</td><td>$\longleftarrow$</td><td>\longrightarrow</td><td>$\longrightarrow$</td><td>\longleftrightarrow</td><td>$\longleftrightarrow$</td></tr><tr><td>\Leftarrow</td><td>$\Leftarrow$</td><td>\Rightarrow</td><td>$\Rightarrow$</td><td>\Leftrightarrow</td><td>$\Leftrightarrow$</td></tr><tr><td>\Longleftarrow</td><td>$\Longleftarrow$</td><td>\Longrightarrow</td><td>$\Longrightarrow$</td><td>\Longleftrightarrow</td><td>$\Longleftrightarrow$</td></tr><tr><td>\uparrow</td><td>$\uparrow$</td><td>\downarrow</td><td>$\downarrow$</td><td>\updownarrow</td><td>$\updownarrow$</td></tr><tr><td>\Uparrow</td><td>$\Uparrow$</td><td>\Downarrow</td><td>$\Downarrow$</td><td>\Updownarrow</td><td>$\Updownarrow$</td></tr><tr><td>\to</td><td>$\to$</td><td>\swarrow</td><td>$\swarrow$</td><td>\nearrow</td><td>$\nearrow$</td></tr><tr><td>\gets</td><td>$\gets$</td><td>\searrow</td><td>$\searrow$</td><td>\nwarrow</td><td>$\nwarrow$</td></tr><tr><td>\mapsto</td><td>$\mapsto$</td><td>\rightrightarrows</td><td>$\rightrightarrows$</td><td></td><td></td></tr></tbody></table><h4 id="⑩空格"><a href="#⑩空格" class="headerlink" title="⑩空格"></a>⑩空格</h4><table><thead><tr><th>输入</th><th>效果</th><th>输入</th><th>效果</th><th>输入</th><th>效果</th></tr></thead><tbody><tr><td>\!</td><td>$</td><td>!</td><td>$</td><td>默认</td><td>$</td></tr><tr><td>,</td><td>$</td><td>,</td><td>$</td><td>;(\ )</td><td>$</td></tr></tbody></table><h3 id="13、字体"><a href="#13、字体" class="headerlink" title="13、字体"></a>13、字体</h3><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$&#123;\字体&#123;需要转换的字符&#125;&#125;$</span><br></pre></td></tr></table></figure></blockquote><table><thead><tr><th>输入</th><th>说明</th><th>显示</th><th>输入</th><th>说明</th><th>显示</th></tr></thead><tbody><tr><td>\rm</td><td>罗马体</td><td>${\rm{Sample}}$</td><td>\cal</td><td>花体</td><td>${\cal{Sample}}$</td></tr><tr><td>\it</td><td>意大利体</td><td>${\it{Sample}}$</td><td>\Bbb</td><td>黑板粗体</td><td>${\Bbb{Sample}}$</td></tr><tr><td>\bf</td><td>粗体</td><td>${\bf{Sample}}$</td><td>\mit</td><td>数学斜体</td><td>${\mit{Sample}}$</td></tr><tr><td>\sf</td><td>等线体</td><td>${\sf{Sample}}$</td><td>\scr</td><td>手写体</td><td>${\scr{Sample}}$</td></tr><tr><td>\tt</td><td>打字机体</td><td>${\tt{Sample}}$</td><td>\frak</td><td>旧德式字体</td><td>${\frak{Sample}}$</td></tr></tbody></table><h3 id="14、大括号和行标"><a href="#14、大括号和行标" class="headerlink" title="14、大括号和行标"></a>14、大括号和行标</h3><blockquote><p>说明:  使用<code>\left</code>和<code>\right</code>来创建自动匹配高度的<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>、<code>.</code>。在每个公式末尾使用<code>\tag&#123;行标&#125;</code>来实现行标。</p></blockquote><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$$</span><br><span class="line">&gt;f\left(</span><br><span class="line">&gt;\left[</span><br><span class="line">&gt;\dfrac&#123;1+\&#123;x,y\&#125;&#125;&#123;\left(\dfrac&#123;x&#125;&#123;y&#125;+\dfrac&#123;y&#125;&#123;x&#125;\right)(u+1)&#125;+a</span><br><span class="line">&gt;\right]</span><br><span class="line">&gt;^&#123;\dfrac&#123;3&#125;&#123;2&#125;&#125;</span><br><span class="line">&gt;\right)</span><br><span class="line">&gt;\tag&#123;行标&#125;</span><br><span class="line">&gt;$$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$$<br>f\left(\left[\dfrac{1+{x,y}}{\left(\dfrac{x}{y}+\dfrac{y}{x}\right)(u+1)}+a\right]^{\dfrac{3}{2}}\right)\tag{行标}<br>$$</p></blockquote><blockquote><p>说明:如果你想将行内显示的分隔符也变大,也可以使用<code>\middle</code>命令</p></blockquote><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$$</span><br><span class="line">&gt;\left\langle q\middle\|\dfrac&#123;\dfrac&#123;x&#125;&#123;y&#125;&#125;&#123;\dfrac&#123;u&#125;&#123;v&#125;&#125;\middle|p\right\rangle</span><br><span class="line">&gt;$$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$$<br>\left\langle q\middle|\dfrac{\dfrac{x}{y}}{\dfrac{u}{v}}\middle|p\right\rangle<br>$$</p></blockquote><h3 id="15、其他命令"><a href="#15、其他命令" class="headerlink" title="15、其他命令"></a>15、其他命令</h3><h4 id="①注释文字"><a href="#①注释文字" class="headerlink" title="①注释文字"></a>①注释文字</h4><blockquote><p>代码:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\text&#123;文字&#125;$</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>效果:<br>$$<br>f(n)&#x3D;\begin{cases}n&#x2F;2,&amp;\text{if $n$ is even}\3n+1,&amp;\text{if $n$ is odd}\end{cases}<br>$$</p></blockquote><h4 id="③文字颜色"><a href="#③文字颜色" class="headerlink" title="③文字颜色"></a>③文字颜色</h4><blockquote><ul><li>适用新旧浏览器<br> 代码:</li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\color&#123;颜色&#125;&#123;文字&#125;$</span><br></pre></td></tr></table></figure></blockquote><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td>black</td><td>$\color{black}{color}$</td><td>grey</td><td>$\color{grey}{color}$</td><td>silver</td><td>$\color{silver}{color}$</td></tr><tr><td>white</td><td>$\color{white}{color}$</td><td>maroon</td><td>$\color{maroon}{color}$</td><td>red</td><td>$\color{red}{color}$</td></tr><tr><td>yellow</td><td>$\color{yellow}{color}$</td><td>lime</td><td>$\color{lime}{color}$</td><td>olive</td><td>$\color{olive}{color}$</td></tr><tr><td>green</td><td>$\color{green}{color}$</td><td>teal</td><td>$\color{teal}{color}$</td><td>auqa</td><td>$\color{auqa}{color}$</td></tr><tr><td>blue</td><td>$\color{blue}{color}$</td><td>navy</td><td>$\color{navy}{color}$</td><td>purple</td><td>$\color{purple}{color}$</td></tr><tr><td>fuchsia</td><td>$\color{fuchsia}{color}$</td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><ul><li>适用新版浏览器<br> 代码:</li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;$\color&#123;#rgb&#125;&#123;文字&#125;$    (注:其中r、g、b可以输入0~9和a~f来分别表示红色、绿色和蓝色的纯度)</span><br></pre></td></tr></table></figure></blockquote><table><thead><tr><th>输入</th><th>输出</th><th>输入</th><th>输出</th><th>输入</th><th>输出</th><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>#000</td><td>$\color</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107/"/>
      <url>/posts/16107/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发癫日常（1）（Blog测试√）</title>
      <link href="/posts/38068/"/>
      <url>/posts/38068/</url>
      
        <content type="html"><![CDATA[<h1 id="其实我只是想测试一下Blog喵"><a href="#其实我只是想测试一下Blog喵" class="headerlink" title="其实我只是想测试一下Blog喵~"></a>其实我只是想测试一下Blog喵~</h1><hr><h2 id="和泉老师-😍😍😍"><a href="#和泉老师-😍😍😍" class="headerlink" title="和泉老师~~~😍😍😍"></a>和泉老师~~~😍😍😍</h2><p><strong>2023.9.10</strong></p><p>今天是教师节，转我一百块，我将对和泉老师狠狠发癫🥵🥵🥵</p><p>和泉老师手把手帮你脱单，不脱单和泉老师退你八十，当然你也可以直接给我转20，因为对于你，我也没有十成的把握。</p><p>看见和泉老师哪有不疯的，硬撑罢了🥰🥰🥰🥰</p><img src="https://picdm.sunbangyan.cn/2023/11/07/7299c9d2d8507783f09e99326f427889.webp" title="和泉老师" style="zoom:40%"/><h2 id="和泉老师"><a href="#和泉老师" class="headerlink" title="和泉老师~~~~"></a>和泉老师~~~~</h2><p>🥰🤩😍😋🥵😈</p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 发癫日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog参考网站</title>
      <link href="/posts/7133/"/>
      <url>/posts/7133/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><strong>空_无</strong></p><p><strong>Front-matter</strong> 常用模板。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">date:</span> </span><br><span class="line"><span class="attr">tags:</span>           <span class="comment"># []</span></span><br><span class="line"><span class="attr">categories:</span>     <span class="comment"># 汉字</span></span><br><span class="line"><span class="attr">cover:</span>          <span class="comment"># 直链</span></span><br><span class="line"><span class="attr">sticky:</span>         <span class="comment"># 数值越大，置顶的优先级越大</span></span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="number">0</span><span class="string">.</span> <span class="string">帖子模板</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-11-26 18:16:30</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">blog</span>, <span class="string">hexo</span>]</span><br><span class="line"><span class="attr">categories:</span> <span class="string">参考教程</span></span><br><span class="line"><span class="attr">sticky:</span> <span class="number">11</span>      </span><br><span class="line"><span class="attr">cover:</span> <span class="string">https://picdm.sunbangyan.cn/2023/11/26/57686fecffe37727fba38e311aaf330d.jpeg</span></span><br></pre></td></tr></table></figure><hr><h1 id="感叹"><a href="#感叹" class="headerlink" title="感叹"></a>感叹</h1><p>互联网教程一点都不适合小白，唉。</p><h1 id="Blog参考"><a href="#Blog参考" class="headerlink" title="Blog参考"></a>Blog参考</h1><h2 id="搭建参考网站"><a href="#搭建参考网站" class="headerlink" title="搭建参考网站"></a>搭建参考网站</h2><p><a href="https://hscyber.github.io/posts/1fb16b0c/">基于Hexo与Github搭建静态个人博客网站 Huangs’s Notes</a></p><h2 id="主题配置：安知鱼"><a href="#主题配置：安知鱼" class="headerlink" title="主题配置：安知鱼"></a>主题配置：安知鱼</h2><p><a href="https://docs.anheyu.com/">安知鱼主题官方文档 | 一个简洁、美丽的静态hexo主题</a></p><hr><h1 id="后续功能"><a href="#后续功能" class="headerlink" title="后续功能"></a>后续功能</h1><h2 id="撰写及发布"><a href="#撰写及发布" class="headerlink" title="撰写及发布"></a>撰写及发布</h2><p><strong>Tip:：一定要先把本地化搞好！</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;mypost&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>创建一个新的md文件，并在&#x2F;source&#x2F;_posts&#x2F;路径下找到对应的,md文件撰写自己的笔记了，撰写完成后，在命令行执行生成并发布，即完成了上传。但是通常延迟才能看到效果，也可以直接使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>并打开本地站点预览结果并调试，默认 <a href="http://localhost:4000/">http://localhost:4000/</a></p><p>成功会出现以下提示：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">INFO  Have a <span class="built_in">nice</span> day</span><br></pre></td></tr></table></figure><p>关闭预览使用以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl c</span><br></pre></td></tr></table></figure><p>改主题用这两个命令:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><h2 id="hexo-魔改教程（1）-图床"><a href="#hexo-魔改教程（1）-图床" class="headerlink" title="hexo 魔改教程（1）| 图床"></a>hexo 魔改教程（1）| 图床</h2><p><a href="https://pics.sunbangyan.cn/">SunPics - 基于EasyImage的开源免费图床</a></p><h2 id="hexo-魔改教程（2）-评论"><a href="#hexo-魔改教程（2）-评论" class="headerlink" title="hexo 魔改教程（2）| 评论"></a>hexo 魔改教程（2）| 评论</h2><p><a href="https://docs.anheyu.com/advanced/#%E8%AF%84%E8%AE%BA">进阶配置 | 安知鱼主题官方文档</a><br><a href="https://twikoo.js.org/frontend.html">前端部署 | Twikoo 文档</a><br><a href="https://waline.js.org/guide/get-started/#vercel-%E9%83%A8%E7%BD%B2-%E6%9C%8D%E5%8A%A1%E7%AB%AF">快速上手 | Waline</a><br><a href="https://waline.js.org/guide/deploy/vercel.html#%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2">Vercel 部署 | Waline</a><br><a href="https://vercel.com/akari2333s-projects">Dashboard – Vercel</a><br><a href="https://valine.js.org/">Valine 一款快速、简洁且高效的无后端评论系统。</a></p><h2 id="hexo魔改教程（3）-加密插件"><a href="#hexo魔改教程（3）-加密插件" class="headerlink" title="hexo魔改教程（3）| 加密插件"></a>hexo魔改教程（3）| 加密插件</h2><p>开源地址：<a href="https://github.com/D0n9X1n/hexo-blog-encrypt">D0n9X1n&#x2F;hexo-blog-encrypt: Yet, just another hexo plugin for security.</a><br>参考blog：<a href="https://www.fomal.cc/posts/2d7ac914.html">博客魔改教程总结(三) | Fomalhaut🥝</a></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">作为日记加密</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2016-03-30 21:12:21</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">XXXXX</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">请输入密码查看.</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">这里需要密码.</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">blink</span> <span class="comment"># default / blink / shrink / flip / up / surge / wave / xray</span></span><br><span class="line"><span class="attr">wrong_pass_message:</span> <span class="string">密码错误</span></span><br><span class="line"><span class="attr">wrong_hash_message:</span> <span class="string">此文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br></pre></td></tr></table></figure><h2 id="hexo-魔改教程（4）-优化文章永久链接为数字编号"><a href="#hexo-魔改教程（4）-优化文章永久链接为数字编号" class="headerlink" title="hexo 魔改教程（4）| 优化文章永久链接为数字编号"></a>hexo 魔改教程（4）| 优化文章永久链接为数字编号</h2><p>参考：<a href="https://cloud.tencent.com/developer/article/1662763">Hexo博客进阶教程（一）| 优化文章永久链接为数字编号</a></p><hr><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><h2 id="Error-Spawn-failed"><a href="#Error-Spawn-failed" class="headerlink" title="Error: Spawn failed"></a>Error: Spawn failed</h2><p><a href="http://dinghaoblog.cn/2021/09/10/%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99%E6%97%B6%E5%87%BA%E7%8E%B0Error-Spawn-failed/">hexo d部署网站时出现错误Error: Spawn failed(生成失败) | DinGHao’s BLOG</a></p><p>这个错误的大致意思是不能够进入远端部署的网址，同时生成失败。以下解决方法只适用于已正确配置SSH的情况下。<br>解决方法:<br> <strong>1.更换网络，用稳定的网络，避免因网络不流畅而导致部署超时。</strong><br> <strong>2.如果未关闭用hexo s命令打开的本地网页，到浏览器中关闭刚刚打开的网页。</strong><br> <strong>3.重新使用三件套hexo clean，hexo g，hexo d。</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>其中<code>hexo g</code>和<code>hexo d</code>指令可以直接使用<code>hexo g -d</code>这一条指令代替，效果是一样的。<br>如果对hexo的指令不熟悉可以查看Hexo官方文档。<br>最后完成部署的结果如下:<code>INFO Deploy done: git</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 参考教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空无</title>
      <link href="/posts/26849/"/>
      <url>/posts/26849/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 空_无 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空_无 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
