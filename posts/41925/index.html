<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>队列——之二 | Akari的小站</title><meta name="keywords" content="数据结构与算法"><meta name="author" content="Akari"><meta name="copyright" content="Akari"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="队列——之二"><meta name="application-name" content="队列——之二"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="队列——之二"><meta property="og:url" content="http://example.com/posts/41925/index.html"><meta property="og:site_name" content="Akari的小站"><meta property="og:description" content="[toc] 参考：   （CSDN）浙大版数据结构（四）队列 （GitHub）CSPostgraduate-408-王道 （CSDN）王道数据结构学习笔记 （iloveflag’s blog）数据结构-王道考研复习笔记   前情提要：   队列（循环队列）—— 线性结构的应用之一 | Akari的小"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://picss.sunbangyan.cn/2024/01/05/bdd191fc11d3ab4fe207cbcba732b3ee.jpeg"><meta property="article:author" content="Akari"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picss.sunbangyan.cn/2024/01/05/bdd191fc11d3ab4fe207cbcba732b3ee.jpeg"><meta name="description" content="[toc] 参考：   （CSDN）浙大版数据结构（四）队列 （GitHub）CSPostgraduate-408-王道 （CSDN）王道数据结构学习笔记 （iloveflag’s blog）数据结构-王道考研复习笔记   前情提要：   队列（循环队列）—— 线性结构的应用之一 | Akari的小"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/posts/41925/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://waline-blog-hxla8mye0-akari2333s-projects.vercel.app/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Akari","link":"链接: ","source":"来源: Akari的小站","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Akari的小站',
  title: '队列——之二',
  postAI: '',
  pageFillDescription: '1. 定义, 2. 分类, 3. 应用, 4. 学习循环队列需弄清楚的 7 个问题, 5. 代码示例, 5.1 静态队列（循环队列）, 5.1.1 C——郝斌老师, 5.1.2 C——浙大数据结构, 5.1.3 C++——王道, 5.1.3.1 C++ 引用, 5.2 链式队列, 5.2.0 头结点有无与否, 5.2.1 C++——郝斌老师, 5.2.1.1 Clear(), 5.2.1.2 ~Queue(), 5.2.2 C——浙大数据结构, 5.2.3 C++——王道参考浙大版数据结构四队列王道王道数据结构学习笔记数据结构王道考研复习笔记前情提要队列循环队列线性结构的应用之一的小站队列链式队列线性结构的应用之一的小站定义队列具有一定操作约束的线性表线性结构的两种常见应用之一是一种可以实现先进先出的存储结构类似于人排队买票插入和删除操作只能在一端插入而在另一端删除数据插入入队列数据删除出队列先进先出分类静态队列用数组实现静态队列通常都必须是循环队列链式队列用链表实现比较简单应用所有和时间有关的事件都有队列的影子学习循环队列需弄清楚的个问题静态队列通常都必须是循环队列为了减少内存浪费循环队列的讲解静态队列为什么必须是循环队列循环队列需要几个参数来确定循环队列各个参数的含义循环队列入队伪算法讲解循环队列出队伪算法讲解如何判断循环队列是否为空如何判断循环队列是否已满静态队列为什么必须是循环队列如图现在如果一个数组里面存了四个元素一开始队头就指向第一个有效元素而队尾指向最后一个元素的下一个元素如果进行出队操作先进先出则从队头开始先出假如出队到数组下标为的元素位置此位置变成了队头那么数组下标为的元素内存被释放出队后的数组元素内存无法重新入队因为入队是从队尾开始不能从队头之前进行入队而且数组中入队操作达到数组最大下标后就无法入队操作同理出队到数组最大下标也无法出队操作数组卡死所以对静态队列必须使用循环队列来提高数组的利用率如果要删除元素出队只能加往数组最大下标方向增加如果要增加元素入队只能加往数组最大下标方向增加按照一般数组的方法指向当前队列的下一个位置队尾类似于链表创建尾插法和链表遍历算法的演示中此函数中的指向尾节点也就是说当增加元素时只能在一端增加即向上移删除元素时只能在一端删除元素即向上移但是如果一直增增删删那么就会造成端溢出而端浪费所以对于这种情况可以采用循环队列的形式即当已经指向数组最后一个元素时那么就可以转而将指向数组的第一个空出来的空间循环队列需要几个参数来确定需要个参数来确定和循环队列各个参数的含义个参数在不同场合有不同的含义队列初始化和的值相等均为队列非空代表的是队列的第一个元素代表的是队列的最后一个有效元素的下一个元素队列空和的值相等但不一定为循环队列入队伪算法讲解准备工作入队前要先判断的位置因为有可能正指向数组最后一个元素所以就越界了如何知道是否快越界了后对整个数组长度求余数余数为则处于最后一个数组元素位置即将越界两步完成将值存入所代表的位置错误的写法正确的写法是数组的长度循环队列出队伪算法讲解同入队的伪算法一样数组的长度如何判断循环队列是否为空即如果与的值相等则该队列就一定为空如何判断循环队列是否已满已知上图中的值和的值没有规律即可以大小等刚开始一定为空那么之后经过一个循环后又了但此时为满即不能通过这个条件来判断其既是空又是满所以必须通过和的其他关系来判断其为满所以有两种方式多增加一个标识是否满的参数但每次对队列进行操作这个标志参数都要更新浪费系统资源少用一个元素通常用此种方式如果和的值相差且则证明队列已满用语言伪算法表示为数组长度已满未满代码示例静态队列循环队列关于的内存分配方式有种不过没什么区别感觉长度为个元素的数组静态分配不使用动态内存分配郝斌老师队列最大长度队头下标队尾下标初始化入队出队是否已满是否为空遍历出队成功出队的元素是静态分配不使用动态内存分配长度为个元素的数组动态内存分配失败队头下标为队尾下标为从队尾开始数据入队队尾加从开始出队获取新的队头队列满时紧挨着由于是循环所以对数组长度取余且是最后一个有效元素的下一个元素指向的元素是空起来不使用的空一元素判断队满获取队头从队头开始出队是否出队到队尾通过空一个元素不使用判断是否到队尾后对数组长度取余浙大数据结构浙大版数据结构四队列函数是语言中的一个函数用于将格式化的数据写入到文件流中具体来说的函数原型是一个指向文件流的指针表示数据将被写入到哪个文件流中在上述代码中使用的是它代表标准错误流是一个字符串包含了格式化输出的控制字符和要输出的数据表示可变数量的参数即要写入的数据示例使用了来将字符串内存分配失败写入到标准错误流中这是一种报告错误的方式通常用于指示程序在运行时遇到了问题内存分配失败内存分配失败使用函数将错误消息写入标准错误流是一个专门用于输出错误信息的流与标准输出区分开来在这里用于将错误消息输出到屏幕上函数用于终止程序的执行是一个宏表示程序以失败的状态退出这是一个标准的返回代码用于表示程序没有成功执行队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量以及一个记录队列尾元素位置的变量组成其中指向整个队列的头一个元素的再前一个指向的是整个队列的最后一个元素从入队从出队且仅使用个数组空间假定是类型记录队头记录队尾初始化队列入队判断队列是否已满出队判断队列是否为空入队入队入队出队出队初始化内存分配失败判断队列是否已满入队队列已满判断队列是否为空出队队列为空王道数据结构学习笔记王道数据结构王道考研复习笔记引用主要区别是使用了的引用而不是传递指针引用是中的特性允许在函数中修改传递的参数而无需显式地使用指针定义在中引用是一个别名它提供了对变量的另一个名称引用在中是通过使用符号进行声明和定义的引用必须在初始化时被绑定到一个对象而且一旦绑定它将一直引用该对象基本语法其中是原始变量的类型是引用的名称是原始变量引用的声明和初始化必须同时进行示例修改引用也会修改原始变量其中是的引用它们实际上指向同一个内存地址因此对的修改也会影响到引用有一些重要的特性和规则引用必须在声明时初始化而且一旦初始化就无法改变引用的目标引用不占用额外的内存空间它只是目标变量的另一个名字引用通常用于函数参数允许在函数中直接操作原始变量而不是其副本引用用于提供对对象的更直观更自然的访问引用在中广泛用于函数传递返回引用值操作符重载等场景引用和指针的异同引用和指针是中两种用于引用和操作变量的机制它们有相似之处也有一些重要的区别以下是引用和指针的异同点相同点别名机制引用和指针都提供了对变量的别名机制可以通过它们来访问和操作变量用于传递参数引用和指针都可以用于函数参数使得函数能够直接操作原始变量而不是对变量的副本进行操作用于修改变量值通过引用或指针可以修改原始变量的值而不仅仅是传递它们的副本不同点语法和操作引用引用在声明时使用符号例如引用一旦初始化就不能再引用其他变量一直引用同一个对象引用不需要使用解引用操作符来访问目标对象引用不能为引用必须在初始化时指向一个有效的对象指针指针在声明时使用符号例如指针可以在任何时候重新指向其他对象使用解引用操作符来访问目标对象指针可以为即指向空地址表示不指向任何有效的对象内存占用引用引用在内存中不占用额外的空间它只是目标变量的别名指针指针需要占用额外的内存空间来存储变量的地址空引用和空指针引用引用在定义时必须初始化不存在空引用的概念指针指针可以为表示不指向任何有效的对象称为空指针操作符重载引用不支持操作符重载指针支持操作符重载可以通过指针实现一些底层的操作适用场景引用适用于不需要改变指向的情况提供了更直观的语法指针适用于需要在运行时改变指向的情况更灵活访问对象成员引用引用使用点运算符访问对象的成员因为引用本质上是一个别名就是绑定到某个对象上的别名它可以像对象本身一样访问成员指针当有一个指向结构体或类的指针时使用箭头运算符来访问对象的成员在选择使用引用还是指针时取决于具体的场景和需求通常情况下引用更适用于作为函数参数传递而指针更适用于需要动态分配内存在运行时改变指向等场景定义模块用静态数组存放队列元素队头指针和队尾指针函数声明初始化判空判满入队出队用返回获取队头元素用返回定义模块测试模块测试模块实现模块初始化队列初始化时队头队尾都指向判断队列是否为空判断队列是否为满牺牲一个单元区分队空和队满入队如果队列已满直接返回通过取余操作让整个队列循环起来出队如果队列为空直接返回实现模块测试模块打印整个队列开始打印队列输出后更新下标结束打印测试开始测试入队成功入队失败入队成功入队失败入队成功入队失败出队成功弹出的元素是出队失败获取队头成功队头元素是获取队头失败队空队非空结束测试测试模块链式队列头结点有无与否在链式队列中是否使用头结点主要影响链表的头指针和尾指针的处理方式带头结点的链式队列头结点存在链表中会额外添加一个头结点头结点的指针指向队列的头元素而尾指针指向队列的尾元素这样头结点的存在使得链表中的每个节点都有一个前驱节点操作方便在插入和删除操作时无需特殊处理头节点的情况简化了代码逻辑判空方便判断队列是否为空可以通过检查头结点的指针是否为空来实现不带头结点的链式队列头结点不存在链表的头指针直接指向队列的头元素而尾指针指向队列的尾元素链表中的第一个节点即为队列的头元素操作需特殊处理在插入和删除操作时需要特殊处理头节点的情况因为头节点和其他节点的处理方式不同判空需特殊处理判断队列是否为空通常需要检查头指针和尾指针是否相等因为没有头结点来帮助判断选择是否使用头结点主要取决于具体的设计需求和实现偏好带头结点的链表在某些情况下适用于对插入和删除操作的简洁性有较高要求的情况对边界情况的处理上更加方便可以使代码更加简洁而不带头结点的链表适用于对内存占用比较敏感的情况且可以接受插入和删除操作的代码逻辑稍微复杂一些更接近实际队列的逻辑郝斌老师错误写法正确写法不需要使用循环在每次调用之后函数内部已经包含了循环的逻辑只要队列不为空就会一直执行出队操作因此在中只需调用一次即可达到清空队列的目的错误写法正确写法在析构函数中不需要显式调用因为析构函数会在对象销毁时自动调用在中类的析构函数是一个特殊的成员函数它在对象被销毁时自动调用析构函数的作用是释放对象占用的资源执行清理工作在示例代码中析构函数的主要目的是清理队列即释放队列中节点所占用的内存已经定义了函数来完成这个清理工作所以在析构函数中调用是合理的然而根据的析构函数自动调用机制如果析构函数中没有显式调用对象销毁时也会自动调用因为包含了释放队列中节点内存的逻辑所以可以不在析构函数中显式调用而是依赖析构函数自动调用它这样的做法更加简洁因为析构函数的主要职责是清理资源而已经负责了这部分工作带头结点带头结点版本指向无用的头结点才是指向队首元素指向队尾元素构造函数在构造函数中使用初始化列表析构函数在对象被销毁时自动调用遍历队列元素队列为空无法遍历判空简化返回语句入队将挂到队列尾部注意是尾指针上移出队队列为空无法出队不是要删除的队首元素所指向的元素才是要删除的元素保存出队元素更新首节点如果队列为空尾指针要指向无用的头结点则将移回清空队列用引用代替出队成功出队的元素是出队失败浙大数据结构数据结构四队列不带头结点队列的链式存储结构也可以用一个单链表实现插入和删除操作分别在链表的两头进行在链表头在链表尾从入队从出队链式队列不带带头节点版本链表节点队列结构指向队尾结点指向队头结点初始化队列入队出队判空入队入队入队出队出队出队头结点为空时队空不带头节点插入第一个元素时需做特殊处理非第一个元素新节点插入到之后修改尾指针即队列空用指针记录队头用返回队头元素不带头节点最后一个节点出队时需做特殊处理修改指针为空队头指向下一个队头王道数据结构学习笔记王道数据结构王道考研复习笔记带头结点链式队列带头结点版本定义模块链表节点队列结构头指针和尾指针函数声明初始化入队出队获取头元素判空清空定义模块实现模块内存分配失败初始化时都指向头结点判满链式存储一般不需要判满除非内存不足内存分配失败新节点插入到之后更新尾指针指针记录队头元素返回队头元素修改头节点的指针最后一个节点出队时修改指针依次出队释放所有节点内存释放头结点内存实现模块测试模块打印函数开始打印使用临时指针避免改变原视队列的状态打印完成测试函数开始测试入队成功入队失败入队成功入队失败入队成功入队失败出队成功弹出的元素是出队失败获取队头成功队头元素是获取队头元素失败队空队非空清理队列测试结束测试模块',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-09 16:21:29',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://picdl.sunbangyan.cn/2023/11/24/b45e6fde93484c373c0976fab70d6963.jpeg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Akari的小站</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">10</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/408/" itemprop="url">408</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>数据结构与算法</span></a></span></div></div><h1 class="post-title" itemprop="name headline">队列——之二</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-01-04T12:22:50.000Z" title="发表于 2024-01-04 20:22:50">2024-01-04</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-01-09T08:21:29.103Z" title="更新于 2024-01-09 16:21:29">2024-01-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">7.3k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="队列——之二"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为郑州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>郑州</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/41925/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://picss.sunbangyan.cn/2024/01/05/bdd191fc11d3ab4fe207cbcba732b3ee.jpeg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/posts/41925/"><header><a class="post-meta-categories" href="/categories/408/" itemprop="url">408</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" tabindex="-1" itemprop="url">数据结构与算法</a><h1 id="CrawlerTitle" itemprop="name headline">队列——之二</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Akari</span><time itemprop="dateCreated datePublished" datetime="2024-01-04T12:22:50.000Z" title="发表于 2024-01-04 20:22:50">2024-01-04</time><time itemprop="dateCreated datePublished" datetime="2024-01-09T08:21:29.103Z" title="更新于 2024-01-09 16:21:29">2024-01-09</time></header><p>[toc]</p>
<p>参考：</p>
<blockquote>
<ul>
<li><em><a target="_blank" rel="noopener" href="https://blog.csdn.net/liyuanyue2017/article/details/83688306">（CSDN）浙大版数据结构（四）队列</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/CodePanda66/CSPostgraduate-408/tree/master">（GitHub）CSPostgraduate-408-王道</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_55593227/article/details/123598044">（CSDN）王道数据结构学习笔记</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://www.iloveflag.com/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0">（iloveflag’s blog）数据结构-王道考研复习笔记</a></em></li>
</ul>
</blockquote>
<p>前情提要：</p>
<blockquote>
<ul>
<li><em><a target="_blank" rel="noopener" href="https://akari2333.github.io/posts/13537/">队列（循环队列）—— 线性结构的应用之一 | Akari的小站</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://akari2333.github.io/posts/7017/">队列（链式队列）—— 线性结构的应用之一 | Akari的小站</a></em></li>
</ul>
</blockquote>
<hr>
<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><p><strong>队列（Queue）</strong>：具有一定操作约束的线性表，线性结构的两种常见应用之一，是一种可以实现”先进先出”的存储结构，类似于人排队买票。</p>
<blockquote>
<ul>
<li>插入和删除操作：只能在一端（front）插入，而在另一端（rear）删除</li>
<li>数据插入：入队列（AddQ）</li>
<li>数据删除：出队列（DeleteQ）</li>
<li>先进先出：FIFO</li>
</ul>
</blockquote>
<h1 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h1><blockquote>
<ol>
<li>静态队列：用数组实现 <strong>静态队列通常都必须是循环队列</strong></li>
<li>链式队列：用链表实现 （比较简单）</li>
</ol>
</blockquote>
<h1 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h1><p>所有和时间有关的事件都有队列的影子。</p>
<h1 id="4-学习循环队列需弄清楚的-7-个问题"><a href="#4-学习循环队列需弄清楚的-7-个问题" class="headerlink" title="4. 学习循环队列需弄清楚的 7 个问题"></a>4. 学习<code>循环队列</code>需弄清楚的 7 个问题</h1><p>静态队列通常都必须是循环队列，为了减少内存浪费。<br>循环队列的讲解：</p>
<blockquote>
<ol>
<li>静态队列为什么必须是循环队列</li>
<li>循环队列需要几个参数来确定</li>
<li>循环队列各个参数的含义</li>
<li>循环队列入队伪算法讲解</li>
<li>循环队列出队伪算法讲解</li>
<li>如何判断循环队列是否为空</li>
<li>如何判断循环队列是否已满</li>
</ol>
</blockquote>
<ol>
<li><p>静态队列为什么必须是循环队列：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picst.sunbangyan.cn/2024/01/04/d89740afd2d59b0381bfa4fd7d3cc70e.jpeg" alt="1" />

<p> 如图，现在如果一个数组里面存了四个元素，一开始 <strong>队头 front</strong> 就指向第一个有效元素，而 <strong>队尾 real</strong> 指向最后一个元素的下一个元素。</p>
<blockquote>
<ul>
<li><p>如果进行出队操作，先进先出，则从队头 front 开始先出，假如出队到数组下标为 2 的元素位置，此位置变成了队头 front，那么数组下标为 0&#x2F;1 的元素内存被释放。<strong>出队后的数组元素内存无法重新入队，因为入队是从队尾 rear 开始，不能从队头 front 之前进行入队，而且数组中入队操作达到数组最大下标后，就无法入队操作。同理出队到数组最大下标，也无法出队操作，数组卡死，所以对静态队列必须使用循环队列来提高数组的利用率。</strong></p>
</li>
<li><p>如果要删除元素（出队），front 只能加(往数组最大下标方向增加)；如果要增加元素（入队），rear 只能加(往数组最大下标方向增加)。（按照一般数组的方法）。rear 指向当前队列的下一个位置。 队尾 rear 类似于<code>链表创建(尾插法)和链表遍历算法的演示</code> 中 <code>PNODE create_list(void)</code>此函数中的PNODE pTail 指向尾节点</p>
</li>
</ul>
</blockquote>
<p> 也就是说：</p>
<blockquote>
<ul>
<li><p>当<strong>增加元素</strong>时，只能在 rear 一端增加，即 rear 向上移。<strong>删除元素</strong>时，只能在 front 一端删除元素，即 front 向上移。</p>
</li>
<li><p>但是如果一直增增删删，那么就会造成 rear 端溢出，而 front 端浪费，所以对于这种情况，可以采用循环队列的形式，即当 rear 已经指向数组最后一个元素时，那么就可以转而将 rear 指向数组的第一个空出来的空间。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>循环队列需要几个参数来确定<br> 需要 2 个参数来确定：front 和 rear</p>
</li>
<li><p>循环队列各个参数的含义：<br> 2 个参数在不同场合有不同的含义</p>
<blockquote>
<ol>
<li>队列初始化<br> front 和 rear 的值相等，均为 0</li>
<li>队列非空<br> front 代表的是队列的第一个元素<br> rear 代表的是队列的最后一个有效元素的下一个元素</li>
<li>队列空<br> front 和 rear 的值相等，但不一定为 0</li>
</ol>
</blockquote>
</li>
<li><p>循环队列入队伪算法讲解：<br> 准备工作：</p>
<blockquote>
<ol>
<li>入队前要先判断 rear 的位置，因为 rear 有可能正指向数组最后一个元素，所以 rear + 1 就越界了。</li>
<li>如何知道 rear 是否快越界了：rear + 1 后对整个数组长度求余数(%)，余数为 0，则 rear + 1 处于最后一个数组元素位置，即将越界。</li>
</ol>
</blockquote>
<p> 两步完成：</p>
<blockquote>
<ol>
<li>将值存入rear 所代表的位置</li>
<li>错误的写法：rear &#x3D; rear + 1;<br>正确的写法是：<strong>rear &#x3D; (rear+1) % 数组的长度</strong></li>
</ol>
</blockquote>
</li>
<li><p>循环队列出队伪算法讲解：<br> 同入队的伪算法一样：<br> <strong>front &#x3D;（front + 1）% 数组的长度</strong></p>
</li>
<li><p>如何判断循环队列是否为空：<br> <strong>front &#x3D;&#x3D; rear。</strong><br> 即如果 front 与 rear 的值相等，则该队列就一定为空。</p>
</li>
<li><p>如何判断循环队列是否已满：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picdl.sunbangyan.cn/2024/01/05/6ed436deed351af3430f4f41eeff760f.jpeg" alt="6" style="zoom:100%"/>

<p> 已知：上图中 front 的值和 rear 的值没有规律，即可以大(3&gt;1)，小(0&lt;4)，等(f&#x3D;r)。<br> 刚开始 f&#x3D;r 一定为空，那么之后经过一个循环后又 r&#x3D;f 了，但此时 r&#x3D;f 为满，即不能通过 r&#x3D;f 这个条件来判断其既是空又是满。所以必须通过 f和r 的其他关系来判断其为满。</p>
<p> 所以有两种方式:</p>
<blockquote>
<ol>
<li>多增加一个标识是否满的参数(但每次对队列进行操作这个标志参数都要更新，浪费系统资源)</li>
<li>少用一个元素 <strong>【通常用此种方式】</strong><br>  如果 front和rear 的值相差 1，且 front&gt;rear，则证明队列已满。</li>
</ol>
</blockquote>
<p> 用 C 语言伪算法表示为：</p>
<blockquote>
<p><strong>if ((rear+1)%数组长度&#x3D;&#x3D;front)<br> &emsp;&emsp;已满<br> else<br> &emsp;&emsp;未满</strong></p>
</blockquote>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picss.sunbangyan.cn/2024/01/05/6f98de33bb4fce96496da94fd59937b3.jpeg" alt="7" style="zoom:100%"/></li>
</ol>
<h1 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. 代码示例</h1><h2 id="5-1-静态队列（循环队列）"><a href="#5-1-静态队列（循环队列）" class="headerlink" title="5.1 静态队列（循环队列）"></a>5.1 静态队列（循环队列）</h2><p>关于 <code>Init(QUEUE* pQ)</code> 的内存分配方式：有 2 种(不过没什么区别感觉)</p>
<ol>
<li><p>malloc</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pQ-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* MaxSize);   <span class="comment">// 长度为 MaxSize 个元素的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>static</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态分配，不使用动态内存分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticArray[MaxSize];</span><br><span class="line">pQ-&gt;pBase = staticArray;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-1-1-C——郝斌老师"><a href="#5-1-1-C——郝斌老师" class="headerlink" title="5.1.1 C——郝斌老师"></a>5.1.1 C——郝斌老师</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-05 17:15:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 20  <span class="comment">// 队列最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    <span class="type">int</span>* pBase;</span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队头下标</span></span><br><span class="line">    <span class="type">int</span> rear;   <span class="comment">// 队尾下标</span></span><br><span class="line">&#125;QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(QUEUE* pQ)</span>;   <span class="comment">// 初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Enter</span><span class="params">(QUEUE* pQ, <span class="type">int</span> val)</span>; <span class="comment">// 入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Out</span><span class="params">(QUEUE* pQ, <span class="type">int</span>* pVal)</span>; <span class="comment">// 出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Full</span><span class="params">(QUEUE* pQ)</span>;    <span class="comment">// 是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Empty</span><span class="params">(QUEUE* pQ)</span>;   <span class="comment">// 是否为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(QUEUE* pQ)</span>;   <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    Init(&amp;Q);</span><br><span class="line">    Enter(&amp;Q, <span class="number">1</span>);</span><br><span class="line">    Enter(&amp;Q, <span class="number">2</span>);</span><br><span class="line">    Enter(&amp;Q, <span class="number">3</span>);</span><br><span class="line">    Enter(&amp;Q, <span class="number">4</span>);</span><br><span class="line">    Enter(&amp;Q, <span class="number">5</span>);</span><br><span class="line">    Traverse(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pVal;</span><br><span class="line">    <span class="keyword">if</span> ( Out(&amp;Q, &amp;pVal) )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队成功！\n出队的元素是：%d\n&quot;</span>, pVal);</span><br><span class="line">    Traverse(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(QUEUE* pQ)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 静态分配，不使用动态内存分配</span></span><br><span class="line"><span class="comment">       static int staticArray[MaxSize];</span></span><br><span class="line"><span class="comment">       pQ-&gt;pBase = staticArray;*/</span></span><br><span class="line">    pQ-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * MaxSize);   <span class="comment">// 长度为 MaxSize 个元素的数组</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == pQ-&gt;pBase )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pQ-&gt;front = <span class="number">0</span>;  <span class="comment">// 队头下标为 0</span></span><br><span class="line">        pQ-&gt;rear = <span class="number">0</span>;   <span class="comment">// 队尾下标为 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Enter</span><span class="params">(QUEUE* pQ, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Is_Full(pQ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pQ-&gt;pBase[pQ-&gt;rear] = val;  <span class="comment">// 从队尾开始，数据入队</span></span><br><span class="line">        pQ-&gt;rear = (pQ-&gt;rear + <span class="number">1</span>) % MaxSize;    <span class="comment">// 队尾 rear 加 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Out</span><span class="params">(QUEUE* pQ, <span class="type">int</span>* pVal)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Is_Empty(pQ) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *pVal = pQ-&gt;pBase[pQ-&gt;front];   <span class="comment">// 从 front 开始出队</span></span><br><span class="line">        pQ-&gt;front = (pQ-&gt;front + <span class="number">1</span>) % MaxSize;  <span class="comment">// 获取新的队头</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  队列满时 rear/front 紧挨着，由于是循环所以对数组长度取余，</span></span><br><span class="line"><span class="comment">  且 rear 是最后一个有效元素的下一个元素，</span></span><br><span class="line"><span class="comment">  rear 指向的元素是空起来不使用的，空一元素判断队满。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Full</span><span class="params">(QUEUE* pQ)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (pQ-&gt;rear + <span class="number">1</span>) % MaxSize == pQ-&gt;front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Is_Empty</span><span class="params">(QUEUE* pQ)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (pQ-&gt;front == pQ-&gt;rear) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(QUEUE* pQ)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pQ-&gt;front;          <span class="comment">// 获取队头，从队头开始出队</span></span><br><span class="line">    <span class="keyword">while</span> ( i != pQ-&gt;rear )&#123;    <span class="comment">// 是否出队到队尾</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pQ-&gt;pBase[i]);</span><br><span class="line">        i = (i + <span class="number">1</span>) % MaxSize;  <span class="comment">// 通过空一个元素不使用，判断是否到队尾，front+1 后对数组长度取余</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-C——浙大数据结构"><a href="#5-1-2-C——浙大数据结构" class="headerlink" title="5.1.2 C——浙大数据结构"></a>5.1.2 C——浙大数据结构</h3><blockquote>
<p><em><a target="_blank" rel="noopener" href="https://blog.csdn.net/liyuanyue2017/article/details/83688306">（浙大版）数据结构（四）队列</a></em></p>
</blockquote>
<ul>
<li><p><strong>fprintf 函数</strong><br>  <strong>fprintf</strong> 是 C 语言中的一个函数，用于将格式化的数据写入到文件流中。具体来说，fprintf 的函数原型：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>stream</strong> 是一个指向文件流的指针，表示数据将被写入到哪个文件流中。在上述代码中，使用的是 stderr，它代表标准错误流。</li>
<li><strong>format</strong> 是一个字符串，包含了格式化输出的控制字符和要输出的数据。</li>
<li><strong>…</strong> 表示可变数量的参数，即要写入的数据。</li>
</ul>
</blockquote>
<p>  示例：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用了 fprintf 来将字符串 &quot;内存分配失败&quot; 写入到标准错误流中。</span></span><br><span class="line"><span class="comment">//这是一种报告错误的方式，通常用于指示程序在运行时遇到了问题。     </span></span><br><span class="line">Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == Q )&#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>**fprintf(stderr, “内存分配失败\n”)**：使用 <strong>fprintf</strong> 函数将错误消息写入标准错误流 <strong>(stderr)<strong>。</strong>stderr</strong> 是一个专门用于输出错误信息的流，与标准输出 <strong>(stdout)</strong> 区分开来。在这里，用于将错误消息输出到屏幕上。</p>
</li>
<li><p><strong>exit(EXIT_FAILURE)<strong>：</strong>exit</strong> 函数用于终止程序的执行。<strong>EXIT_FAILURE</strong> 是一个宏，表示程序以失败的状态退出。这是一个标准的返回代码，用于表示程序没有成功执行。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量 front 以及一个记录队列尾元素位置的变量 rear 组成，其中 front 指向整个队列的头一个元素的再前一个，rear 指向的是整个队列的最后一个元素，从 rear 入队，从 front 出队，且仅使用 n-1 个数组空间。</p>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-08 11:39:47</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;    <span class="comment">// 假定是int类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front;   <span class="comment">// 记录队头</span></span><br><span class="line">    <span class="type">int</span> rear;    <span class="comment">// 记录队尾</span></span><br><span class="line">&#125;*Queue;</span><br><span class="line"></span><br><span class="line">Queue <span class="title function_">createQueue</span><span class="params">()</span>;    <span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addQ</span><span class="params">(Queue Q, ElementType e)</span>;  <span class="comment">// 入队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue Q)</span>;    <span class="comment">// 判断队列是否已满</span></span><br><span class="line">ElementType <span class="title function_">deleteQ</span><span class="params">(Queue Q)</span>;       <span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue Q)</span>;   <span class="comment">// 判断队列是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Q = createQueue();</span><br><span class="line">    </span><br><span class="line">    addQ(Q, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1入队\n&quot;</span>);</span><br><span class="line">    addQ(Q, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2入队\n&quot;</span>);</span><br><span class="line">    addQ(Q, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3入队\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d出队\n&quot;</span>, deleteQ(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d出队\n&quot;</span>, deleteQ(Q));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Queue <span class="title function_">createQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == Q )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;front = <span class="number">-1</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否已满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q-&gt;rear + <span class="number">1</span>) % MaxSize == Q-&gt;front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addQ</span><span class="params">(Queue Q, ElementType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( isFull(Q) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;rear] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q-&gt;rear == Q-&gt;front));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">ElementType <span class="title function_">deleteQ</span><span class="params">(Queue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( isEmpty(Q) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">        <span class="keyword">return</span> Q-&gt;Data[Q-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-3-C-——王道"><a href="#5-1-3-C-——王道" class="headerlink" title="5.1.3 C++——王道"></a>5.1.3 C++——王道</h3><blockquote>
<ul>
<li><em><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_55593227/article/details/123598044">数据结构学习笔记（王道）</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://www.iloveflag.com/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0">数据结构-王道考研复习笔记 · iloveflag’s Blog</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/CodePanda66/CSPostgraduate-408/blob/master/DataStructure/Src/DS_2_StackAndQueue/DS_2_3_SqQueue0.cpp">CSPostgraduate-408&#x2F;DataStructure&#x2F;Src&#x2F;DS_2_StackAndQueue&#x2F;DS_2_3_SqQueue0.cpp</a></em></li>
</ul>
</blockquote>
<h4 id="5-1-3-1-C-引用"><a href="#5-1-3-1-C-引用" class="headerlink" title="5.1.3.1 C++ 引用"></a>5.1.3.1 C++ 引用</h4><blockquote>
<p><em>主要区别是使用了 C++ 的引用，而不是传递指针。 引用是 C++ 中的特性，允许在函数中修改传递的参数，而无需显式地使用指针</em></p>
</blockquote>
<ol>
<li><p>定义：<br> 在C++中，引用是一个别名，它提供了对变量的另一个名称。引用在C++中是通过使用 <strong>&amp;</strong> 符号进行声明和定义的。引用必须在初始化时被绑定到一个对象，而且一旦绑定，它将一直引用该对象。</p>
</li>
<li><p>基本语法：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type &amp;refName = originalVariable;</span><br></pre></td></tr></table></figure>

<p> 其中，<strong>type</strong> 是原始变量的类型，<strong>refName</strong> 是引用的名称，<strong>originalVariable</strong> 是原始变量。引用的声明和初始化必须同时进行。</p>
</li>
<li><p>示例：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b = <span class="number">99</span>;  <span class="comment">// 修改引用，也会修改原始变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其中：b 是 a 的引用，它们实际上指向同一个内存地址。因此，对 b 的修改也会影响到 a。</p>
</li>
<li><p>引用有一些重要的特性和规则：</p>
<blockquote>
<ol>
<li>引用必须在声明时初始化，而且一旦初始化，就无法改变引用的目标。</li>
<li>引用不占用额外的内存空间，它只是目标变量的另一个名字。</li>
<li>引用通常用于函数参数，允许在函数中直接操作原始变量，而不是其副本。</li>
<li>引用用于提供对对象的更直观、更自然的访问。</li>
</ol>
</blockquote>
<p> 引用在C++中广泛用于函数传递、返回引用值、操作符重载等场景。</p>
</li>
<li><p>引用和指针的异同：<br> 引用（Reference）和指针（Pointer）是 C++ 中两种用于引用和操作变量的机制，它们有相似之处，也有一些重要的区别。以下是引用和指针的异同点：</p>
</li>
</ol>
<p><strong>相同点：</strong></p>
<ol>
<li><strong>别名机制：</strong><br>引用和指针都提供了对变量的别名机制，可以通过它们来访问和操作变量。</li>
<li><strong>用于传递参数：</strong><br>引用和指针都可以用于函数参数，使得函数能够直接操作原始变量，而不是对变量的副本进行操作。</li>
<li><strong>用于修改变量值：</strong><br>通过引用或指针，可以修改原始变量的值，而不仅仅是传递它们的副本。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li><strong>语法和操作：</strong><ul>
<li><strong>引用：</strong><ul>
<li>引用在声明时使用 &amp; 符号，例如 int &amp;ref &#x3D; variable;。</li>
<li>引用一旦初始化，就不能再引用其他变量，一直引用同一个对象。</li>
<li>引用不需要使用解引用操作符（*）来访问目标对象。</li>
<li>引用不能为 NULL，引用必须在初始化时指向一个有效的对象。</li>
</ul>
</li>
<li><strong>指针：</strong><ul>
<li>指针在声明时使用 * 符号，例如 int *ptr &#x3D; &variable;。</li>
<li>指针可以在任何时候重新指向其他对象。</li>
<li>使用解引用操作符（*）来访问目标对象。</li>
<li>指针可以为 NULL，即指向空地址，表示不指向任何有效的对象。</li>
</ul>
</li>
</ul>
</li>
<li><strong>内存占用：</strong><ul>
<li><strong>引用：</strong><ul>
<li>引用在内存中不占用额外的空间，它只是目标变量的别名。</li>
</ul>
</li>
<li><strong>指针：</strong><ul>
<li>指针需要占用额外的内存空间来存储变量的地址。</li>
</ul>
</li>
</ul>
</li>
<li><strong>空引用和空指针：</strong><ul>
<li><strong>引用：</strong><ul>
<li>引用在定义时必须初始化，不存在空引用的概念。</li>
</ul>
</li>
<li><strong>指针：</strong><ul>
<li>指针可以为 NULL，表示不指向任何有效的对象，称为空指针。</li>
</ul>
</li>
</ul>
</li>
<li><strong>操作符重载：</strong><ul>
<li>引用不支持操作符重载。</li>
<li>指针支持操作符重载，可以通过指针实现一些底层的操作。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>引用：</strong><ul>
<li>适用于不需要改变指向的情况，提供了更直观的语法。</li>
</ul>
</li>
<li><strong>指针：</strong><ul>
<li>适用于需要在运行时改变指向的情况，更灵活。</li>
</ul>
</li>
</ul>
</li>
<li><strong>访问对象成员：</strong><ul>
<li><strong>引用：</strong><ul>
<li>引用使用 <code>.</code><strong>点运算符</strong>访问对象的成员，因为引用本质上是一个别名，就是绑定到某个对象上的别名，它可以像对象本身一样访问成员。</li>
</ul>
</li>
<li><strong>指针:</strong><ul>
<li>当有一个指向结构体或类的指针时，使用<code>-&gt;</code><strong>箭头运算符</strong>来访问对象的成员。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>在选择使用引用还是指针时，取决于具体的场景和需求：<strong>通常情况下，引用更适用于作为函数参数传递，而指针更适用于需要动态分配内存、在运行时改变指向等场景。</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-08 12:22:10</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/**定义模块**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 用静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;    <span class="comment">// 队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(SqQueue &amp;Q)</span></span>; <span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span></span>;    <span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">(SqQueue Q)</span></span>;     <span class="comment">// 判满</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span></span>;   <span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span>; <span class="comment">// 出队，用 e 返回</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span>;  <span class="comment">// 获取队头元素，用 e 返回</span></span><br><span class="line"><span class="comment">/**定义模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printQueue</span><span class="params">(SqQueue Q)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**实现模块**/</span></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;   <span class="comment">// 初始化时，队头队尾都指向 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Q.rear == Q.front )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为满</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (Q.rear + <span class="number">1</span>) % MaxSize == Q.front )&#123;   <span class="comment">// 牺牲一个单元区分队空和队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果队列已满直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isFull</span>(Q) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;    <span class="comment">// 通过取余操作让整个队列循环起来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果队列为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**实现模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br><span class="line"><span class="comment">// 打印整个队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始打印队列\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ( Q.front != Q.rear )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Q.data[Q.front]);</span><br><span class="line">        Q.front = (Q.front + <span class="number">1</span>) % MaxSize;  <span class="comment">// 输出后更新下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结束打印\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始测试\n&quot;</span>);</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">initQueue</span>(Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">1</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功！\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">2</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功！\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">3</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功！\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printQueue</span>(Q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">outQueue</span>(Q, e) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队成功，弹出的元素是：%d\n&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">getHead</span>(Q, e) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取队头成功！队头元素是：%d\n&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取队头失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队非空\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结束测试\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-链式队列"><a href="#5-2-链式队列" class="headerlink" title="5.2 链式队列"></a>5.2 链式队列</h2><h3 id="5-2-0-头结点有无与否"><a href="#5-2-0-头结点有无与否" class="headerlink" title="5.2.0 头结点有无与否"></a>5.2.0 头结点有无与否</h3><p>在链式队列中，是否使用头结点<strong>主要影响链表的头指针和尾指针的处理方式</strong>。</p>
<ol>
<li><p><strong>带头结点的链式队列：</strong></p>
<blockquote>
<ul>
<li><strong>头结点存在：</strong> 链表中会额外添加一个头结点，头结点的 Next 指针指向队列的头元素，而尾指针指向队列的尾元素。这样，头结点的存在使得链表中的每个节点都有一个前驱节点。</li>
<li><strong>操作方便：</strong> 在插入和删除操作时，无需特殊处理头节点的情况，简化了代码逻辑。</li>
<li><strong>判空方便：</strong> 判断队列是否为空可以通过检查头结点的 Next 指针是否为空来实现。</li>
</ul>
</blockquote>
</li>
<li><p><strong>不带头结点的链式队列：</strong></p>
<blockquote>
<ul>
<li><strong>头结点不存在：</strong> 链表的头指针直接指向队列的头元素，而尾指针指向队列的尾元素。链表中的第一个节点即为队列的头元素。</li>
<li><strong>操作需特殊处理：</strong> 在插入和删除操作时，需要特殊处理头节点的情况，因为头节点和其他节点的处理方式不同。</li>
<li><strong>判空需特殊处理：</strong> 判断队列是否为空通常需要检查头指针和尾指针是否相等，因为没有头结点来帮助判断。</li>
</ul>
</blockquote>
</li>
</ol>
<p>选择是否使用头结点主要取决于具体的设计需求和实现偏好。<br>带头结点的链表在某些情况下（<strong>适用于对插入和删除操作的简洁性有较高要求的情况</strong>）对边界情况的处理上更加方便，可以使代码更加简洁；而不带头结点的链表（<strong>适用于对内存占用比较敏感的情况，且可以接受插入和删除操作的代码逻辑稍微复杂一些</strong>）更接近实际队列的逻辑。</p>
<h3 id="5-2-1-C-——郝斌老师"><a href="#5-2-1-C-——郝斌老师" class="headerlink" title="5.2.1 C++——郝斌老师"></a>5.2.1 C++——郝斌老师</h3><h4 id="5-2-1-1-Clear"><a href="#5-2-1-1-Clear" class="headerlink" title="5.2.1.1 Clear();"></a>5.2.1.1 Clear();</h4><p><strong>错误写法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>( !<span class="keyword">this</span>-&gt;<span class="built_in">isEmpty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">outQueue</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确写法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Out_Queue</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不需要使用循环：在每次调用 Out_Queue 之后，函数内部已经包含了循环的逻辑。只要队列不为空，就会一直执行出队操作。因此，在 Clear_Queue 中只需调用一次 Out_Queue 即可达到清空队列的目的。</p>
<h4 id="5-2-1-2-Queue"><a href="#5-2-1-2-Queue" class="headerlink" title="5.2.1.2 ~Queue();"></a>5.2.1.2 ~Queue();</h4><p><strong>错误写法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">Queue</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确写法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">Queue</span>()&#123;</span><br><span class="line">    <span class="built_in">Clear</span>();</span><br><span class="line">    <span class="keyword">delete</span> pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>在析构函数中不需要显式调用 this-&gt;Clear()，因为析构函数会在对象销毁时自动调用。</em></p>
<p>在C++中，<strong>类的析构函数（Destructor）</strong>是一个特殊的成员函数，它在对象被销毁时自动调用。析构函数的作用是释放对象占用的资源，执行清理工作。</p>
<p>在示例代码中，析构函数的主要目的是清理队列，即释放队列中节点所占用的内存。已经定义了 <strong>Clear</strong> 函数来完成这个清理工作，所以在析构函数中调用 <strong>Clear</strong> 是合理的。</p>
<p>然而，<strong>根据C++的析构函数自动调用机制</strong>，如果析构函数中没有显式调用 <strong>Clear</strong>，对象销毁时也会自动调用 <strong>Clear</strong>，因为 <strong>Clear</strong> 包含了释放队列中节点内存的逻辑。</p>
<p>所以，可以不在析构函数中显式调用 <strong>Clear</strong>，而是依赖析构函数自动调用它。这样的做法更加简洁，因为析构函数的主要职责是清理资源，而 <strong>Clear</strong> 已经负责了这部分工作。</p>
<hr>
<p><strong>带头结点。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-08 20:05:37</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带头结点版本。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *pNext;</span><br><span class="line">&#125;NODE, *PNODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PNODE pHead, pTail; <span class="comment">// pHead指向无用的头结点 pHead-&gt;pNext才是指向队首元素, pTail指向队尾元素</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Queue</span>() : <span class="built_in">pHead</span>(<span class="keyword">new</span> NODE), <span class="built_in">pTail</span>(pHead)&#123;    <span class="comment">// 在构造函数中使用初始化列表</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;pHead-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数：在对象被销毁时自动调用</span></span><br><span class="line">    ~<span class="built_in">Queue</span>()&#123;</span><br><span class="line">        <span class="built_in">Clear</span>();</span><br><span class="line">        <span class="keyword">delete</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历队列元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Traverse</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>() )&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列为空，无法遍历！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        PNODE pTemp = <span class="keyword">this</span>-&gt;pHead-&gt;pNext;</span><br><span class="line">        <span class="keyword">while</span> ( pTemp != <span class="literal">nullptr</span> )&#123;</span><br><span class="line">            cout &lt;&lt; pTemp-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            pTemp = pTemp-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">// 简化返回语句</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;pHead == <span class="keyword">this</span>-&gt;pTail);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        PNODE pNew = <span class="keyword">new</span> NODE;</span><br><span class="line">        pNew-&gt;data = val;</span><br><span class="line">        pNew-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>-&gt;pTail-&gt;pNext = pNew;  <span class="comment">// 将pNew挂到队列尾部</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;pTail = pNew; <span class="comment">// 注意是尾指针上移</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">outQueue</span><span class="params">(<span class="type">int</span> &amp;val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>() )&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列为空，无法出队！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PNODE pTemp = <span class="keyword">this</span>-&gt;pHead-&gt;pNext;   <span class="comment">//pHead不是要删除的队首元素，pHead-&gt;pNext所指向的元素才是要删除的元素</span></span><br><span class="line">        val = pTemp-&gt;data;  <span class="comment">// 保存出队元素</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;pHead-&gt;pNext = pTemp-&gt;pNext;  <span class="comment">// 更新首节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> pTemp;</span><br><span class="line">        pTemp = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == <span class="keyword">this</span>-&gt;pHead-&gt;pNext)&#123;  <span class="comment">// 如果队列为空</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;pTail = <span class="keyword">this</span>-&gt;pHead;       <span class="comment">// 尾指针要指向无用的头结点，则将 pTail 移回 pHead</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空队列</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="built_in">outQueue</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )&#123;</span><br><span class="line">        Q.<span class="built_in">enQueue</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.<span class="built_in">Traverse</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> ( Q.<span class="built_in">outQueue</span>(val) )&#123; <span class="comment">// 用引用代替&amp;val</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;出队成功，出队的元素是: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;出队失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Q.<span class="built_in">Traverse</span>();</span><br><span class="line">    </span><br><span class="line">    Q.<span class="built_in">Clear</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-C——浙大数据结构"><a href="#5-2-2-C——浙大数据结构" class="headerlink" title="5.2.2 C——浙大数据结构"></a>5.2.2 C——浙大数据结构</h3><blockquote>
<p><em><a target="_blank" rel="noopener" href="https://blog.csdn.net/liyuanyue2017/article/details/83688306">CSDN——数据结构（四）队列</a></em></p>
</blockquote>
<p><strong>不带头结点。</strong></p>
<p>​队列的链式存储结构也可以用一个单链表实现。插入和删除操作分别在链表的两头进行，front 在链表头，rear 在链表尾，从 rear 入队，从 front 出队。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-08 21:55:20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列（不带带头节点版本）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span>  <span class="comment">// 指向队尾结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span> <span class="comment">// 指向队头结点</span></span><br><span class="line">&#125;*Queue;</span><br><span class="line"></span><br><span class="line">Queue <span class="title function_">createQueue</span><span class="params">()</span>;    <span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addQueue</span><span class="params">(Queue Q, ElemType e)</span>; <span class="comment">// 入队</span></span><br><span class="line">ElemType <span class="title function_">deleteQueue</span><span class="params">(Queue Q)</span>;  <span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue Q)</span>;   <span class="comment">// 判空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Q = createQueue();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;入队 5\n&quot;</span>);</span><br><span class="line">    addQueue(Q,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;入队 4\n&quot;</span>);</span><br><span class="line">    addQueue(Q,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;入队 3\n&quot;</span>);</span><br><span class="line">    addQueue(Q,<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队 %d\n&quot;</span>, deleteQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队 %d\n&quot;</span>, deleteQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队 %d\n&quot;</span>, deleteQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, deleteQueue(Q));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue <span class="title function_">createQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">    Q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q-&gt;front == <span class="literal">NULL</span> ); <span class="comment">// 头结点为空时队空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addQueue</span><span class="params">(Queue Q, ElemType e)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    </span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == Q-&gt;front )&#123;</span><br><span class="line">        <span class="comment">// 不带头节点插入第一个元素时，需做特殊处理</span></span><br><span class="line">        Q-&gt;rear = Q-&gt;front = p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非第一个元素</span></span><br><span class="line">        Q-&gt;rear-&gt;Next = p;  <span class="comment">// 新节点插入到 rear 之后</span></span><br><span class="line">        Q-&gt;rear = p;        <span class="comment">// 修改尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">deleteQueue</span><span class="params">(Queue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( isEmpty(Q) )&#123;      <span class="comment">// 即 Q.front == NULL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列空 &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span> =</span> Q-&gt;front;  <span class="comment">// 用指针 p 记录队头</span></span><br><span class="line">    ElemType x = p-&gt;data;       <span class="comment">// 用 x 返回队头元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不带头节点最后一个节点出队时，需做特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> ( Q-&gt;rear == p )&#123;</span><br><span class="line">        Q-&gt;rear = Q-&gt;front = <span class="literal">NULL</span>;  <span class="comment">// 修改 rear 指针为空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;front = p-&gt;Next; <span class="comment">// 队头指向下一个队头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-C-——王道"><a href="#5-2-3-C-——王道" class="headerlink" title="5.2.3 C++——王道"></a>5.2.3 C++——王道</h3><blockquote>
<ul>
<li><em><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_55593227/article/details/123598044">数据结构学习笔记（王道）</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://www.iloveflag.com/2021/11/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0">数据结构-王道考研复习笔记 · iloveflag’s Blog</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/CodePanda66/CSPostgraduate-408/blob/master/DataStructure/Src/DS_2_StackAndQueue/DS_2_3_SqQueue0.cpp">CSPostgraduate-408&#x2F;DataStructure&#x2F;Src&#x2F;DS_2_StackAndQueue&#x2F;DS_2_3_SqQueue0.cpp</a></em></li>
</ul>
</blockquote>
<p><strong>带头结点。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @Akari</span></span><br><span class="line"><span class="comment"> * @date: 2024-01-08 21:55:58</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列（带头结点版本）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**定义模块**/</span></span><br><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *Next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear; <span class="comment">// 头指针和尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>;   <span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(LinkQueue &amp;Q, <span class="type">int</span> x)</span></span>;  <span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(LinkQueue &amp;Q, <span class="type">int</span> &amp;x)</span></span>; <span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getHead</span><span class="params">(LinkQueue Q, <span class="type">int</span> &amp;x)</span></span>;  <span class="comment">// 获取头元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQueue Q)</span></span>;      <span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>;  <span class="comment">// 清空</span></span><br><span class="line"><span class="comment">/**定义模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**实现模块**/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> ( Q.front == <span class="literal">nullptr</span> )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front-&gt;Next = <span class="literal">nullptr</span>;    <span class="comment">// 初始化时，front、rear 都指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(LinkQueue &amp;Q, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判满？链式存储一般不需要判满，除非内存不足</span></span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> ( s == <span class="literal">nullptr</span> )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;Next = <span class="literal">nullptr</span>;</span><br><span class="line">    Q.rear-&gt;Next = s;   <span class="comment">// 新节点插入到 rear 之后</span></span><br><span class="line">    Q.rear = s;     <span class="comment">// 更新尾指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(LinkQueue &amp;Q, <span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LinkNode *p = Q.front-&gt;Next;    <span class="comment">// 指针p 记录队头元素</span></span><br><span class="line">    x = p-&gt;data;    <span class="comment">// x 返回队头元素</span></span><br><span class="line">    Q.front-&gt;Next = p-&gt;Next;    <span class="comment">// 修改头节点的Next指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一个节点出队时</span></span><br><span class="line">    <span class="keyword">if</span> ( Q.rear == p )&#123;</span><br><span class="line">        Q.rear = Q.front;   <span class="comment">// 修改rear指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getHead</span><span class="params">(LinkQueue Q, <span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = Q.front-&gt;Next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">deQueue</span>(Q, x) )&#123;</span><br><span class="line">        <span class="comment">// 依次出队，释放所有节点内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(Q.front);  <span class="comment">// 释放头结点内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**实现模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br><span class="line"><span class="comment">// 打印函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printQueue</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始打印\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    LinkNode *temp = Q.front-&gt;Next; <span class="comment">// 使用临时指针 temp，避免改变原视队列的状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( temp != Q.rear )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n打印完成\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testLinkQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始测试！\n&quot;</span>);</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">initQueue</span>(Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">1</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功 1\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">2</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功 2\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">enQueue</span>(Q, <span class="number">3</span>) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队成功 3\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;入队失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printQueue</span>(Q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">deQueue</span>(Q, x) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队成功，弹出的元素是 %d\n&quot;</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">getHead</span>(Q, x) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取队头成功，队头元素是 %d\n&quot;</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取队头元素失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>(Q) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队非空\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">clearQueue</span>(Q);  <span class="comment">// 清理队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;测试结束！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**测试模块**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testLinkQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picdl.sunbangyan.cn/2023/11/24/b45e6fde93484c373c0976fab70d6963.jpeg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picdl.sunbangyan.cn/2023/11/24/b45e6fde93484c373c0976fab70d6963.jpeg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Akari</div><div class="post-copyright__author_desc">为什么要演奏春日影！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/posts/41925/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/posts/41925/')">队列——之二</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/posts/41925/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=队列——之二&amp;url=http://example.com/posts/41925/&amp;pic=https://picss.sunbangyan.cn/2024/01/05/bdd191fc11d3ab4fe207cbcba732b3ee.jpeg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Akari的小站</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>数据结构与算法<span class="tagsPageCount">15</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://picss.sunbangyan.cn/2024/01/05/bdd191fc11d3ab4fe207cbcba732b3ee.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/14941/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picss.sunbangyan.cn/2023/12/29/e05cef3ba13bc87d79c4ebda6b404278.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">栈——之二</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/53020/" title="递归—汉诺塔"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-07</div><div class="title">递归—汉诺塔</div></div></a></div><div><a href="/posts/61129/" title="十大排序—选择排序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picdm.sunbangyan.cn/2023/12/09/da37c57735537198e26ccaa45c035525.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-09</div><div class="title">十大排序—选择排序</div></div></a></div><div><a href="/posts/23318/" title="静态 链式二叉树"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-20</div><div class="title">静态 链式二叉树</div></div></a></div><div><a href="/posts/13537/" title="队列（循环队列）—— 线性结构的应用之一"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-23</div><div class="title">队列（循环队列）—— 线性结构的应用之一</div></div></a></div><div><a href="/posts/45748/" title="单链表"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-23</div><div class="title">单链表</div></div></a></div><div><a href="/posts/7017/" title="队列（链式队列）—— 线性结构的应用之一"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picdm.sunbangyan.cn/2023/12/09/5dec8a63f6710afecbf6b54eb5eaef32.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-23</div><div class="title">队列（链式队列）—— 线性结构的应用之一</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Waline</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picdl.sunbangyan.cn/2023/11/24/b45e6fde93484c373c0976fab70d6963.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">总有一天，每个人会和这个故事告别，走向不同的方向，独属于你自己的下一页。但是那样就好，累了的话就停下脚步，怀念的话就回来看看这个故事也一直都在。且行且看，尽力而为，不要害怕，不要后悔。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Akari</h1><div class="author-info__desc">为什么要演奏春日影！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/akari2333" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">2. 分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">3. 应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AD%A6%E4%B9%A0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E9%9C%80%E5%BC%84%E6%B8%85%E6%A5%9A%E7%9A%84-7-%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">4. 学习循环队列需弄清楚的 7 个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">5. 代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%9D%99%E6%80%81%E9%98%9F%E5%88%97%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 静态队列（循环队列）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-C%E2%80%94%E2%80%94%E9%83%9D%E6%96%8C%E8%80%81%E5%B8%88"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 C——郝斌老师</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-C%E2%80%94%E2%80%94%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 C——浙大数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-C-%E2%80%94%E2%80%94%E7%8E%8B%E9%81%93"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3 C++——王道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-1-C-%E5%BC%95%E7%94%A8"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">5.1.3.1 C++ 引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 链式队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-0-%E5%A4%B4%E7%BB%93%E7%82%B9%E6%9C%89%E6%97%A0%E4%B8%8E%E5%90%A6"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.0 头结点有无与否</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-C-%E2%80%94%E2%80%94%E9%83%9D%E6%96%8C%E8%80%81%E5%B8%88"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.1 C++——郝斌老师</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-1-Clear"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">5.2.1.1 Clear();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-2-Queue"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">5.2.1.2 ~Queue();</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-C%E2%80%94%E2%80%94%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.2 C——浙大数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-C-%E2%80%94%E2%80%94%E7%8E%8B%E9%81%93"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.3 C++——王道</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/41925/" title="队列——之二"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picss.sunbangyan.cn/2024/01/05/bdd191fc11d3ab4fe207cbcba732b3ee.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="队列——之二"/></a><div class="content"><a class="title" href="/posts/41925/" title="队列——之二">队列——之二</a><time datetime="2024-01-04T12:22:50.000Z" title="发表于 2024-01-04 20:22:50">2024-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/14941/" title="栈——之二"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picss.sunbangyan.cn/2023/12/29/e05cef3ba13bc87d79c4ebda6b404278.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈——之二"/></a><div class="content"><a class="title" href="/posts/14941/" title="栈——之二">栈——之二</a><time datetime="2023-12-29T13:47:00.000Z" title="发表于 2023-12-29 21:47:00">2023-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/12893/" title="单链表——之二"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picdm.sunbangyan.cn/2023/12/29/d8fe1546fb87cd8c88deea5c1465b4be.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单链表——之二"/></a><div class="content"><a class="title" href="/posts/12893/" title="单链表——之二">单链表——之二</a><time datetime="2023-12-29T13:24:03.000Z" title="发表于 2023-12-29 21:24:03">2023-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/19788/" title="在这片绝望的大地上，踏上希望的旅途评测《星之终途》"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picdl.sunbangyan.cn/2023/12/22/b5e36b90d2f300b24abaa26097ce4373.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在这片绝望的大地上，踏上希望的旅途评测《星之终途》"/></a><div class="content"><a class="title" href="/posts/19788/" title="在这片绝望的大地上，踏上希望的旅途评测《星之终途》">在这片绝望的大地上，踏上希望的旅途评测《星之终途》</a><time datetime="2023-12-22T01:42:49.000Z" title="发表于 2023-12-22 09:42:49">2023-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/32623/" title="Galgame的艺术——废萌与剧情作的优美崇高之争"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://picdl.sunbangyan.cn/2023/12/22/5781ce2c358bf9fd40ce6ee89d3a3360.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Galgame的艺术——废萌与剧情作的优美崇高之争"/></a><div class="content"><a class="title" href="/posts/32623/" title="Galgame的艺术——废萌与剧情作的优美崇高之争">Galgame的艺术——废萌与剧情作的优美崇高之争</a><time datetime="2023-12-22T01:42:19.000Z" title="发表于 2023-12-22 09:42:19">2023-12-22</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Akari" target="_blank">Akari</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">9</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/ACGN/" style="font-size: 0.88rem;">ACGN<sup>1</sup></a><a href="/tags/AcWing-C-%E5%9F%BA%E7%A1%80%E8%AF%BE/" style="font-size: 0.88rem;">AcWing C++基础课<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C#<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>1</sup></a><a href="/tags/Markdown/" style="font-size: 0.88rem;">Markdown<sup>2</sup></a><a href="/tags/Unity/" style="font-size: 0.88rem;">Unity<sup>1</sup></a><a href="/tags/blog/" style="font-size: 0.88rem;">blog<sup>2</sup></a><a href="/tags/galgame/" style="font-size: 0.88rem;">galgame<sup>4</sup></a><a href="/tags/hexo/" style="font-size: 0.88rem;">hexo<sup>2</sup></a><a href="/tags/%E5%8F%91%E7%99%AB%E6%97%A5%E5%B8%B8/" style="font-size: 0.88rem;">发癫日常<sup>2</sup></a><a href="/tags/%E5%BD%92%E6%A1%A3%EF%BC%88%E6%8B%96%E6%9B%B4%E2%88%9A%EF%BC%89/" style="font-size: 0.88rem;">归档（拖更√）<sup>3</sup></a><a href="/tags/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/" style="font-size: 0.88rem;">排序和查找<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">数据结构与算法<sup>15</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/" style="font-size: 0.88rem;">生活日常<sup>2</sup></a><a href="/tags/%E7%A9%BA-%E6%97%A0/" style="font-size: 0.88rem;">空_无<sup>5</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">计算机组成原理<sup>1</sup></a><a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 0.88rem;">递归<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8923265151" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/playlist?id=8923265151&amp;userid=310905058&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/medium-zoom@1.0.8/dist/medium-zoom.min.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("11/03/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Akari 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("11/03/2023 10:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
      img.title = "下班了就该开开心心的玩耍，嘿嘿~";
      img.alt = "下班了就该开开心心的玩耍，嘿嘿~";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://waline-blog-hxla8mye0-akari2333s-projects.vercel.app/',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://waline-blog-hxla8mye0-akari2333s-projects.vercel.app/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const initWaline = () => {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: '',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
    }, null))
  }

  const loadWaline = async () => {
    if (typeof Waline === 'object') initWaline()
    else {
      await getCSS('https://cdn.cbd.int/@waline/client@2.15.5/dist/waline.css')
      await getScript('https://cdn.cbd.int/@waline/client@2.15.5/dist/waline.js')
      initWaline()
    }
  }

  if ('Twikoo' === 'Waline' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://waline-blog-hxla8mye0-akari2333s-projects.vercel.app/',
        region: 'ap-shanghai',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>